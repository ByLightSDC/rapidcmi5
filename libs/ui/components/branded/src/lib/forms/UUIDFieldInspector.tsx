/*
 *   Copyright (c) 2023 - 2024 By Light Professional IT Services LLC
 *   All rights reserved.
 */
/* eslint-disable @typescript-eslint/no-explicit-any */

/*
The component resolves UUID to a friendly display name
And displays a preview icon that can be clicked to pop a form
Form can be opened in any crud mode (view, edit, create), but NOTE that you can not present 2 React forms in a modal
Because we use react hook form , clicking submit button in one form will trigger all submit buttons in modal
*/

import React, { useEffect, useState } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { useNavigate } from 'react-router';
import { FormCrudType, setModal } from '@rangeos-nx/ui/redux';

import EditIcon from '@mui/icons-material/Edit';
import PreviewIcon from '@mui/icons-material/Preview';

import TextField from '@mui/material/TextField';

import { ButtonIcon } from '@rangeos-nx/ui/api/hooks';
import { LoadingUi } from '../indicators/Loading';
import DataCacheOrFetcher from './DataCacheOrFetcher';
import { tFormControlTextFieldProps } from './FormControlTextField';
import ReadOnlyTextField from './ReadOnlyTextField';

/**
 * @interface iUUIDFieldInspectorProps
 * @property {tFormControlTextFieldProps}
 * @property {string} [defaultValue]
 * @property {*} [setError] React Hook Form function to set error on field when api error occurs
 * @property {(fieldName: string, selectModalId?: string) => void} [onClear] Method to call when clear button for field is clicked
 * @property {(fieldName: string) => void} [onChange] Method to call when key value is changed
 * @property {boolean} [isValid] React hook form valid indicator
 */
interface iUUIDFieldInspectorProps extends tFormControlTextFieldProps {
  defaultValue?: string;
  setError?: any;
  onClear?: (fieldName: string, selectModalId?: string) => void;
  onChange?: (fieldName: string) => void;
  isValid?: boolean;
}

/**
 * @interface tUUIDFieldInspectorProps
 * @property {string} [initialAlias] Optional initial value for "name" field
 * @property {string} [aliasProperty] Override property for "name" field
 * @property {any} [apiHook] Hook for getting individual item by uuid
 * @property {(data: any, index: number) => any} [getRenderItems] Method used to retriee additional fields to render with the name field
 * @property {FormCrudType} [crudType=FormCrudType.view] Current mode of form
 * @property {boolean} [disabled=false] Whether field is disabled
 * @property {string} [editRoute] Optional route for editting the item
 * @property {any} [filters] Optional filters to apply to api hook call
 * @property {iUUIDFieldInspectorProps} formFieldProps Props to pass to actual Text Field
 * @property {boolean} [isKeyValue = false] indicates data is in form of a key value pair
 * @property {boolean} [isModal=false] Indication of form being displayed as modal (default=false)
 * @property {string} [modalFormId] Id for form to view item in modal
 * @property {string} [selectModalId] Selection modal Id for item
 * @property {string} queryKey Key for query cache
 * @property {boolean} [shouldApplyErrors=props.crudType !== FormCrudType.design] Whether to apply error to field for api hook error
 * @property {boolean} [shouldFetch=true] Whether to fetch data thru api, if a record is generated by Scenario Design, this should typically be false. otherwise true.
 * @property {boolean} [shouldResolve=true] Whether to resolve the name
 * @property {*} [sxInputProps] sx props passed to internal input field
 * @property {*} [textFieldProps] Any additional MUI TextField props needed (e.g., required)
 * @property {string} [topicId] ID of Topic
 * @property {string} uuid Current uuid of item
 * @property {(data?: any) => void} [onDataLoaded] Optional method to call when data is loaded thru api
 */
export type tUUIDFieldInspectorProps = {
  initialAlias?: string;
  aliasProperty?: string;
  apiHook?: any;
  getRenderItems?: (data: any, index: number) => JSX.Element | null | undefined;
  crudType?: FormCrudType; //whether form view will be editable
  disabled?: boolean;
  editRoute?: string;
  filters?: any;
  formFieldProps: iUUIDFieldInspectorProps;
  isKeyValue?: boolean;
  isModal?: boolean;
  modalFormId?: string;
  selectModalId?: string;
  queryKey: string;
  shouldApplyErrors?: boolean;
  shouldFetch?: boolean;
  shouldResolve?: boolean;
  sxInputProps?: any;
  textFieldProps?: any;
  topicId?: string;
  uuid: string;
  onDataLoaded?: (data?: any) => void;
};

export function UUIDFieldInspector(props: tUUIDFieldInspectorProps) {
  const {
    initialAlias,
    aliasProperty = 'name',
    apiHook,
    getRenderItems,
    crudType = FormCrudType.view,
    disabled = false,
    editRoute,
    filters = {},
    formFieldProps,
    isKeyValue = false,
    modalFormId,
    onDataLoaded,
    selectModalId,
    queryKey,
    shouldApplyErrors = props.crudType !== FormCrudType.design,
    shouldFetch = true,
    shouldResolve = true,
    sxInputProps = {},
    textFieldProps = {},
    topicId,
    uuid,
  } = props;

  const navigate = useNavigate();
  const [readyToLoad, setReadyToLoad] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [isModalTriggered, setIsModalTriggered] = useState(false);
  const [data, setData] = useState<any>(null);
  const [apiRequestError, setApiRequestError] = useState<any>(null);
  //initialAlias is the key for key value pairs otherwise, its the field value
  const [alias, setAlias] = useState(
    initialAlias ? initialAlias : isKeyValue ? '' : uuid,
  );
  const dispatch = useDispatch();
  const fieldError = formFieldProps.error;
  const fieldHelperText = formFieldProps.helperText;

  const options = {
    ...filters,
  };

  let shouldFetchFeature = shouldFetch;

  //feature flags
  const isModalEditable =
    crudType === FormCrudType.create || crudType === FormCrudType.edit;

  //combine flags into single check
  const shouldFetchFlag = shouldFetch && !disabled && readyToLoad;

  //cached data
  const cacheData: any = null;

  if (crudType === FormCrudType.design && cacheData?.name) {
    shouldFetchFeature = false;
  }
  //default data
  const defaultData: any = cacheData || {
    isNotValid: true,
    [aliasProperty]: '',
  };

  /** Editable fields, user can specify their own alias
   * this value bubbles up to parent form
   */
  const handleChange = (text: string) => {
    setAlias(text);
    if (formFieldProps.onChange) {
      formFieldProps.onChange(text);
    }
  };

  /** Field cleared
   * this value bubbles up to parent form
   */
  const handleClearSelection = () => {
    setIsLoading(false);
    setReadyToLoad(false);
    setData(null);
    setAlias('');
    setApiRequestError(null);
    if (formFieldProps.onClear) {
      formFieldProps.onClear(formFieldProps.name, selectModalId);
    }
  };

  /** Launches modal form
   */
  const handleViewOrEditData = (event: React.MouseEvent<HTMLElement>) => {
    event.stopPropagation();
    setIsModalTriggered(true);
    //Pull from Common or fallback on last load

    if (editRoute) {
      navigate(editRoute + '/' + uuid);
    }
  };

  /** Applies loaded data to alias and form launcher
   */
  const applyData = (data: any) => {
    setData(data);
    setIsLoading(false);
    if (shouldResolve) {
      if (Object.prototype.hasOwnProperty.call(data, aliasProperty)) {
        setAlias(data[aliasProperty]);
      }
    } else {
      setAlias(initialAlias || '');
    }
    setApiRequestError(null);
  };

  /**Data is loaded via fetcher component
   * Resolve alias from data
   */
  const handleInitialDataLoad = (data: any) => {
    applyData(data);
    if (onDataLoaded) {
      onDataLoaded(data);
    }
  };

  /**
   * Handles error returned from API call
   * If formFieldProps passes in setError, then a manual form error is set for this field
   * @param {any} error error returned from api call
   */
  const handleInitialDataError = (error: any) => {
    setApiRequestError(error);

    if (shouldApplyErrors) {
      if (formFieldProps.setError) {
        formFieldProps.setError(formFieldProps.name, {
          type: 'api read error',
          message: error,
        });
      }
    }

    //no longer loading since there was an error
    setIsLoading(false);
    setReadyToLoad(false); // so we won't keep trying to reload a controlled field
  };

  /**
   * UE listens for uuid and cache changes
   * Updates alias and data accordingly
   * Resets loading & error flags
   */
  useEffect(() => {
    //check empty or cleared, echo handleClearSelection but re-mount alias
    if (!uuid) {
      setIsLoading(false);
      setReadyToLoad(false);
      setData(null);
      setAlias(initialAlias || uuid); //same as mount
      setApiRequestError(null);
      return;
    }

    //check for updated cached date
    // REF this causes a bug
    // if (!defaultData.hasOwnProperty('isNotValid')) {
    //   debuggerLog('or cache changed', defaultData);
    //   //alias exists, use cached data
    //   setIsLoading(false);
    // handleInitialDataLoad(defaultData);

    // } else {

    if (!shouldFetchFeature) {
      if (shouldResolve && cacheData?.name) {
        setAlias(cacheData?.name);
        return;
      }
      setAlias(initialAlias || uuid);
      return;
    }

    //triggers a fresh load
    setIsLoading(true);
    setData(null);
    setApiRequestError(null);
    setReadyToLoad(true);
    // }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [uuid, defaultData[aliasProperty]]);

  return (
    <>
      {shouldFetchFlag && apiHook && (
        <DataCacheOrFetcher
          apiHook={apiHook}
          payload={options}
          queryKey={queryKey}
          errorMessage=""
          showIndicator={false}
          shouldSuppressToaster={true}
          onDataLoad={handleInitialDataLoad}
          onError={handleInitialDataError}
        />
      )}
      {/*DO NOT CHANGE!! will break position of loading indicator -- position: relative below is so that we can overlay the loading spinner over sibling text field */}
      <div className="content-row-icons" style={{ position: 'relative' }}>
        {formFieldProps.readOnly && (
          <ReadOnlyTextField
            fieldInfo={formFieldProps.infoText ?? ''}
            fieldName={formFieldProps.name}
            fieldLabel={formFieldProps.label}
            fieldValue={isLoading ? '' : alias || ''}
            onClear={formFieldProps?.onClear ? handleClearSelection : undefined}
            sxProps={textFieldProps} //parent div is one of 2 grid children
            sxInputProps={sxInputProps}
            props={{
              fullWidth: formFieldProps.fullWidth ?? true,
              disabled: formFieldProps.disabled ?? true,
              required: formFieldProps.required ?? false,
              placeholder: isLoading && alias ? '' : formFieldProps.placeholder,
              multiline: false,
              error: fieldError,
              helperText: fieldHelperText,
              autoComplete: 'off', // to prevent console warning from [DOM]
            }}
          >
            {getRenderItems ? <>{getRenderItems(data, 0)}</> : null}
          </ReadOnlyTextField>
        )}
        {!formFieldProps.readOnly && (
          <TextField
            autoComplete="off"
            InputLabelProps={{ shrink: true }} // always put label above box even if empty
            InputProps={{
              sx: {
                backgroundColor: (theme: any) => `${theme.input.fill}`,

                '& .MuiOutlinedInput-root': {
                  width: 'inherit',
                  height: 'inherit',
                },
              },
              inputProps: {
                'data-testid': formFieldProps.name,
              },
            }}
            data-testid={formFieldProps.name}
            id={formFieldProps.name}
            aria-label={formFieldProps.label}
            label={formFieldProps.label}
            name={formFieldProps.name}
            value={isLoading ? '' : alias || ''}
            required={formFieldProps.required ?? false}
            error={fieldError}
            helperText={fieldHelperText}
            margin="none" //wasdense
            // for key value pairs, you can have object selected (uuid exists), but you manually cleared key
            placeholder={
              isKeyValue && uuid ? 'Enter a name' : formFieldProps.placeholder
            }
            variant="outlined"
            fullWidth={true}
            size="small"
            spellCheck={false}
            multiline={false}
            onChange={(event) => {
              handleChange(event.target.value);
            }}
          />
        )}
        {isLoading && alias && (
          <LoadingUi
            sxProps={{
              position: 'absolute',
              top: '16px',
              left: '4px',
              display: 'flex',
              flexDirection: 'row',
              zIndex: 999, // force it on top!
              height: '24px',
            }}
          />
        )}
        {getRenderItems ? <>{getRenderItems(data, 1)}</> : null}
        {isModalEditable && data && modalFormId && !apiRequestError && (
          <ButtonIcon
            id="Edit"
            name="Edit"
            tooltip={`Edit ${topicId}`}
            props={{
              onClick: handleViewOrEditData,
            }}
            sxProps={{ margin: '0px' }}
          >
            <EditIcon fontSize="medium" />
          </ButtonIcon>
        )}
        {!isModalEditable && data && modalFormId && !apiRequestError && (
          <ButtonIcon
            id="View"
            name="View"
            tooltip={`View ${topicId}`}
            props={{
              onClick: handleViewOrEditData,
            }}
          >
            <PreviewIcon fontSize="medium" />
          </ButtonIcon>
        )}
        {getRenderItems ? <>{getRenderItems(data, 2)}</> : null}
      </div>
    </>
  );
}
export default UUIDFieldInspector;
