/* tslint:disable */
/* eslint-disable */
/**
 * LMS-API
 * LMS-API documentation
 *
 * The version of the OpenAPI document: v1alpha1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AiGenerateCourseDataRequest
 */
export interface AiGenerateCourseDataRequest {
    /**
     * 
     * @type {string}
     * @memberof AiGenerateCourseDataRequest
     */
    'prompt'?: string;
}
/**
 * 
 * @export
 * @interface AiQueryInstructorsRequest
 */
export interface AiQueryInstructorsRequest {
    /**
     * 
     * @type {string}
     * @memberof AiQueryInstructorsRequest
     */
    'query'?: string;
}
/**
 * 
 * @export
 * @interface AuSlide
 */
export interface AuSlide {
    /**
     * 
     * @type {string}
     * @memberof AuSlide
     */
    'slideName': string;
    /**
     * 
     * @type {string}
     * @memberof AuSlide
     */
    'slideContent': string;
    /**
     * 
     * @type {Array<SlideQuiz>}
     * @memberof AuSlide
     */
    'quizzes': Array<SlideQuiz>;
}
/**
 * 
 * @export
 * @interface ClassDeployment
 */
export interface ClassDeployment {
    /**
     * The class identifier for the deployment
     * @type {string}
     * @memberof ClassDeployment
     */
    'classId': string;
    /**
     * UUID of the deployed scenario
     * @type {string}
     * @memberof ClassDeployment
     */
    'scenarioUUID': string;
    /**
     * The email of the user who deployed this class
     * @type {string}
     * @memberof ClassDeployment
     */
    'deployer': string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof ClassDeployment
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof ClassDeployment
     */
    'dateEdited'?: string;
}
/**
 * 
 * @export
 * @interface ClassDeploymentRequest
 */
export interface ClassDeploymentRequest {
    /**
     * The LMS class identifier to launch into
     * @type {string}
     * @memberof ClassDeploymentRequest
     */
    'classId': string;
    /**
     * Number of seats to provision for this class launch (>= 1)
     * @type {number}
     * @memberof ClassDeploymentRequest
     */
    'seats': number;
    /**
     * Index of the class-based scenario to launch from the course
     * @type {number}
     * @memberof ClassDeploymentRequest
     */
    'classDeploymentIndex': number;
}
/**
 * 
 * @export
 * @interface Cmi5AUMapping
 */
export interface Cmi5AUMapping {
    /**
     * The unique id of the au
     * @type {string}
     * @memberof Cmi5AUMapping
     */
    'auId': string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof Cmi5AUMapping
     */
    'author'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof Cmi5AUMapping
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof Cmi5AUMapping
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof Cmi5AUMapping
     */
    'name'?: string;
    /**
     * The scenarios associated with the au
     * @type {Array<string>}
     * @memberof Cmi5AUMapping
     */
    'scenarios': Array<string>;
}
/**
 * 
 * @export
 * @interface Cmi5BuildContentCreate
 */
export interface Cmi5BuildContentCreate {
    /**
     * The amount of time the course will take
     * @type {number}
     * @memberof Cmi5BuildContentCreate
     */
    'duration'?: number;
    /**
     * If a user can self enroll in the course
     * @type {boolean}
     * @memberof Cmi5BuildContentCreate
     */
    'selfEnrollable'?: boolean;
    /**
     * The number of users which can be enrolled into this course
     * @type {number}
     * @memberof Cmi5BuildContentCreate
     */
    'seats'?: number;
    /**
     * The list of work roles this task works towards
     * @type {Array<string>}
     * @memberof Cmi5BuildContentCreate
     */
    'workRoles'?: Array<string>;
    /**
     * General topic tags that are related to the course
     * @type {Array<string>}
     * @memberof Cmi5BuildContentCreate
     */
    'topicTags'?: Array<string>;
    /**
     * The platforms which this course utilizes
     * @type {Array<string>}
     * @memberof Cmi5BuildContentCreate
     */
    'platforms'?: Array<string>;
    /**
     * A list of user requirments for the course
     * @type {Array<string>}
     * @memberof Cmi5BuildContentCreate
     */
    'requirements'?: Array<string>;
    /**
     * The difficulty level of the course
     * @type {string}
     * @memberof Cmi5BuildContentCreate
     */
    'courseLevel'?: Cmi5BuildContentCreateCourseLevelEnum;
    /**
     * 
     * @type {File}
     * @memberof Cmi5BuildContentCreate
     */
    'file': File;
    /**
     * Whether or not to create / update au mappings for a course
     * @type {boolean}
     * @memberof Cmi5BuildContentCreate
     */
    'createAuMappings': boolean;
    /**
     * Optional project name for the cmi5 course upload
     * @type {string}
     * @memberof Cmi5BuildContentCreate
     */
    'projectName'?: string;
}

export const Cmi5BuildContentCreateCourseLevelEnum = {
    Beginner: 'beginner',
    Intermediate: 'intermediate',
    Advanced: 'advanced'
} as const;

export type Cmi5BuildContentCreateCourseLevelEnum = typeof Cmi5BuildContentCreateCourseLevelEnum[keyof typeof Cmi5BuildContentCreateCourseLevelEnum];

/**
 * 
 * @export
 * @interface Cmi5Course
 */
export interface Cmi5Course {
    /**
     * The ID of the cmi5 course on the cmi5 server
     * @type {string}
     * @memberof Cmi5Course
     */
    'cmi5ServerId'?: string;
    /**
     * The url of the cmi5 course, does not have to be unique
     * @type {string}
     * @memberof Cmi5Course
     */
    'courseId'?: string;
    /**
     * The unique url of the cmi5 course for the lms
     * @type {string}
     * @memberof Cmi5Course
     */
    'lmsId'?: string;
    /**
     * The name of the cmi5 course
     * @type {string}
     * @memberof Cmi5Course
     */
    'courseName'?: string;
    /**
     * The description of the cmi5 course
     * @type {string}
     * @memberof Cmi5Course
     */
    'courseDescription'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof Cmi5Course
     */
    'author'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof Cmi5Course
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof Cmi5Course
     */
    'dateEdited'?: string;
    /**
     * An array of the course AUs
     * @type {Array<string>}
     * @memberof Cmi5Course
     */
    'aus'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Cmi5List200Response
 */
export interface Cmi5List200Response {
    /**
     * 
     * @type {number}
     * @memberof Cmi5List200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof Cmi5List200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof Cmi5List200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Cmi5List200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<Cmi5Course>}
     * @memberof Cmi5List200Response
     */
    'data'?: Array<Cmi5Course>;
}
/**
 * 
 * @export
 * @interface Course
 */
export interface Course {
    /**
     * 
     * @type {string}
     * @memberof Course
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Course
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Course
     */
    'author'?: string;
    /**
     * 
     * @type {string}
     * @memberof Course
     */
    'dateCreated'?: string;
    /**
     * 
     * @type {string}
     * @memberof Course
     */
    'dateEdited'?: string;
    /**
     * 
     * @type {string}
     * @memberof Course
     */
    'courseType'?: string;
    /**
     * 
     * @type {string}
     * @memberof Course
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Course
     */
    'courseImage'?: string;
    /**
     * 
     * @type {CourseMeta}
     * @memberof Course
     */
    'metaData'?: CourseMeta;
    /**
     * 
     * @type {number}
     * @memberof Course
     */
    'enrolledUsers'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Course
     */
    'deployedClasses'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CourseAuModel
 */
export interface CourseAuModel {
    /**
     * 
     * @type {string}
     * @memberof CourseAuModel
     */
    'auName': string;
    /**
     * 
     * @type {string}
     * @memberof CourseAuModel
     */
    'auDescription': string;
    /**
     * 
     * @type {Array<AuSlide>}
     * @memberof CourseAuModel
     */
    'auSlides': Array<AuSlide>;
}
/**
 * 
 * @export
 * @interface CourseDataModel
 */
export interface CourseDataModel {
    /**
     * 
     * @type {string}
     * @memberof CourseDataModel
     */
    'courseTitle': string;
    /**
     * 
     * @type {string}
     * @memberof CourseDataModel
     */
    'courseDescription': string;
    /**
     * 
     * @type {Array<CourseAuModel>}
     * @memberof CourseDataModel
     */
    'aus': Array<CourseAuModel>;
}
/**
 * 
 * @export
 * @interface CourseEnrollmentRequest
 */
export interface CourseEnrollmentRequest {
    /**
     * The course id
     * @type {string}
     * @memberof CourseEnrollmentRequest
     */
    'id'?: string;
    /**
     * The type of course (CMI5 or Moodle)
     * @type {string}
     * @memberof CourseEnrollmentRequest
     */
    'type'?: CourseEnrollmentRequestTypeEnum;
}

export const CourseEnrollmentRequestTypeEnum = {
    Cmi5: 'cmi5',
    Moodle: 'moodle'
} as const;

export type CourseEnrollmentRequestTypeEnum = typeof CourseEnrollmentRequestTypeEnum[keyof typeof CourseEnrollmentRequestTypeEnum];

/**
 * 
 * @export
 * @interface CourseGetStudentEnrollments200Response
 */
export interface CourseGetStudentEnrollments200Response {
    /**
     * 
     * @type {number}
     * @memberof CourseGetStudentEnrollments200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof CourseGetStudentEnrollments200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof CourseGetStudentEnrollments200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof CourseGetStudentEnrollments200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<EnrolledCourse>}
     * @memberof CourseGetStudentEnrollments200Response
     */
    'data'?: Array<EnrolledCourse>;
}
/**
 * 
 * @export
 * @interface CourseInstructorEnrollmentRequest
 */
export interface CourseInstructorEnrollmentRequest {
    /**
     * The course id
     * @type {string}
     * @memberof CourseInstructorEnrollmentRequest
     */
    'id'?: string;
    /**
     * The type of course (CMI5 or Moodle)
     * @type {string}
     * @memberof CourseInstructorEnrollmentRequest
     */
    'type'?: CourseInstructorEnrollmentRequestTypeEnum;
    /**
     * The date the course will start for these students, leave blank to start now
     * @type {string}
     * @memberof CourseInstructorEnrollmentRequest
     */
    'startDate'?: string;
    /**
     * The date the course will end for these students
     * @type {string}
     * @memberof CourseInstructorEnrollmentRequest
     */
    'endDate'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CourseInstructorEnrollmentRequest
     */
    'userEmails'?: Array<string>;
}

export const CourseInstructorEnrollmentRequestTypeEnum = {
    Cmi5: 'cmi5',
    Moodle: 'moodle'
} as const;

export type CourseInstructorEnrollmentRequestTypeEnum = typeof CourseInstructorEnrollmentRequestTypeEnum[keyof typeof CourseInstructorEnrollmentRequestTypeEnum];

/**
 * 
 * @export
 * @interface CourseList200Response
 */
export interface CourseList200Response {
    /**
     * 
     * @type {number}
     * @memberof CourseList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof CourseList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof CourseList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof CourseList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<Course>}
     * @memberof CourseList200Response
     */
    'data'?: Array<Course>;
}
/**
 * 
 * @export
 * @interface CourseMeta
 */
export interface CourseMeta {
    /**
     * 
     * @type {string}
     * @memberof CourseMeta
     */
    'id'?: string;
    /**
     * The type of course (Moodle or CMI5)
     * @type {string}
     * @memberof CourseMeta
     */
    'courseType'?: CourseMetaCourseTypeEnum;
    /**
     * The native course id from Moodle or CMI5
     * @type {string}
     * @memberof CourseMeta
     */
    'providerCourseId'?: string;
    /**
     * The amount of time the course will take
     * @type {number}
     * @memberof CourseMeta
     */
    'duration'?: number;
    /**
     * The original content author from rapid cmi5
     * @type {string}
     * @memberof CourseMeta
     */
    'rapidCmi5CourseAuthor'?: string;
    /**
     * If a user can self enroll in the course
     * @type {boolean}
     * @memberof CourseMeta
     */
    'selfEnrollable'?: boolean;
    /**
     * If the course is mandatory
     * @type {Array<string>}
     * @memberof CourseMeta
     */
    'workRoles'?: Array<string>;
    /**
     * If the course is mandatory
     * @type {Array<string>}
     * @memberof CourseMeta
     */
    'topicTags'?: Array<string>;
    /**
     * If the course is mandatory
     * @type {Array<string>}
     * @memberof CourseMeta
     */
    'platforms'?: Array<string>;
    /**
     * A list of user requirments for the course
     * @type {Array<string>}
     * @memberof CourseMeta
     */
    'requirements'?: Array<string>;
    /**
     * The number of users which can be enrolled into a course
     * @type {number}
     * @memberof CourseMeta
     */
    'seats'?: number;
    /**
     * The difficulty level of the course
     * @type {string}
     * @memberof CourseMeta
     */
    'courseLevel'?: CourseMetaCourseLevelEnum;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof CourseMeta
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof CourseMeta
     */
    'dateEdited'?: string;
}

export const CourseMetaCourseTypeEnum = {
    Cmi5: 'cmi5',
    Moodle: 'moodle'
} as const;

export type CourseMetaCourseTypeEnum = typeof CourseMetaCourseTypeEnum[keyof typeof CourseMetaCourseTypeEnum];
export const CourseMetaCourseLevelEnum = {
    Beginner: 'beginner',
    Intermediate: 'intermediate',
    Advanced: 'advanced'
} as const;

export type CourseMetaCourseLevelEnum = typeof CourseMetaCourseLevelEnum[keyof typeof CourseMetaCourseLevelEnum];

/**
 * 
 * @export
 * @interface CourseMetaCreate
 */
export interface CourseMetaCreate {
    /**
     * The type of course (Moodle or CMI5)
     * @type {string}
     * @memberof CourseMetaCreate
     */
    'courseType'?: CourseMetaCreateCourseTypeEnum;
    /**
     * The native course id from Moodle or CMI5
     * @type {string}
     * @memberof CourseMetaCreate
     */
    'providerCourseId'?: string;
    /**
     * The amount of time the course will take
     * @type {number}
     * @memberof CourseMetaCreate
     */
    'duration'?: number;
    /**
     * The original content author from rapid cmi5
     * @type {string}
     * @memberof CourseMetaCreate
     */
    'rapidCmi5CourseAuthor'?: string;
    /**
     * If a user can self enroll in the course
     * @type {boolean}
     * @memberof CourseMetaCreate
     */
    'selfEnrollable'?: boolean;
    /**
     * If the course is mandatory
     * @type {Array<string>}
     * @memberof CourseMetaCreate
     */
    'workRoles'?: Array<string>;
    /**
     * If the course is mandatory
     * @type {Array<string>}
     * @memberof CourseMetaCreate
     */
    'topicTags'?: Array<string>;
    /**
     * If the course is mandatory
     * @type {Array<string>}
     * @memberof CourseMetaCreate
     */
    'platforms'?: Array<string>;
    /**
     * A list of user requirments for the course
     * @type {Array<string>}
     * @memberof CourseMetaCreate
     */
    'requirements'?: Array<string>;
    /**
     * The number of users which can be enrolled into a course
     * @type {number}
     * @memberof CourseMetaCreate
     */
    'seats'?: number;
    /**
     * The difficulty level of the course
     * @type {string}
     * @memberof CourseMetaCreate
     */
    'courseLevel'?: CourseMetaCreateCourseLevelEnum;
}

export const CourseMetaCreateCourseTypeEnum = {
    Cmi5: 'cmi5',
    Moodle: 'moodle'
} as const;

export type CourseMetaCreateCourseTypeEnum = typeof CourseMetaCreateCourseTypeEnum[keyof typeof CourseMetaCreateCourseTypeEnum];
export const CourseMetaCreateCourseLevelEnum = {
    Beginner: 'beginner',
    Intermediate: 'intermediate',
    Advanced: 'advanced'
} as const;

export type CourseMetaCreateCourseLevelEnum = typeof CourseMetaCreateCourseLevelEnum[keyof typeof CourseMetaCreateCourseLevelEnum];

/**
 * 
 * @export
 * @interface CourseMetaUpdate
 */
export interface CourseMetaUpdate {
    /**
     * 
     * @type {string}
     * @memberof CourseMetaUpdate
     */
    'id'?: string;
    /**
     * The type of course (Moodle or CMI5)
     * @type {string}
     * @memberof CourseMetaUpdate
     */
    'courseType'?: CourseMetaUpdateCourseTypeEnum;
    /**
     * The native course id from Moodle or CMI5
     * @type {string}
     * @memberof CourseMetaUpdate
     */
    'providerCourseId'?: string;
    /**
     * The amount of time the course will take
     * @type {number}
     * @memberof CourseMetaUpdate
     */
    'duration'?: number;
    /**
     * The original content author from rapid cmi5
     * @type {string}
     * @memberof CourseMetaUpdate
     */
    'rapidCmi5CourseAuthor'?: string;
    /**
     * If a user can self enroll in the course
     * @type {boolean}
     * @memberof CourseMetaUpdate
     */
    'selfEnrollable'?: boolean;
    /**
     * If the course is mandatory
     * @type {Array<string>}
     * @memberof CourseMetaUpdate
     */
    'workRoles'?: Array<string>;
    /**
     * If the course is mandatory
     * @type {Array<string>}
     * @memberof CourseMetaUpdate
     */
    'topicTags'?: Array<string>;
    /**
     * If the course is mandatory
     * @type {Array<string>}
     * @memberof CourseMetaUpdate
     */
    'platforms'?: Array<string>;
    /**
     * A list of user requirments for the course
     * @type {Array<string>}
     * @memberof CourseMetaUpdate
     */
    'requirements'?: Array<string>;
    /**
     * The number of users which can be enrolled into a course
     * @type {number}
     * @memberof CourseMetaUpdate
     */
    'seats'?: number;
    /**
     * The difficulty level of the course
     * @type {string}
     * @memberof CourseMetaUpdate
     */
    'courseLevel'?: CourseMetaUpdateCourseLevelEnum;
}

export const CourseMetaUpdateCourseTypeEnum = {
    Cmi5: 'cmi5',
    Moodle: 'moodle'
} as const;

export type CourseMetaUpdateCourseTypeEnum = typeof CourseMetaUpdateCourseTypeEnum[keyof typeof CourseMetaUpdateCourseTypeEnum];
export const CourseMetaUpdateCourseLevelEnum = {
    Beginner: 'beginner',
    Intermediate: 'intermediate',
    Advanced: 'advanced'
} as const;

export type CourseMetaUpdateCourseLevelEnum = typeof CourseMetaUpdateCourseLevelEnum[keyof typeof CourseMetaUpdateCourseLevelEnum];

/**
 * 
 * @export
 * @interface CreateCmi5CourseAIResponse
 */
export interface CreateCmi5CourseAIResponse {
    /**
     * AI response
     * @type {string}
     * @memberof CreateCmi5CourseAIResponse
     */
    'response': string;
    /**
     * 
     * @type {CourseDataModel}
     * @memberof CreateCmi5CourseAIResponse
     */
    'courseData': CourseDataModel;
}
/**
 * 
 * @export
 * @interface Element
 */
export interface Element {
    [key: string]: any;

    /**
     * the short name of the related document
     * @type {string}
     * @memberof Element
     */
    'doc_identifier'?: string;
    /**
     * The type of element as given by the related document.
     * @type {string}
     * @memberof Element
     */
    'element_type'?: ElementElementTypeEnum;
    /**
     * the name of the element. This property might be the identifier that is given to the element by the given document like \'ID.AM-1\' or \'S0009\'. Default value is the string \'N/A\'.
     * @type {string}
     * @memberof Element
     */
    'element_identifier'?: string;
    /**
     * The title of the element. Some elements may not have titles e.g. ID.AM-1 or S0009. Default value is the string \'N/A\'.
     * @type {string}
     * @memberof Element
     */
    'title'?: string;
    /**
     * This field represents the text within an element.
     * @type {string}
     * @memberof Element
     */
    'text'?: string;
}

export const ElementElementTypeEnum = {
    Category: 'category',
    CompetencyArea: 'competency_area',
    Knowledge: 'knowledge',
    OpmCode: 'opm_code',
    Skill: 'skill',
    Sort: 'sort',
    Task: 'task',
    WorkRole: 'work_role'
} as const;

export type ElementElementTypeEnum = typeof ElementElementTypeEnum[keyof typeof ElementElementTypeEnum];

/**
 * 
 * @export
 * @interface EnrolledCourse
 */
export interface EnrolledCourse {
    /**
     * 
     * @type {string}
     * @memberof EnrolledCourse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnrolledCourse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnrolledCourse
     */
    'author'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnrolledCourse
     */
    'dateCreated'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnrolledCourse
     */
    'dateEdited'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnrolledCourse
     */
    'courseType'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnrolledCourse
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnrolledCourse
     */
    'courseImage'?: string;
    /**
     * 
     * @type {CourseMeta}
     * @memberof EnrolledCourse
     */
    'metaData'?: CourseMeta;
    /**
     * 
     * @type {number}
     * @memberof EnrolledCourse
     */
    'enrolledUsers'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof EnrolledCourse
     */
    'deployedClasses'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof EnrolledCourse
     */
    'progress'?: number;
    /**
     * 
     * @type {string}
     * @memberof EnrolledCourse
     */
    'startDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof EnrolledCourse
     */
    'endDate'?: string;
}
/**
 * 
 * @export
 * @interface Grade
 */
export interface Grade {
    /**
     * 
     * @type {string}
     * @memberof Grade
     */
    'progress'?: string;
    /**
     * 
     * @type {string}
     * @memberof Grade
     */
    'auStatus'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Grade
     */
    'activites'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Grade
     */
    'statements'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Grade
     */
    'auId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Grade
     */
    'auName'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Grade
     */
    'ksats'?: Array<string>;
}
/**
 * 
 * @export
 * @interface InstructorAIResponse
 */
export interface InstructorAIResponse {
    /**
     * AI response
     * @type {string}
     * @memberof InstructorAIResponse
     */
    'response': string;
}
/**
 * 
 * @export
 * @interface KsaTsList200Response
 */
export interface KsaTsList200Response {
    /**
     * 
     * @type {number}
     * @memberof KsaTsList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof KsaTsList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof KsaTsList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof KsaTsList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<Element>}
     * @memberof KsaTsList200Response
     */
    'data'?: Array<Element>;
}
/**
 * 
 * @export
 * @interface LrsStatementsList200Response
 */
export interface LrsStatementsList200Response {
    /**
     * 
     * @type {number}
     * @memberof LrsStatementsList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof LrsStatementsList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof LrsStatementsList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof LrsStatementsList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<Cmi5AUMapping>}
     * @memberof LrsStatementsList200Response
     */
    'data'?: Array<Cmi5AUMapping>;
}
/**
 * 
 * @export
 * @interface SlideQuiz
 */
export interface SlideQuiz {
    /**
     * 
     * @type {Array<SlideQuizQuestion>}
     * @memberof SlideQuiz
     */
    'questions': Array<SlideQuizQuestion>;
}
/**
 * 
 * @export
 * @interface SlideQuizQuestion
 */
export interface SlideQuizQuestion {
    /**
     * 
     * @type {string}
     * @memberof SlideQuizQuestion
     */
    'question': string;
    /**
     * 
     * @type {string}
     * @memberof SlideQuizQuestion
     */
    'answer': string;
}
/**
 * 
 * @export
 * @interface StudentAIResponse
 */
export interface StudentAIResponse {
    /**
     * AI response
     * @type {string}
     * @memberof StudentAIResponse
     */
    'response': string;
}

/**
 * AIApi - axios parameter creator
 * @export
 */
export const AIApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Request a new course to be created inside of Rapid CMI5
         * @param {AiGenerateCourseDataRequest} [aiGenerateCourseDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiGenerateCourseData: async (aiGenerateCourseDataRequest?: AiGenerateCourseDataRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/ai/rapid-cmi5/course`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aiGenerateCourseDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Query the Instructor AI
         * @param {AiQueryInstructorsRequest} [aiQueryInstructorsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiQueryInstructors: async (aiQueryInstructorsRequest?: AiQueryInstructorsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/ai/instructors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aiQueryInstructorsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Query the Student AI
         * @param {AiQueryInstructorsRequest} [aiQueryInstructorsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiQueryStudents: async (aiQueryInstructorsRequest?: AiQueryInstructorsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/ai/students`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aiQueryInstructorsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AIApi - functional programming interface
 * @export
 */
export const AIApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AIApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Request a new course to be created inside of Rapid CMI5
         * @param {AiGenerateCourseDataRequest} [aiGenerateCourseDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiGenerateCourseData(aiGenerateCourseDataRequest?: AiGenerateCourseDataRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCmi5CourseAIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiGenerateCourseData(aiGenerateCourseDataRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIApi.aiGenerateCourseData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Query the Instructor AI
         * @param {AiQueryInstructorsRequest} [aiQueryInstructorsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiQueryInstructors(aiQueryInstructorsRequest?: AiQueryInstructorsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstructorAIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiQueryInstructors(aiQueryInstructorsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIApi.aiQueryInstructors']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Query the Student AI
         * @param {AiQueryInstructorsRequest} [aiQueryInstructorsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiQueryStudents(aiQueryInstructorsRequest?: AiQueryInstructorsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StudentAIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiQueryStudents(aiQueryInstructorsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AIApi.aiQueryStudents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AIApi - factory interface
 * @export
 */
export const AIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AIApiFp(configuration)
    return {
        /**
         * 
         * @summary Request a new course to be created inside of Rapid CMI5
         * @param {AiGenerateCourseDataRequest} [aiGenerateCourseDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiGenerateCourseData(aiGenerateCourseDataRequest?: AiGenerateCourseDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateCmi5CourseAIResponse> {
            return localVarFp.aiGenerateCourseData(aiGenerateCourseDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Query the Instructor AI
         * @param {AiQueryInstructorsRequest} [aiQueryInstructorsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiQueryInstructors(aiQueryInstructorsRequest?: AiQueryInstructorsRequest, options?: RawAxiosRequestConfig): AxiosPromise<InstructorAIResponse> {
            return localVarFp.aiQueryInstructors(aiQueryInstructorsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Query the Student AI
         * @param {AiQueryInstructorsRequest} [aiQueryInstructorsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiQueryStudents(aiQueryInstructorsRequest?: AiQueryInstructorsRequest, options?: RawAxiosRequestConfig): AxiosPromise<StudentAIResponse> {
            return localVarFp.aiQueryStudents(aiQueryInstructorsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AIApi - object-oriented interface
 * @export
 * @class AIApi
 * @extends {BaseAPI}
 */
export class AIApi extends BaseAPI {
    /**
     * 
     * @summary Request a new course to be created inside of Rapid CMI5
     * @param {AiGenerateCourseDataRequest} [aiGenerateCourseDataRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIApi
     */
    public aiGenerateCourseData(aiGenerateCourseDataRequest?: AiGenerateCourseDataRequest, options?: RawAxiosRequestConfig) {
        return AIApiFp(this.configuration).aiGenerateCourseData(aiGenerateCourseDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Query the Instructor AI
     * @param {AiQueryInstructorsRequest} [aiQueryInstructorsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIApi
     */
    public aiQueryInstructors(aiQueryInstructorsRequest?: AiQueryInstructorsRequest, options?: RawAxiosRequestConfig) {
        return AIApiFp(this.configuration).aiQueryInstructors(aiQueryInstructorsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Query the Student AI
     * @param {AiQueryInstructorsRequest} [aiQueryInstructorsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AIApi
     */
    public aiQueryStudents(aiQueryInstructorsRequest?: AiQueryInstructorsRequest, options?: RawAxiosRequestConfig) {
        return AIApiFp(this.configuration).aiQueryStudents(aiQueryInstructorsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Cmi5EnrollmentApi - axios parameter creator
 * @export
 */
export const Cmi5EnrollmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Enroll in a cmi5 course
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmi5Enroll: async (courseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('cmi5Enroll', 'courseId', courseId)
            const localVarPath = `/v1/cmi5/enrollment/course/{courseId}/enroll`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all users enrolled in a course
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmi5GetAllEnrollments: async (courseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('cmi5GetAllEnrollments', 'courseId', courseId)
            const localVarPath = `/v1/cmi5/enrollment/course/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all completed cmi5 courses the user is enrolled in
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmi5GetCompletedUserEnrollments: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/cmi5/enrollment/user/completed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all cmi5 courses the user is enrolled in
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmi5GetUserEnrollments: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/cmi5/enrollment/user/current`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unenroll in a cmi5 course
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmi5Unenroll: async (courseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('cmi5Unenroll', 'courseId', courseId)
            const localVarPath = `/v1/cmi5/enrollment/course/{courseId}/unenroll`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Cmi5EnrollmentApi - functional programming interface
 * @export
 */
export const Cmi5EnrollmentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Cmi5EnrollmentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Enroll in a cmi5 course
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmi5Enroll(courseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmi5Enroll(courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Cmi5EnrollmentApi.cmi5Enroll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all users enrolled in a course
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmi5GetAllEnrollments(courseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmi5GetAllEnrollments(courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Cmi5EnrollmentApi.cmi5GetAllEnrollments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all completed cmi5 courses the user is enrolled in
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmi5GetCompletedUserEnrollments(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmi5GetCompletedUserEnrollments(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Cmi5EnrollmentApi.cmi5GetCompletedUserEnrollments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all cmi5 courses the user is enrolled in
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmi5GetUserEnrollments(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmi5GetUserEnrollments(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Cmi5EnrollmentApi.cmi5GetUserEnrollments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Unenroll in a cmi5 course
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmi5Unenroll(courseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmi5Unenroll(courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Cmi5EnrollmentApi.cmi5Unenroll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Cmi5EnrollmentApi - factory interface
 * @export
 */
export const Cmi5EnrollmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Cmi5EnrollmentApiFp(configuration)
    return {
        /**
         * 
         * @summary Enroll in a cmi5 course
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmi5Enroll(courseId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.cmi5Enroll(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all users enrolled in a course
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmi5GetAllEnrollments(courseId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.cmi5GetAllEnrollments(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all completed cmi5 courses the user is enrolled in
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmi5GetCompletedUserEnrollments(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.cmi5GetCompletedUserEnrollments(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all cmi5 courses the user is enrolled in
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmi5GetUserEnrollments(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.cmi5GetUserEnrollments(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unenroll in a cmi5 course
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmi5Unenroll(courseId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.cmi5Unenroll(courseId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Cmi5EnrollmentApi - object-oriented interface
 * @export
 * @class Cmi5EnrollmentApi
 * @extends {BaseAPI}
 */
export class Cmi5EnrollmentApi extends BaseAPI {
    /**
     * 
     * @summary Enroll in a cmi5 course
     * @param {string} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Cmi5EnrollmentApi
     */
    public cmi5Enroll(courseId: string, options?: RawAxiosRequestConfig) {
        return Cmi5EnrollmentApiFp(this.configuration).cmi5Enroll(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all users enrolled in a course
     * @param {string} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Cmi5EnrollmentApi
     */
    public cmi5GetAllEnrollments(courseId: string, options?: RawAxiosRequestConfig) {
        return Cmi5EnrollmentApiFp(this.configuration).cmi5GetAllEnrollments(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all completed cmi5 courses the user is enrolled in
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Cmi5EnrollmentApi
     */
    public cmi5GetCompletedUserEnrollments(options?: RawAxiosRequestConfig) {
        return Cmi5EnrollmentApiFp(this.configuration).cmi5GetCompletedUserEnrollments(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all cmi5 courses the user is enrolled in
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Cmi5EnrollmentApi
     */
    public cmi5GetUserEnrollments(options?: RawAxiosRequestConfig) {
        return Cmi5EnrollmentApiFp(this.configuration).cmi5GetUserEnrollments(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unenroll in a cmi5 course
     * @param {string} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Cmi5EnrollmentApi
     */
    public cmi5Unenroll(courseId: string, options?: RawAxiosRequestConfig) {
        return Cmi5EnrollmentApiFp(this.configuration).cmi5Unenroll(courseId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Cmi5ManagementApi - axios parameter creator
 * @export
 */
export const Cmi5ManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a cmi5 zip package and return the metadata
         * @param {File} file 
         * @param {boolean} createAuMappings Whether or not to create / update au mappings for a course
         * @param {number} [duration] The amount of time the course will take
         * @param {boolean} [selfEnrollable] If a user can self enroll in the course
         * @param {number} [seats] The number of users which can be enrolled into this course
         * @param {Array<string>} [workRoles] The list of work roles this task works towards
         * @param {Array<string>} [topicTags] General topic tags that are related to the course
         * @param {Array<string>} [platforms] The platforms which this course utilizes
         * @param {Array<string>} [requirements] A list of user requirments for the course
         * @param {Cmi5BuildCourseLevelEnum} [courseLevel] The difficulty level of the course
         * @param {string} [projectName] Optional project name for the cmi5 course upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmi5Build: async (file: File, createAuMappings: boolean, duration?: number, selfEnrollable?: boolean, seats?: number, workRoles?: Array<string>, topicTags?: Array<string>, platforms?: Array<string>, requirements?: Array<string>, courseLevel?: Cmi5BuildCourseLevelEnum, projectName?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('cmi5Build', 'file', file)
            // verify required parameter 'createAuMappings' is not null or undefined
            assertParamExists('cmi5Build', 'createAuMappings', createAuMappings)
            const localVarPath = `/v1/cmi5/management/course/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            if (duration !== undefined) { 
                localVarFormParams.append('duration', duration as any);
            }
    
            if (selfEnrollable !== undefined) { 
                localVarFormParams.append('selfEnrollable', String(selfEnrollable) as any);
            }
    
            if (seats !== undefined) { 
                localVarFormParams.append('seats', seats as any);
            }
                if (workRoles) {
                localVarFormParams.append('workRoles', workRoles.join(COLLECTION_FORMATS.csv));
            }

                if (topicTags) {
                localVarFormParams.append('topicTags', topicTags.join(COLLECTION_FORMATS.csv));
            }

                if (platforms) {
                localVarFormParams.append('platforms', platforms.join(COLLECTION_FORMATS.csv));
            }

                if (requirements) {
                localVarFormParams.append('requirements', requirements.join(COLLECTION_FORMATS.csv));
            }

    
            if (courseLevel !== undefined) { 
                localVarFormParams.append('courseLevel', courseLevel as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (createAuMappings !== undefined) { 
                localVarFormParams.append('createAuMappings', String(createAuMappings) as any);
            }
    
            if (projectName !== undefined) { 
                localVarFormParams.append('projectName', projectName as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the launch url for a specific au in a cmi5 course
         * @param {string} courseId 
         * @param {string} auIndex 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmi5CreateLaunchUrl: async (courseId: string, auIndex: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('cmi5CreateLaunchUrl', 'courseId', courseId)
            // verify required parameter 'auIndex' is not null or undefined
            assertParamExists('cmi5CreateLaunchUrl', 'auIndex', auIndex)
            const localVarPath = `/v1/cmi5/management/launch-url/{courseId}/au/{auIndex}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"auIndex"}}`, encodeURIComponent(String(auIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a cmi5 course
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmi5Delete: async (courseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('cmi5Delete', 'courseId', courseId)
            const localVarPath = `/v1/cmi5/management/course/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the available cmi5 courses
         * @param {string} [author] 
         * @param {string} [dateCreated] 
         * @param {string} [dateEdited] 
         * @param {Cmi5ListCourseTypeEnum} [courseType] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {Cmi5ListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {Cmi5ListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmi5List: async (author?: string, dateCreated?: string, dateEdited?: string, courseType?: Cmi5ListCourseTypeEnum, offset?: number, limit?: number, search?: string, sortBy?: Cmi5ListSortByEnum, sort?: Cmi5ListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/cmi5/management/course`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (dateCreated !== undefined) {
                localVarQueryParameter['dateCreated'] = dateCreated;
            }

            if (dateEdited !== undefined) {
                localVarQueryParameter['dateEdited'] = dateEdited;
            }

            if (courseType !== undefined) {
                localVarQueryParameter['courseType'] = courseType;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a cmi5 course
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmi5Retrieve: async (courseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('cmi5Retrieve', 'courseId', courseId)
            const localVarPath = `/v1/cmi5/management/course/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Cmi5ManagementApi - functional programming interface
 * @export
 */
export const Cmi5ManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Cmi5ManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a cmi5 zip package and return the metadata
         * @param {File} file 
         * @param {boolean} createAuMappings Whether or not to create / update au mappings for a course
         * @param {number} [duration] The amount of time the course will take
         * @param {boolean} [selfEnrollable] If a user can self enroll in the course
         * @param {number} [seats] The number of users which can be enrolled into this course
         * @param {Array<string>} [workRoles] The list of work roles this task works towards
         * @param {Array<string>} [topicTags] General topic tags that are related to the course
         * @param {Array<string>} [platforms] The platforms which this course utilizes
         * @param {Array<string>} [requirements] A list of user requirments for the course
         * @param {Cmi5BuildCourseLevelEnum} [courseLevel] The difficulty level of the course
         * @param {string} [projectName] Optional project name for the cmi5 course upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmi5Build(file: File, createAuMappings: boolean, duration?: number, selfEnrollable?: boolean, seats?: number, workRoles?: Array<string>, topicTags?: Array<string>, platforms?: Array<string>, requirements?: Array<string>, courseLevel?: Cmi5BuildCourseLevelEnum, projectName?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmi5Build(file, createAuMappings, duration, selfEnrollable, seats, workRoles, topicTags, platforms, requirements, courseLevel, projectName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Cmi5ManagementApi.cmi5Build']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the launch url for a specific au in a cmi5 course
         * @param {string} courseId 
         * @param {string} auIndex 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmi5CreateLaunchUrl(courseId: string, auIndex: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmi5CreateLaunchUrl(courseId, auIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Cmi5ManagementApi.cmi5CreateLaunchUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a cmi5 course
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmi5Delete(courseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cmi5Course>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmi5Delete(courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Cmi5ManagementApi.cmi5Delete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List the available cmi5 courses
         * @param {string} [author] 
         * @param {string} [dateCreated] 
         * @param {string} [dateEdited] 
         * @param {Cmi5ListCourseTypeEnum} [courseType] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {Cmi5ListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {Cmi5ListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmi5List(author?: string, dateCreated?: string, dateEdited?: string, courseType?: Cmi5ListCourseTypeEnum, offset?: number, limit?: number, search?: string, sortBy?: Cmi5ListSortByEnum, sort?: Cmi5ListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cmi5List200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmi5List(author, dateCreated, dateEdited, courseType, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Cmi5ManagementApi.cmi5List']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a cmi5 course
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmi5Retrieve(courseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cmi5Course>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmi5Retrieve(courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Cmi5ManagementApi.cmi5Retrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Cmi5ManagementApi - factory interface
 * @export
 */
export const Cmi5ManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Cmi5ManagementApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a cmi5 zip package and return the metadata
         * @param {File} file 
         * @param {boolean} createAuMappings Whether or not to create / update au mappings for a course
         * @param {number} [duration] The amount of time the course will take
         * @param {boolean} [selfEnrollable] If a user can self enroll in the course
         * @param {number} [seats] The number of users which can be enrolled into this course
         * @param {Array<string>} [workRoles] The list of work roles this task works towards
         * @param {Array<string>} [topicTags] General topic tags that are related to the course
         * @param {Array<string>} [platforms] The platforms which this course utilizes
         * @param {Array<string>} [requirements] A list of user requirments for the course
         * @param {Cmi5BuildCourseLevelEnum} [courseLevel] The difficulty level of the course
         * @param {string} [projectName] Optional project name for the cmi5 course upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmi5Build(file: File, createAuMappings: boolean, duration?: number, selfEnrollable?: boolean, seats?: number, workRoles?: Array<string>, topicTags?: Array<string>, platforms?: Array<string>, requirements?: Array<string>, courseLevel?: Cmi5BuildCourseLevelEnum, projectName?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cmi5Build(file, createAuMappings, duration, selfEnrollable, seats, workRoles, topicTags, platforms, requirements, courseLevel, projectName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the launch url for a specific au in a cmi5 course
         * @param {string} courseId 
         * @param {string} auIndex 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmi5CreateLaunchUrl(courseId: string, auIndex: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cmi5CreateLaunchUrl(courseId, auIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a cmi5 course
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmi5Delete(courseId: string, options?: RawAxiosRequestConfig): AxiosPromise<Cmi5Course> {
            return localVarFp.cmi5Delete(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the available cmi5 courses
         * @param {string} [author] 
         * @param {string} [dateCreated] 
         * @param {string} [dateEdited] 
         * @param {Cmi5ListCourseTypeEnum} [courseType] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {Cmi5ListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {Cmi5ListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmi5List(author?: string, dateCreated?: string, dateEdited?: string, courseType?: Cmi5ListCourseTypeEnum, offset?: number, limit?: number, search?: string, sortBy?: Cmi5ListSortByEnum, sort?: Cmi5ListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<Cmi5List200Response> {
            return localVarFp.cmi5List(author, dateCreated, dateEdited, courseType, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a cmi5 course
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmi5Retrieve(courseId: string, options?: RawAxiosRequestConfig): AxiosPromise<Cmi5Course> {
            return localVarFp.cmi5Retrieve(courseId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Cmi5ManagementApi - object-oriented interface
 * @export
 * @class Cmi5ManagementApi
 * @extends {BaseAPI}
 */
export class Cmi5ManagementApi extends BaseAPI {
    /**
     * 
     * @summary Create a cmi5 zip package and return the metadata
     * @param {File} file 
     * @param {boolean} createAuMappings Whether or not to create / update au mappings for a course
     * @param {number} [duration] The amount of time the course will take
     * @param {boolean} [selfEnrollable] If a user can self enroll in the course
     * @param {number} [seats] The number of users which can be enrolled into this course
     * @param {Array<string>} [workRoles] The list of work roles this task works towards
     * @param {Array<string>} [topicTags] General topic tags that are related to the course
     * @param {Array<string>} [platforms] The platforms which this course utilizes
     * @param {Array<string>} [requirements] A list of user requirments for the course
     * @param {Cmi5BuildCourseLevelEnum} [courseLevel] The difficulty level of the course
     * @param {string} [projectName] Optional project name for the cmi5 course upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Cmi5ManagementApi
     */
    public cmi5Build(file: File, createAuMappings: boolean, duration?: number, selfEnrollable?: boolean, seats?: number, workRoles?: Array<string>, topicTags?: Array<string>, platforms?: Array<string>, requirements?: Array<string>, courseLevel?: Cmi5BuildCourseLevelEnum, projectName?: string, options?: RawAxiosRequestConfig) {
        return Cmi5ManagementApiFp(this.configuration).cmi5Build(file, createAuMappings, duration, selfEnrollable, seats, workRoles, topicTags, platforms, requirements, courseLevel, projectName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the launch url for a specific au in a cmi5 course
     * @param {string} courseId 
     * @param {string} auIndex 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Cmi5ManagementApi
     */
    public cmi5CreateLaunchUrl(courseId: string, auIndex: string, options?: RawAxiosRequestConfig) {
        return Cmi5ManagementApiFp(this.configuration).cmi5CreateLaunchUrl(courseId, auIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a cmi5 course
     * @param {string} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Cmi5ManagementApi
     */
    public cmi5Delete(courseId: string, options?: RawAxiosRequestConfig) {
        return Cmi5ManagementApiFp(this.configuration).cmi5Delete(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the available cmi5 courses
     * @param {string} [author] 
     * @param {string} [dateCreated] 
     * @param {string} [dateEdited] 
     * @param {Cmi5ListCourseTypeEnum} [courseType] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {Cmi5ListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {Cmi5ListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Cmi5ManagementApi
     */
    public cmi5List(author?: string, dateCreated?: string, dateEdited?: string, courseType?: Cmi5ListCourseTypeEnum, offset?: number, limit?: number, search?: string, sortBy?: Cmi5ListSortByEnum, sort?: Cmi5ListSortEnum, options?: RawAxiosRequestConfig) {
        return Cmi5ManagementApiFp(this.configuration).cmi5List(author, dateCreated, dateEdited, courseType, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a cmi5 course
     * @param {string} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Cmi5ManagementApi
     */
    public cmi5Retrieve(courseId: string, options?: RawAxiosRequestConfig) {
        return Cmi5ManagementApiFp(this.configuration).cmi5Retrieve(courseId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const Cmi5BuildCourseLevelEnum = {
    Beginner: 'beginner',
    Intermediate: 'intermediate',
    Advanced: 'advanced'
} as const;
export type Cmi5BuildCourseLevelEnum = typeof Cmi5BuildCourseLevelEnum[keyof typeof Cmi5BuildCourseLevelEnum];
/**
 * @export
 */
export const Cmi5ListCourseTypeEnum = {
    Cmi5: 'cmi5',
    Moodle: 'moodle'
} as const;
export type Cmi5ListCourseTypeEnum = typeof Cmi5ListCourseTypeEnum[keyof typeof Cmi5ListCourseTypeEnum];
/**
 * @export
 */
export const Cmi5ListSortByEnum = {
    Author: 'author',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    CourseName: 'courseName'
} as const;
export type Cmi5ListSortByEnum = typeof Cmi5ListSortByEnum[keyof typeof Cmi5ListSortByEnum];
/**
 * @export
 */
export const Cmi5ListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type Cmi5ListSortEnum = typeof Cmi5ListSortEnum[keyof typeof Cmi5ListSortEnum];


/**
 * CourseEnrollmentApi - axios parameter creator
 * @export
 */
export const CourseEnrollmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Enroll the user making the request into a course
         * @param {CourseEnrollmentRequest} [courseEnrollmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseEnroll: async (courseEnrollmentRequest?: CourseEnrollmentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/course/enrollment/user/enroll`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(courseEnrollmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the completed enrollments for a user
         * @param {boolean} [getCachedGrades] Get the cached grades for the course to speed up the call
         * @param {string} [author] 
         * @param {string} [dateCreated] 
         * @param {string} [dateEdited] 
         * @param {CourseGetCompletedStudentEnrollmentsCourseTypeEnum} [courseType] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {CourseGetCompletedStudentEnrollmentsSortByEnum} [sortBy] Key used to sort the collection by
         * @param {CourseGetCompletedStudentEnrollmentsSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseGetCompletedStudentEnrollments: async (getCachedGrades?: boolean, author?: string, dateCreated?: string, dateEdited?: string, courseType?: CourseGetCompletedStudentEnrollmentsCourseTypeEnum, offset?: number, limit?: number, search?: string, sortBy?: CourseGetCompletedStudentEnrollmentsSortByEnum, sort?: CourseGetCompletedStudentEnrollmentsSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/course/enrollment/user/completed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (getCachedGrades !== undefined) {
                localVarQueryParameter['getCachedGrades'] = getCachedGrades;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (dateCreated !== undefined) {
                localVarQueryParameter['dateCreated'] = dateCreated;
            }

            if (dateEdited !== undefined) {
                localVarQueryParameter['dateEdited'] = dateEdited;
            }

            if (courseType !== undefined) {
                localVarQueryParameter['courseType'] = courseType;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the enrollments for a course
         * @param {string} courseId 
         * @param {CourseGetCourseEnrollmentsTypeEnum} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseGetCourseEnrollments: async (courseId: string, type: CourseGetCourseEnrollmentsTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('courseGetCourseEnrollments', 'courseId', courseId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('courseGetCourseEnrollments', 'type', type)
            const localVarPath = `/v1/course/enrollment/course/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the enrollments for a user
         * @param {boolean} [getCachedGrades] Get the cached grades for the course to speed up the call
         * @param {string} [author] 
         * @param {string} [dateCreated] 
         * @param {string} [dateEdited] 
         * @param {CourseGetStudentEnrollmentsCourseTypeEnum} [courseType] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {CourseGetStudentEnrollmentsSortByEnum} [sortBy] Key used to sort the collection by
         * @param {CourseGetStudentEnrollmentsSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseGetStudentEnrollments: async (getCachedGrades?: boolean, author?: string, dateCreated?: string, dateEdited?: string, courseType?: CourseGetStudentEnrollmentsCourseTypeEnum, offset?: number, limit?: number, search?: string, sortBy?: CourseGetStudentEnrollmentsSortByEnum, sort?: CourseGetStudentEnrollmentsSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/course/enrollment/user/current`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (getCachedGrades !== undefined) {
                localVarQueryParameter['getCachedGrades'] = getCachedGrades;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (dateCreated !== undefined) {
                localVarQueryParameter['dateCreated'] = dateCreated;
            }

            if (dateEdited !== undefined) {
                localVarQueryParameter['dateEdited'] = dateEdited;
            }

            if (courseType !== undefined) {
                localVarQueryParameter['courseType'] = courseType;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unenroll in a cmi5 course
         * @param {CourseEnrollmentRequest} [courseEnrollmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseUnenroll: async (courseEnrollmentRequest?: CourseEnrollmentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/course/enrollment/user/unenroll`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(courseEnrollmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CourseEnrollmentApi - functional programming interface
 * @export
 */
export const CourseEnrollmentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CourseEnrollmentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Enroll the user making the request into a course
         * @param {CourseEnrollmentRequest} [courseEnrollmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseEnroll(courseEnrollmentRequest?: CourseEnrollmentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseEnroll(courseEnrollmentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseEnrollmentApi.courseEnroll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the completed enrollments for a user
         * @param {boolean} [getCachedGrades] Get the cached grades for the course to speed up the call
         * @param {string} [author] 
         * @param {string} [dateCreated] 
         * @param {string} [dateEdited] 
         * @param {CourseGetCompletedStudentEnrollmentsCourseTypeEnum} [courseType] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {CourseGetCompletedStudentEnrollmentsSortByEnum} [sortBy] Key used to sort the collection by
         * @param {CourseGetCompletedStudentEnrollmentsSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseGetCompletedStudentEnrollments(getCachedGrades?: boolean, author?: string, dateCreated?: string, dateEdited?: string, courseType?: CourseGetCompletedStudentEnrollmentsCourseTypeEnum, offset?: number, limit?: number, search?: string, sortBy?: CourseGetCompletedStudentEnrollmentsSortByEnum, sort?: CourseGetCompletedStudentEnrollmentsSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseGetStudentEnrollments200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseGetCompletedStudentEnrollments(getCachedGrades, author, dateCreated, dateEdited, courseType, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseEnrollmentApi.courseGetCompletedStudentEnrollments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the enrollments for a course
         * @param {string} courseId 
         * @param {CourseGetCourseEnrollmentsTypeEnum} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseGetCourseEnrollments(courseId: string, type: CourseGetCourseEnrollmentsTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseGetCourseEnrollments(courseId, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseEnrollmentApi.courseGetCourseEnrollments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the enrollments for a user
         * @param {boolean} [getCachedGrades] Get the cached grades for the course to speed up the call
         * @param {string} [author] 
         * @param {string} [dateCreated] 
         * @param {string} [dateEdited] 
         * @param {CourseGetStudentEnrollmentsCourseTypeEnum} [courseType] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {CourseGetStudentEnrollmentsSortByEnum} [sortBy] Key used to sort the collection by
         * @param {CourseGetStudentEnrollmentsSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseGetStudentEnrollments(getCachedGrades?: boolean, author?: string, dateCreated?: string, dateEdited?: string, courseType?: CourseGetStudentEnrollmentsCourseTypeEnum, offset?: number, limit?: number, search?: string, sortBy?: CourseGetStudentEnrollmentsSortByEnum, sort?: CourseGetStudentEnrollmentsSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseGetStudentEnrollments200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseGetStudentEnrollments(getCachedGrades, author, dateCreated, dateEdited, courseType, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseEnrollmentApi.courseGetStudentEnrollments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Unenroll in a cmi5 course
         * @param {CourseEnrollmentRequest} [courseEnrollmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseUnenroll(courseEnrollmentRequest?: CourseEnrollmentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseUnenroll(courseEnrollmentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseEnrollmentApi.courseUnenroll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CourseEnrollmentApi - factory interface
 * @export
 */
export const CourseEnrollmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CourseEnrollmentApiFp(configuration)
    return {
        /**
         * 
         * @summary Enroll the user making the request into a course
         * @param {CourseEnrollmentRequest} [courseEnrollmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseEnroll(courseEnrollmentRequest?: CourseEnrollmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.courseEnroll(courseEnrollmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the completed enrollments for a user
         * @param {boolean} [getCachedGrades] Get the cached grades for the course to speed up the call
         * @param {string} [author] 
         * @param {string} [dateCreated] 
         * @param {string} [dateEdited] 
         * @param {CourseGetCompletedStudentEnrollmentsCourseTypeEnum} [courseType] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {CourseGetCompletedStudentEnrollmentsSortByEnum} [sortBy] Key used to sort the collection by
         * @param {CourseGetCompletedStudentEnrollmentsSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseGetCompletedStudentEnrollments(getCachedGrades?: boolean, author?: string, dateCreated?: string, dateEdited?: string, courseType?: CourseGetCompletedStudentEnrollmentsCourseTypeEnum, offset?: number, limit?: number, search?: string, sortBy?: CourseGetCompletedStudentEnrollmentsSortByEnum, sort?: CourseGetCompletedStudentEnrollmentsSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<CourseGetStudentEnrollments200Response> {
            return localVarFp.courseGetCompletedStudentEnrollments(getCachedGrades, author, dateCreated, dateEdited, courseType, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the enrollments for a course
         * @param {string} courseId 
         * @param {CourseGetCourseEnrollmentsTypeEnum} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseGetCourseEnrollments(courseId: string, type: CourseGetCourseEnrollmentsTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.courseGetCourseEnrollments(courseId, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the enrollments for a user
         * @param {boolean} [getCachedGrades] Get the cached grades for the course to speed up the call
         * @param {string} [author] 
         * @param {string} [dateCreated] 
         * @param {string} [dateEdited] 
         * @param {CourseGetStudentEnrollmentsCourseTypeEnum} [courseType] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {CourseGetStudentEnrollmentsSortByEnum} [sortBy] Key used to sort the collection by
         * @param {CourseGetStudentEnrollmentsSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseGetStudentEnrollments(getCachedGrades?: boolean, author?: string, dateCreated?: string, dateEdited?: string, courseType?: CourseGetStudentEnrollmentsCourseTypeEnum, offset?: number, limit?: number, search?: string, sortBy?: CourseGetStudentEnrollmentsSortByEnum, sort?: CourseGetStudentEnrollmentsSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<CourseGetStudentEnrollments200Response> {
            return localVarFp.courseGetStudentEnrollments(getCachedGrades, author, dateCreated, dateEdited, courseType, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unenroll in a cmi5 course
         * @param {CourseEnrollmentRequest} [courseEnrollmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseUnenroll(courseEnrollmentRequest?: CourseEnrollmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.courseUnenroll(courseEnrollmentRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CourseEnrollmentApi - object-oriented interface
 * @export
 * @class CourseEnrollmentApi
 * @extends {BaseAPI}
 */
export class CourseEnrollmentApi extends BaseAPI {
    /**
     * 
     * @summary Enroll the user making the request into a course
     * @param {CourseEnrollmentRequest} [courseEnrollmentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseEnrollmentApi
     */
    public courseEnroll(courseEnrollmentRequest?: CourseEnrollmentRequest, options?: RawAxiosRequestConfig) {
        return CourseEnrollmentApiFp(this.configuration).courseEnroll(courseEnrollmentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the completed enrollments for a user
     * @param {boolean} [getCachedGrades] Get the cached grades for the course to speed up the call
     * @param {string} [author] 
     * @param {string} [dateCreated] 
     * @param {string} [dateEdited] 
     * @param {CourseGetCompletedStudentEnrollmentsCourseTypeEnum} [courseType] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {CourseGetCompletedStudentEnrollmentsSortByEnum} [sortBy] Key used to sort the collection by
     * @param {CourseGetCompletedStudentEnrollmentsSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseEnrollmentApi
     */
    public courseGetCompletedStudentEnrollments(getCachedGrades?: boolean, author?: string, dateCreated?: string, dateEdited?: string, courseType?: CourseGetCompletedStudentEnrollmentsCourseTypeEnum, offset?: number, limit?: number, search?: string, sortBy?: CourseGetCompletedStudentEnrollmentsSortByEnum, sort?: CourseGetCompletedStudentEnrollmentsSortEnum, options?: RawAxiosRequestConfig) {
        return CourseEnrollmentApiFp(this.configuration).courseGetCompletedStudentEnrollments(getCachedGrades, author, dateCreated, dateEdited, courseType, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the enrollments for a course
     * @param {string} courseId 
     * @param {CourseGetCourseEnrollmentsTypeEnum} type 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseEnrollmentApi
     */
    public courseGetCourseEnrollments(courseId: string, type: CourseGetCourseEnrollmentsTypeEnum, options?: RawAxiosRequestConfig) {
        return CourseEnrollmentApiFp(this.configuration).courseGetCourseEnrollments(courseId, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the enrollments for a user
     * @param {boolean} [getCachedGrades] Get the cached grades for the course to speed up the call
     * @param {string} [author] 
     * @param {string} [dateCreated] 
     * @param {string} [dateEdited] 
     * @param {CourseGetStudentEnrollmentsCourseTypeEnum} [courseType] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {CourseGetStudentEnrollmentsSortByEnum} [sortBy] Key used to sort the collection by
     * @param {CourseGetStudentEnrollmentsSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseEnrollmentApi
     */
    public courseGetStudentEnrollments(getCachedGrades?: boolean, author?: string, dateCreated?: string, dateEdited?: string, courseType?: CourseGetStudentEnrollmentsCourseTypeEnum, offset?: number, limit?: number, search?: string, sortBy?: CourseGetStudentEnrollmentsSortByEnum, sort?: CourseGetStudentEnrollmentsSortEnum, options?: RawAxiosRequestConfig) {
        return CourseEnrollmentApiFp(this.configuration).courseGetStudentEnrollments(getCachedGrades, author, dateCreated, dateEdited, courseType, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unenroll in a cmi5 course
     * @param {CourseEnrollmentRequest} [courseEnrollmentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseEnrollmentApi
     */
    public courseUnenroll(courseEnrollmentRequest?: CourseEnrollmentRequest, options?: RawAxiosRequestConfig) {
        return CourseEnrollmentApiFp(this.configuration).courseUnenroll(courseEnrollmentRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const CourseGetCompletedStudentEnrollmentsCourseTypeEnum = {
    Cmi5: 'cmi5',
    Moodle: 'moodle'
} as const;
export type CourseGetCompletedStudentEnrollmentsCourseTypeEnum = typeof CourseGetCompletedStudentEnrollmentsCourseTypeEnum[keyof typeof CourseGetCompletedStudentEnrollmentsCourseTypeEnum];
/**
 * @export
 */
export const CourseGetCompletedStudentEnrollmentsSortByEnum = {
    Author: 'author',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Name: 'name'
} as const;
export type CourseGetCompletedStudentEnrollmentsSortByEnum = typeof CourseGetCompletedStudentEnrollmentsSortByEnum[keyof typeof CourseGetCompletedStudentEnrollmentsSortByEnum];
/**
 * @export
 */
export const CourseGetCompletedStudentEnrollmentsSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type CourseGetCompletedStudentEnrollmentsSortEnum = typeof CourseGetCompletedStudentEnrollmentsSortEnum[keyof typeof CourseGetCompletedStudentEnrollmentsSortEnum];
/**
 * @export
 */
export const CourseGetCourseEnrollmentsTypeEnum = {
    Cmi5: 'cmi5',
    Moodle: 'moodle'
} as const;
export type CourseGetCourseEnrollmentsTypeEnum = typeof CourseGetCourseEnrollmentsTypeEnum[keyof typeof CourseGetCourseEnrollmentsTypeEnum];
/**
 * @export
 */
export const CourseGetStudentEnrollmentsCourseTypeEnum = {
    Cmi5: 'cmi5',
    Moodle: 'moodle'
} as const;
export type CourseGetStudentEnrollmentsCourseTypeEnum = typeof CourseGetStudentEnrollmentsCourseTypeEnum[keyof typeof CourseGetStudentEnrollmentsCourseTypeEnum];
/**
 * @export
 */
export const CourseGetStudentEnrollmentsSortByEnum = {
    Author: 'author',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Name: 'name'
} as const;
export type CourseGetStudentEnrollmentsSortByEnum = typeof CourseGetStudentEnrollmentsSortByEnum[keyof typeof CourseGetStudentEnrollmentsSortByEnum];
/**
 * @export
 */
export const CourseGetStudentEnrollmentsSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type CourseGetStudentEnrollmentsSortEnum = typeof CourseGetStudentEnrollmentsSortEnum[keyof typeof CourseGetStudentEnrollmentsSortEnum];


/**
 * CourseInstructorApi - axios parameter creator
 * @export
 */
export const CourseInstructorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Assign the instructor to manage a course
         * @param {CourseEnrollmentRequest} [courseEnrollmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseAssign: async (courseEnrollmentRequest?: CourseEnrollmentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/course/instructor/assign`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(courseEnrollmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Enroll users into a course
         * @param {CourseInstructorEnrollmentRequest} [courseInstructorEnrollmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseEnrollUsers: async (courseInstructorEnrollmentRequest?: CourseInstructorEnrollmentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/course/instructor/enroll-users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(courseInstructorEnrollmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the user emails enrolled into a course
         * @param {string} courseId 
         * @param {CourseGetCourseEnrollmentsByCourseIdTypeEnum} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseGetCourseEnrollmentsByCourseId: async (courseId: string, type: CourseGetCourseEnrollmentsByCourseIdTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('courseGetCourseEnrollmentsByCourseId', 'courseId', courseId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('courseGetCourseEnrollmentsByCourseId', 'type', type)
            const localVarPath = `/v1/course/instructor/{courseId}/users`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the enrollments for a course
         * @param {string} courseId 
         * @param {CourseGetUserGradesTypeEnum} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseGetUserGrades: async (courseId: string, type: CourseGetUserGradesTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('courseGetUserGrades', 'courseId', courseId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('courseGetUserGrades', 'type', type)
            const localVarPath = `/v1/course/instructor/{courseId}/users/grades`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Launch a class deployment for a cmi5 course, please note there is no moodle launch class
         * @param {string} courseId 
         * @param {ClassDeploymentRequest} [classDeploymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseLaunchClass: async (courseId: string, classDeploymentRequest?: ClassDeploymentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('courseLaunchClass', 'courseId', courseId)
            const localVarPath = `/v1/course/instructor/{courseId}/launch-class`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(classDeploymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the courses an instructor manages
         * @param {string} [author] 
         * @param {string} [dateCreated] 
         * @param {string} [dateEdited] 
         * @param {CourseList1CourseTypeEnum} [courseType] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {CourseList1SortByEnum} [sortBy] Key used to sort the collection by
         * @param {CourseList1SortEnum} [sort] 
         * @param {boolean} [deployableClassesOnly] Returns only courses which have class deployments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseList1: async (author?: string, dateCreated?: string, dateEdited?: string, courseType?: CourseList1CourseTypeEnum, offset?: number, limit?: number, search?: string, sortBy?: CourseList1SortByEnum, sort?: CourseList1SortEnum, deployableClassesOnly?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/course/instructor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (dateCreated !== undefined) {
                localVarQueryParameter['dateCreated'] = dateCreated;
            }

            if (dateEdited !== undefined) {
                localVarQueryParameter['dateEdited'] = dateEdited;
            }

            if (courseType !== undefined) {
                localVarQueryParameter['courseType'] = courseType;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (deployableClassesOnly !== undefined) {
                localVarQueryParameter['deployableClassesOnly'] = deployableClassesOnly;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unassign the instructor from managing a course
         * @param {CourseEnrollmentRequest} [courseEnrollmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseUnassign: async (courseEnrollmentRequest?: CourseEnrollmentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/course/instructor/unassign`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(courseEnrollmentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CourseInstructorApi - functional programming interface
 * @export
 */
export const CourseInstructorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CourseInstructorApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Assign the instructor to manage a course
         * @param {CourseEnrollmentRequest} [courseEnrollmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseAssign(courseEnrollmentRequest?: CourseEnrollmentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseAssign(courseEnrollmentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseInstructorApi.courseAssign']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Enroll users into a course
         * @param {CourseInstructorEnrollmentRequest} [courseInstructorEnrollmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseEnrollUsers(courseInstructorEnrollmentRequest?: CourseInstructorEnrollmentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseEnrollUsers(courseInstructorEnrollmentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseInstructorApi.courseEnrollUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the user emails enrolled into a course
         * @param {string} courseId 
         * @param {CourseGetCourseEnrollmentsByCourseIdTypeEnum} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseGetCourseEnrollmentsByCourseId(courseId: string, type: CourseGetCourseEnrollmentsByCourseIdTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseGetCourseEnrollmentsByCourseId(courseId, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseInstructorApi.courseGetCourseEnrollmentsByCourseId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the enrollments for a course
         * @param {string} courseId 
         * @param {CourseGetUserGradesTypeEnum} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseGetUserGrades(courseId: string, type: CourseGetUserGradesTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseGetUserGrades(courseId, type, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseInstructorApi.courseGetUserGrades']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Launch a class deployment for a cmi5 course, please note there is no moodle launch class
         * @param {string} courseId 
         * @param {ClassDeploymentRequest} [classDeploymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseLaunchClass(courseId: string, classDeploymentRequest?: ClassDeploymentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassDeployment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseLaunchClass(courseId, classDeploymentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseInstructorApi.courseLaunchClass']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List the courses an instructor manages
         * @param {string} [author] 
         * @param {string} [dateCreated] 
         * @param {string} [dateEdited] 
         * @param {CourseList1CourseTypeEnum} [courseType] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {CourseList1SortByEnum} [sortBy] Key used to sort the collection by
         * @param {CourseList1SortEnum} [sort] 
         * @param {boolean} [deployableClassesOnly] Returns only courses which have class deployments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseList1(author?: string, dateCreated?: string, dateEdited?: string, courseType?: CourseList1CourseTypeEnum, offset?: number, limit?: number, search?: string, sortBy?: CourseList1SortByEnum, sort?: CourseList1SortEnum, deployableClassesOnly?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseList1(author, dateCreated, dateEdited, courseType, offset, limit, search, sortBy, sort, deployableClassesOnly, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseInstructorApi.courseList1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Unassign the instructor from managing a course
         * @param {CourseEnrollmentRequest} [courseEnrollmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseUnassign(courseEnrollmentRequest?: CourseEnrollmentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseUnassign(courseEnrollmentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseInstructorApi.courseUnassign']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CourseInstructorApi - factory interface
 * @export
 */
export const CourseInstructorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CourseInstructorApiFp(configuration)
    return {
        /**
         * 
         * @summary Assign the instructor to manage a course
         * @param {CourseEnrollmentRequest} [courseEnrollmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseAssign(courseEnrollmentRequest?: CourseEnrollmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.courseAssign(courseEnrollmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Enroll users into a course
         * @param {CourseInstructorEnrollmentRequest} [courseInstructorEnrollmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseEnrollUsers(courseInstructorEnrollmentRequest?: CourseInstructorEnrollmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.courseEnrollUsers(courseInstructorEnrollmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the user emails enrolled into a course
         * @param {string} courseId 
         * @param {CourseGetCourseEnrollmentsByCourseIdTypeEnum} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseGetCourseEnrollmentsByCourseId(courseId: string, type: CourseGetCourseEnrollmentsByCourseIdTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.courseGetCourseEnrollmentsByCourseId(courseId, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the enrollments for a course
         * @param {string} courseId 
         * @param {CourseGetUserGradesTypeEnum} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseGetUserGrades(courseId: string, type: CourseGetUserGradesTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<object>> {
            return localVarFp.courseGetUserGrades(courseId, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Launch a class deployment for a cmi5 course, please note there is no moodle launch class
         * @param {string} courseId 
         * @param {ClassDeploymentRequest} [classDeploymentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseLaunchClass(courseId: string, classDeploymentRequest?: ClassDeploymentRequest, options?: RawAxiosRequestConfig): AxiosPromise<ClassDeployment> {
            return localVarFp.courseLaunchClass(courseId, classDeploymentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the courses an instructor manages
         * @param {string} [author] 
         * @param {string} [dateCreated] 
         * @param {string} [dateEdited] 
         * @param {CourseList1CourseTypeEnum} [courseType] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {CourseList1SortByEnum} [sortBy] Key used to sort the collection by
         * @param {CourseList1SortEnum} [sort] 
         * @param {boolean} [deployableClassesOnly] Returns only courses which have class deployments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseList1(author?: string, dateCreated?: string, dateEdited?: string, courseType?: CourseList1CourseTypeEnum, offset?: number, limit?: number, search?: string, sortBy?: CourseList1SortByEnum, sort?: CourseList1SortEnum, deployableClassesOnly?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<CourseList200Response> {
            return localVarFp.courseList1(author, dateCreated, dateEdited, courseType, offset, limit, search, sortBy, sort, deployableClassesOnly, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unassign the instructor from managing a course
         * @param {CourseEnrollmentRequest} [courseEnrollmentRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseUnassign(courseEnrollmentRequest?: CourseEnrollmentRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.courseUnassign(courseEnrollmentRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CourseInstructorApi - object-oriented interface
 * @export
 * @class CourseInstructorApi
 * @extends {BaseAPI}
 */
export class CourseInstructorApi extends BaseAPI {
    /**
     * 
     * @summary Assign the instructor to manage a course
     * @param {CourseEnrollmentRequest} [courseEnrollmentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseInstructorApi
     */
    public courseAssign(courseEnrollmentRequest?: CourseEnrollmentRequest, options?: RawAxiosRequestConfig) {
        return CourseInstructorApiFp(this.configuration).courseAssign(courseEnrollmentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Enroll users into a course
     * @param {CourseInstructorEnrollmentRequest} [courseInstructorEnrollmentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseInstructorApi
     */
    public courseEnrollUsers(courseInstructorEnrollmentRequest?: CourseInstructorEnrollmentRequest, options?: RawAxiosRequestConfig) {
        return CourseInstructorApiFp(this.configuration).courseEnrollUsers(courseInstructorEnrollmentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the user emails enrolled into a course
     * @param {string} courseId 
     * @param {CourseGetCourseEnrollmentsByCourseIdTypeEnum} type 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseInstructorApi
     */
    public courseGetCourseEnrollmentsByCourseId(courseId: string, type: CourseGetCourseEnrollmentsByCourseIdTypeEnum, options?: RawAxiosRequestConfig) {
        return CourseInstructorApiFp(this.configuration).courseGetCourseEnrollmentsByCourseId(courseId, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the enrollments for a course
     * @param {string} courseId 
     * @param {CourseGetUserGradesTypeEnum} type 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseInstructorApi
     */
    public courseGetUserGrades(courseId: string, type: CourseGetUserGradesTypeEnum, options?: RawAxiosRequestConfig) {
        return CourseInstructorApiFp(this.configuration).courseGetUserGrades(courseId, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Launch a class deployment for a cmi5 course, please note there is no moodle launch class
     * @param {string} courseId 
     * @param {ClassDeploymentRequest} [classDeploymentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseInstructorApi
     */
    public courseLaunchClass(courseId: string, classDeploymentRequest?: ClassDeploymentRequest, options?: RawAxiosRequestConfig) {
        return CourseInstructorApiFp(this.configuration).courseLaunchClass(courseId, classDeploymentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the courses an instructor manages
     * @param {string} [author] 
     * @param {string} [dateCreated] 
     * @param {string} [dateEdited] 
     * @param {CourseList1CourseTypeEnum} [courseType] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {CourseList1SortByEnum} [sortBy] Key used to sort the collection by
     * @param {CourseList1SortEnum} [sort] 
     * @param {boolean} [deployableClassesOnly] Returns only courses which have class deployments
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseInstructorApi
     */
    public courseList1(author?: string, dateCreated?: string, dateEdited?: string, courseType?: CourseList1CourseTypeEnum, offset?: number, limit?: number, search?: string, sortBy?: CourseList1SortByEnum, sort?: CourseList1SortEnum, deployableClassesOnly?: boolean, options?: RawAxiosRequestConfig) {
        return CourseInstructorApiFp(this.configuration).courseList1(author, dateCreated, dateEdited, courseType, offset, limit, search, sortBy, sort, deployableClassesOnly, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unassign the instructor from managing a course
     * @param {CourseEnrollmentRequest} [courseEnrollmentRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseInstructorApi
     */
    public courseUnassign(courseEnrollmentRequest?: CourseEnrollmentRequest, options?: RawAxiosRequestConfig) {
        return CourseInstructorApiFp(this.configuration).courseUnassign(courseEnrollmentRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const CourseGetCourseEnrollmentsByCourseIdTypeEnum = {
    Cmi5: 'cmi5',
    Moodle: 'moodle'
} as const;
export type CourseGetCourseEnrollmentsByCourseIdTypeEnum = typeof CourseGetCourseEnrollmentsByCourseIdTypeEnum[keyof typeof CourseGetCourseEnrollmentsByCourseIdTypeEnum];
/**
 * @export
 */
export const CourseGetUserGradesTypeEnum = {
    Cmi5: 'cmi5',
    Moodle: 'moodle'
} as const;
export type CourseGetUserGradesTypeEnum = typeof CourseGetUserGradesTypeEnum[keyof typeof CourseGetUserGradesTypeEnum];
/**
 * @export
 */
export const CourseList1CourseTypeEnum = {
    Cmi5: 'cmi5',
    Moodle: 'moodle'
} as const;
export type CourseList1CourseTypeEnum = typeof CourseList1CourseTypeEnum[keyof typeof CourseList1CourseTypeEnum];
/**
 * @export
 */
export const CourseList1SortByEnum = {
    Author: 'author',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Name: 'name'
} as const;
export type CourseList1SortByEnum = typeof CourseList1SortByEnum[keyof typeof CourseList1SortByEnum];
/**
 * @export
 */
export const CourseList1SortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type CourseList1SortEnum = typeof CourseList1SortEnum[keyof typeof CourseList1SortEnum];


/**
 * CourseManagementApi - axios parameter creator
 * @export
 */
export const CourseManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a course meta entry
         * @param {CourseMetaCreate} [courseMetaCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseCreate: async (courseMetaCreate?: CourseMetaCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/course/management/metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(courseMetaCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the available courses of all types
         * @param {string} [author] 
         * @param {string} [dateCreated] 
         * @param {string} [dateEdited] 
         * @param {CourseListCourseTypeEnum} [courseType] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {CourseListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {CourseListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseList: async (author?: string, dateCreated?: string, dateEdited?: string, courseType?: CourseListCourseTypeEnum, offset?: number, limit?: number, search?: string, sortBy?: CourseListSortByEnum, sort?: CourseListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/course/management`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (dateCreated !== undefined) {
                localVarQueryParameter['dateCreated'] = dateCreated;
            }

            if (dateEdited !== undefined) {
                localVarQueryParameter['dateEdited'] = dateEdited;
            }

            if (courseType !== undefined) {
                localVarQueryParameter['courseType'] = courseType;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a course meta entry
         * @param {CourseMetaUpdate} [courseMetaUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseUpdate: async (courseMetaUpdate?: CourseMetaUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/course/management/metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(courseMetaUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CourseManagementApi - functional programming interface
 * @export
 */
export const CourseManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CourseManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a course meta entry
         * @param {CourseMetaCreate} [courseMetaCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseCreate(courseMetaCreate?: CourseMetaCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseMeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseCreate(courseMetaCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseManagementApi.courseCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List the available courses of all types
         * @param {string} [author] 
         * @param {string} [dateCreated] 
         * @param {string} [dateEdited] 
         * @param {CourseListCourseTypeEnum} [courseType] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {CourseListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {CourseListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseList(author?: string, dateCreated?: string, dateEdited?: string, courseType?: CourseListCourseTypeEnum, offset?: number, limit?: number, search?: string, sortBy?: CourseListSortByEnum, sort?: CourseListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseList(author, dateCreated, dateEdited, courseType, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseManagementApi.courseList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a course meta entry
         * @param {CourseMetaUpdate} [courseMetaUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseUpdate(courseMetaUpdate?: CourseMetaUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseMeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseUpdate(courseMetaUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CourseManagementApi.courseUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CourseManagementApi - factory interface
 * @export
 */
export const CourseManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CourseManagementApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a course meta entry
         * @param {CourseMetaCreate} [courseMetaCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseCreate(courseMetaCreate?: CourseMetaCreate, options?: RawAxiosRequestConfig): AxiosPromise<CourseMeta> {
            return localVarFp.courseCreate(courseMetaCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the available courses of all types
         * @param {string} [author] 
         * @param {string} [dateCreated] 
         * @param {string} [dateEdited] 
         * @param {CourseListCourseTypeEnum} [courseType] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {CourseListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {CourseListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseList(author?: string, dateCreated?: string, dateEdited?: string, courseType?: CourseListCourseTypeEnum, offset?: number, limit?: number, search?: string, sortBy?: CourseListSortByEnum, sort?: CourseListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<CourseList200Response> {
            return localVarFp.courseList(author, dateCreated, dateEdited, courseType, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a course meta entry
         * @param {CourseMetaUpdate} [courseMetaUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseUpdate(courseMetaUpdate?: CourseMetaUpdate, options?: RawAxiosRequestConfig): AxiosPromise<CourseMeta> {
            return localVarFp.courseUpdate(courseMetaUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CourseManagementApi - object-oriented interface
 * @export
 * @class CourseManagementApi
 * @extends {BaseAPI}
 */
export class CourseManagementApi extends BaseAPI {
    /**
     * 
     * @summary Create a course meta entry
     * @param {CourseMetaCreate} [courseMetaCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseManagementApi
     */
    public courseCreate(courseMetaCreate?: CourseMetaCreate, options?: RawAxiosRequestConfig) {
        return CourseManagementApiFp(this.configuration).courseCreate(courseMetaCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the available courses of all types
     * @param {string} [author] 
     * @param {string} [dateCreated] 
     * @param {string} [dateEdited] 
     * @param {CourseListCourseTypeEnum} [courseType] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {CourseListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {CourseListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseManagementApi
     */
    public courseList(author?: string, dateCreated?: string, dateEdited?: string, courseType?: CourseListCourseTypeEnum, offset?: number, limit?: number, search?: string, sortBy?: CourseListSortByEnum, sort?: CourseListSortEnum, options?: RawAxiosRequestConfig) {
        return CourseManagementApiFp(this.configuration).courseList(author, dateCreated, dateEdited, courseType, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a course meta entry
     * @param {CourseMetaUpdate} [courseMetaUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseManagementApi
     */
    public courseUpdate(courseMetaUpdate?: CourseMetaUpdate, options?: RawAxiosRequestConfig) {
        return CourseManagementApiFp(this.configuration).courseUpdate(courseMetaUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const CourseListCourseTypeEnum = {
    Cmi5: 'cmi5',
    Moodle: 'moodle'
} as const;
export type CourseListCourseTypeEnum = typeof CourseListCourseTypeEnum[keyof typeof CourseListCourseTypeEnum];
/**
 * @export
 */
export const CourseListSortByEnum = {
    Author: 'author',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Name: 'name'
} as const;
export type CourseListSortByEnum = typeof CourseListSortByEnum[keyof typeof CourseListSortByEnum];
/**
 * @export
 */
export const CourseListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type CourseListSortEnum = typeof CourseListSortEnum[keyof typeof CourseListSortEnum];


/**
 * LRSGradesApi - axios parameter creator
 * @export
 */
export const LRSGradesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get user course grades
         * @param {string} courseId 
         * @param {boolean} [getStatements] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gradesGetCourseGrades: async (courseId: string, getStatements?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('gradesGetCourseGrades', 'courseId', courseId)
            const localVarPath = `/v1/lrs/grades/course/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (getStatements !== undefined) {
                localVarQueryParameter['getStatements'] = getStatements;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user au grades
         * @param {string} courseId 
         * @param {number} auIndex 
         * @param {boolean} [getStatements] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gradesGrade: async (courseId: string, auIndex: number, getStatements?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('gradesGrade', 'courseId', courseId)
            // verify required parameter 'auIndex' is not null or undefined
            assertParamExists('gradesGrade', 'auIndex', auIndex)
            const localVarPath = `/v1/lrs/grades/course/{courseId}/{auIndex}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)))
                .replace(`{${"auIndex"}}`, encodeURIComponent(String(auIndex)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (getStatements !== undefined) {
                localVarQueryParameter['getStatements'] = getStatements;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LRSGradesApi - functional programming interface
 * @export
 */
export const LRSGradesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LRSGradesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get user course grades
         * @param {string} courseId 
         * @param {boolean} [getStatements] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gradesGetCourseGrades(courseId: string, getStatements?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Grade>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gradesGetCourseGrades(courseId, getStatements, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LRSGradesApi.gradesGetCourseGrades']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user au grades
         * @param {string} courseId 
         * @param {number} auIndex 
         * @param {boolean} [getStatements] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gradesGrade(courseId: string, auIndex: number, getStatements?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Grade>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gradesGrade(courseId, auIndex, getStatements, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LRSGradesApi.gradesGrade']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LRSGradesApi - factory interface
 * @export
 */
export const LRSGradesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LRSGradesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get user course grades
         * @param {string} courseId 
         * @param {boolean} [getStatements] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gradesGetCourseGrades(courseId: string, getStatements?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<Grade>> {
            return localVarFp.gradesGetCourseGrades(courseId, getStatements, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user au grades
         * @param {string} courseId 
         * @param {number} auIndex 
         * @param {boolean} [getStatements] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gradesGrade(courseId: string, auIndex: number, getStatements?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Grade> {
            return localVarFp.gradesGrade(courseId, auIndex, getStatements, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LRSGradesApi - object-oriented interface
 * @export
 * @class LRSGradesApi
 * @extends {BaseAPI}
 */
export class LRSGradesApi extends BaseAPI {
    /**
     * 
     * @summary Get user course grades
     * @param {string} courseId 
     * @param {boolean} [getStatements] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LRSGradesApi
     */
    public gradesGetCourseGrades(courseId: string, getStatements?: boolean, options?: RawAxiosRequestConfig) {
        return LRSGradesApiFp(this.configuration).gradesGetCourseGrades(courseId, getStatements, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user au grades
     * @param {string} courseId 
     * @param {number} auIndex 
     * @param {boolean} [getStatements] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LRSGradesApi
     */
    public gradesGrade(courseId: string, auIndex: number, getStatements?: boolean, options?: RawAxiosRequestConfig) {
        return LRSGradesApiFp(this.configuration).gradesGrade(courseId, auIndex, getStatements, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LRSStatementApi - axios parameter creator
 * @export
 */
export const LRSStatementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get LRS statements
         * @param {string} [since] 
         * @param {string} [until] 
         * @param {string} [userId] 
         * @param {string} [verb] 
         * @param {string} [registration] 
         * @param {string} [auId] 
         * @param {string} [courseId] 
         * @param {string} [activityId] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {LrsStatementsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lrsStatementsList: async (since?: string, until?: string, userId?: string, verb?: string, registration?: string, auId?: string, courseId?: string, activityId?: string, offset?: number, limit?: number, search?: string, sort?: LrsStatementsListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/lrs/statement`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (since !== undefined) {
                localVarQueryParameter['since'] = since;
            }

            if (until !== undefined) {
                localVarQueryParameter['until'] = until;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (verb !== undefined) {
                localVarQueryParameter['verb'] = verb;
            }

            if (registration !== undefined) {
                localVarQueryParameter['registration'] = registration;
            }

            if (auId !== undefined) {
                localVarQueryParameter['auId'] = auId;
            }

            if (courseId !== undefined) {
                localVarQueryParameter['courseId'] = courseId;
            }

            if (activityId !== undefined) {
                localVarQueryParameter['activityId'] = activityId;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LRSStatementApi - functional programming interface
 * @export
 */
export const LRSStatementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LRSStatementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get LRS statements
         * @param {string} [since] 
         * @param {string} [until] 
         * @param {string} [userId] 
         * @param {string} [verb] 
         * @param {string} [registration] 
         * @param {string} [auId] 
         * @param {string} [courseId] 
         * @param {string} [activityId] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {LrsStatementsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lrsStatementsList(since?: string, until?: string, userId?: string, verb?: string, registration?: string, auId?: string, courseId?: string, activityId?: string, offset?: number, limit?: number, search?: string, sort?: LrsStatementsListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LrsStatementsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lrsStatementsList(since, until, userId, verb, registration, auId, courseId, activityId, offset, limit, search, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LRSStatementApi.lrsStatementsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LRSStatementApi - factory interface
 * @export
 */
export const LRSStatementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LRSStatementApiFp(configuration)
    return {
        /**
         * 
         * @summary Get LRS statements
         * @param {string} [since] 
         * @param {string} [until] 
         * @param {string} [userId] 
         * @param {string} [verb] 
         * @param {string} [registration] 
         * @param {string} [auId] 
         * @param {string} [courseId] 
         * @param {string} [activityId] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {LrsStatementsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lrsStatementsList(since?: string, until?: string, userId?: string, verb?: string, registration?: string, auId?: string, courseId?: string, activityId?: string, offset?: number, limit?: number, search?: string, sort?: LrsStatementsListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<LrsStatementsList200Response> {
            return localVarFp.lrsStatementsList(since, until, userId, verb, registration, auId, courseId, activityId, offset, limit, search, sort, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LRSStatementApi - object-oriented interface
 * @export
 * @class LRSStatementApi
 * @extends {BaseAPI}
 */
export class LRSStatementApi extends BaseAPI {
    /**
     * 
     * @summary Get LRS statements
     * @param {string} [since] 
     * @param {string} [until] 
     * @param {string} [userId] 
     * @param {string} [verb] 
     * @param {string} [registration] 
     * @param {string} [auId] 
     * @param {string} [courseId] 
     * @param {string} [activityId] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {LrsStatementsListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LRSStatementApi
     */
    public lrsStatementsList(since?: string, until?: string, userId?: string, verb?: string, registration?: string, auId?: string, courseId?: string, activityId?: string, offset?: number, limit?: number, search?: string, sort?: LrsStatementsListSortEnum, options?: RawAxiosRequestConfig) {
        return LRSStatementApiFp(this.configuration).lrsStatementsList(since, until, userId, verb, registration, auId, courseId, activityId, offset, limit, search, sort, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const LrsStatementsListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type LrsStatementsListSortEnum = typeof LrsStatementsListSortEnum[keyof typeof LrsStatementsListSortEnum];


/**
 * MoodleEnrollmentApi - axios parameter creator
 * @export
 */
export const MoodleEnrollmentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Enrolls a user into a moodle course
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moodleEnrollUserInCourse: async (courseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('moodleEnrollUserInCourse', 'courseId', courseId)
            const localVarPath = `/v1/moodle/enrollment/user/enroll/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the available moodle courses for the current user
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moodleListCurrentEnrollments: async (courseId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'courseId' is not null or undefined
            assertParamExists('moodleListCurrentEnrollments', 'courseId', courseId)
            const localVarPath = `/v1/moodle/enrollment/course/{courseId}`
                .replace(`{${"courseId"}}`, encodeURIComponent(String(courseId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the available moodle courses for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moodleListCurrentUserCourses: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/moodle/enrollment/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MoodleEnrollmentApi - functional programming interface
 * @export
 */
export const MoodleEnrollmentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MoodleEnrollmentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Enrolls a user into a moodle course
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moodleEnrollUserInCourse(courseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moodleEnrollUserInCourse(courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MoodleEnrollmentApi.moodleEnrollUserInCourse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List the available moodle courses for the current user
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moodleListCurrentEnrollments(courseId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moodleListCurrentEnrollments(courseId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MoodleEnrollmentApi.moodleListCurrentEnrollments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List the available moodle courses for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moodleListCurrentUserCourses(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moodleListCurrentUserCourses(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MoodleEnrollmentApi.moodleListCurrentUserCourses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MoodleEnrollmentApi - factory interface
 * @export
 */
export const MoodleEnrollmentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MoodleEnrollmentApiFp(configuration)
    return {
        /**
         * 
         * @summary Enrolls a user into a moodle course
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moodleEnrollUserInCourse(courseId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<object>> {
            return localVarFp.moodleEnrollUserInCourse(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the available moodle courses for the current user
         * @param {string} courseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moodleListCurrentEnrollments(courseId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<object>> {
            return localVarFp.moodleListCurrentEnrollments(courseId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the available moodle courses for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moodleListCurrentUserCourses(options?: RawAxiosRequestConfig): AxiosPromise<Array<object>> {
            return localVarFp.moodleListCurrentUserCourses(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MoodleEnrollmentApi - object-oriented interface
 * @export
 * @class MoodleEnrollmentApi
 * @extends {BaseAPI}
 */
export class MoodleEnrollmentApi extends BaseAPI {
    /**
     * 
     * @summary Enrolls a user into a moodle course
     * @param {string} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MoodleEnrollmentApi
     */
    public moodleEnrollUserInCourse(courseId: string, options?: RawAxiosRequestConfig) {
        return MoodleEnrollmentApiFp(this.configuration).moodleEnrollUserInCourse(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the available moodle courses for the current user
     * @param {string} courseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MoodleEnrollmentApi
     */
    public moodleListCurrentEnrollments(courseId: string, options?: RawAxiosRequestConfig) {
        return MoodleEnrollmentApiFp(this.configuration).moodleListCurrentEnrollments(courseId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the available moodle courses for the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MoodleEnrollmentApi
     */
    public moodleListCurrentUserCourses(options?: RawAxiosRequestConfig) {
        return MoodleEnrollmentApiFp(this.configuration).moodleListCurrentUserCourses(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MoodleManagementApi - axios parameter creator
 * @export
 */
export const MoodleManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List the available cmi5 courses
         * @param {string} [author] 
         * @param {string} [dateCreated] 
         * @param {string} [dateEdited] 
         * @param {MoodleListCourseTypeEnum} [courseType] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {MoodleListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moodleList: async (author?: string, dateCreated?: string, dateEdited?: string, courseType?: MoodleListCourseTypeEnum, offset?: number, limit?: number, search?: string, sort?: MoodleListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/moodle/management/course`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (dateCreated !== undefined) {
                localVarQueryParameter['dateCreated'] = dateCreated;
            }

            if (dateEdited !== undefined) {
                localVarQueryParameter['dateEdited'] = dateEdited;
            }

            if (courseType !== undefined) {
                localVarQueryParameter['courseType'] = courseType;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MoodleManagementApi - functional programming interface
 * @export
 */
export const MoodleManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MoodleManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List the available cmi5 courses
         * @param {string} [author] 
         * @param {string} [dateCreated] 
         * @param {string} [dateEdited] 
         * @param {MoodleListCourseTypeEnum} [courseType] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {MoodleListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moodleList(author?: string, dateCreated?: string, dateEdited?: string, courseType?: MoodleListCourseTypeEnum, offset?: number, limit?: number, search?: string, sort?: MoodleListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moodleList(author, dateCreated, dateEdited, courseType, offset, limit, search, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MoodleManagementApi.moodleList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MoodleManagementApi - factory interface
 * @export
 */
export const MoodleManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MoodleManagementApiFp(configuration)
    return {
        /**
         * 
         * @summary List the available cmi5 courses
         * @param {string} [author] 
         * @param {string} [dateCreated] 
         * @param {string} [dateEdited] 
         * @param {MoodleListCourseTypeEnum} [courseType] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {MoodleListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moodleList(author?: string, dateCreated?: string, dateEdited?: string, courseType?: MoodleListCourseTypeEnum, offset?: number, limit?: number, search?: string, sort?: MoodleListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<object>> {
            return localVarFp.moodleList(author, dateCreated, dateEdited, courseType, offset, limit, search, sort, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MoodleManagementApi - object-oriented interface
 * @export
 * @class MoodleManagementApi
 * @extends {BaseAPI}
 */
export class MoodleManagementApi extends BaseAPI {
    /**
     * 
     * @summary List the available cmi5 courses
     * @param {string} [author] 
     * @param {string} [dateCreated] 
     * @param {string} [dateEdited] 
     * @param {MoodleListCourseTypeEnum} [courseType] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {MoodleListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MoodleManagementApi
     */
    public moodleList(author?: string, dateCreated?: string, dateEdited?: string, courseType?: MoodleListCourseTypeEnum, offset?: number, limit?: number, search?: string, sort?: MoodleListSortEnum, options?: RawAxiosRequestConfig) {
        return MoodleManagementApiFp(this.configuration).moodleList(author, dateCreated, dateEdited, courseType, offset, limit, search, sort, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const MoodleListCourseTypeEnum = {
    Cmi5: 'cmi5',
    Moodle: 'moodle'
} as const;
export type MoodleListCourseTypeEnum = typeof MoodleListCourseTypeEnum[keyof typeof MoodleListCourseTypeEnum];
/**
 * @export
 */
export const MoodleListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type MoodleListSortEnum = typeof MoodleListSortEnum[keyof typeof MoodleListSortEnum];


/**
 * NICEKSATsApi - axios parameter creator
 * @export
 */
export const NICEKSATsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List of NICE KSATs
         * @param {Array<KsaTsListElementTypeEnum>} [elementType] 
         * @param {string} [elementIdentifier] 
         * @param {string} [title] 
         * @param {string} [text] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {KsaTsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {KsaTsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ksaTsList: async (elementType?: Array<KsaTsListElementTypeEnum>, elementIdentifier?: string, title?: string, text?: string, offset?: number, limit?: number, search?: string, sortBy?: KsaTsListSortByEnum, sort?: KsaTsListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/nice/ksats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (elementType) {
                localVarQueryParameter['element_type'] = elementType;
            }

            if (elementIdentifier !== undefined) {
                localVarQueryParameter['element_identifier'] = elementIdentifier;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NICEKSATsApi - functional programming interface
 * @export
 */
export const NICEKSATsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NICEKSATsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List of NICE KSATs
         * @param {Array<KsaTsListElementTypeEnum>} [elementType] 
         * @param {string} [elementIdentifier] 
         * @param {string} [title] 
         * @param {string} [text] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {KsaTsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {KsaTsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ksaTsList(elementType?: Array<KsaTsListElementTypeEnum>, elementIdentifier?: string, title?: string, text?: string, offset?: number, limit?: number, search?: string, sortBy?: KsaTsListSortByEnum, sort?: KsaTsListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KsaTsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ksaTsList(elementType, elementIdentifier, title, text, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NICEKSATsApi.ksaTsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NICEKSATsApi - factory interface
 * @export
 */
export const NICEKSATsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NICEKSATsApiFp(configuration)
    return {
        /**
         * 
         * @summary List of NICE KSATs
         * @param {Array<KsaTsListElementTypeEnum>} [elementType] 
         * @param {string} [elementIdentifier] 
         * @param {string} [title] 
         * @param {string} [text] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {KsaTsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {KsaTsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ksaTsList(elementType?: Array<KsaTsListElementTypeEnum>, elementIdentifier?: string, title?: string, text?: string, offset?: number, limit?: number, search?: string, sortBy?: KsaTsListSortByEnum, sort?: KsaTsListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<KsaTsList200Response> {
            return localVarFp.ksaTsList(elementType, elementIdentifier, title, text, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NICEKSATsApi - object-oriented interface
 * @export
 * @class NICEKSATsApi
 * @extends {BaseAPI}
 */
export class NICEKSATsApi extends BaseAPI {
    /**
     * 
     * @summary List of NICE KSATs
     * @param {Array<KsaTsListElementTypeEnum>} [elementType] 
     * @param {string} [elementIdentifier] 
     * @param {string} [title] 
     * @param {string} [text] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {KsaTsListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {KsaTsListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NICEKSATsApi
     */
    public ksaTsList(elementType?: Array<KsaTsListElementTypeEnum>, elementIdentifier?: string, title?: string, text?: string, offset?: number, limit?: number, search?: string, sortBy?: KsaTsListSortByEnum, sort?: KsaTsListSortEnum, options?: RawAxiosRequestConfig) {
        return NICEKSATsApiFp(this.configuration).ksaTsList(elementType, elementIdentifier, title, text, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const KsaTsListElementTypeEnum = {
    Category: 'category',
    CompetencyArea: 'competency_area',
    Knowledge: 'knowledge',
    OpmCode: 'opm_code',
    Skill: 'skill',
    Sort: 'sort',
    Task: 'task',
    WorkRole: 'work_role'
} as const;
export type KsaTsListElementTypeEnum = typeof KsaTsListElementTypeEnum[keyof typeof KsaTsListElementTypeEnum];
/**
 * @export
 */
export const KsaTsListSortByEnum = {
    ElementType: 'element_type',
    ElementIdentifier: 'element_identifier',
    Title: 'title',
    Text: 'text'
} as const;
export type KsaTsListSortByEnum = typeof KsaTsListSortByEnum[keyof typeof KsaTsListSortByEnum];
/**
 * @export
 */
export const KsaTsListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type KsaTsListSortEnum = typeof KsaTsListSortEnum[keyof typeof KsaTsListSortEnum];


