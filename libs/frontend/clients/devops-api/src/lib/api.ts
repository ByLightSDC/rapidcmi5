/* tslint:disable */
/* eslint-disable */
/**
 * DevOps-API
 * DevOps-API documentation
 *
 * The version of the OpenAPI document: v1alpha1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AclPackage
 */
export interface AclPackage {
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof AclPackage
     */
    'retrieve': Array<Array<string>>;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof AclPackage
     */
    'update': Array<Array<string>>;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof AclPackage
     */
    'delete': Array<Array<string>>;
}
/**
 * 
 * @export
 * @interface AclPackageCreate
 */
export interface AclPackageCreate {
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof AclPackageCreate
     */
    'retrieve': Array<Array<string>>;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof AclPackageCreate
     */
    'update': Array<Array<string>>;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof AclPackageCreate
     */
    'delete': Array<Array<string>>;
}
/**
 * 
 * @export
 * @interface AclRange
 */
export interface AclRange {
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof AclRange
     */
    'retrieve': Array<Array<string>>;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof AclRange
     */
    'update': Array<Array<string>>;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof AclRange
     */
    'delete': Array<Array<string>>;
    /**
     * MTO organizations allowed to deploy any scenario on this range
     * @type {Array<Array<string>>}
     * @memberof AclRange
     */
    'deploy': Array<Array<string>>;
    /**
     * MTO organizations allowed to undeploy any scenario on this range
     * @type {Array<Array<string>>}
     * @memberof AclRange
     */
    'undeploy': Array<Array<string>>;
}
/**
 * 
 * @export
 * @interface AclRangeCreate
 */
export interface AclRangeCreate {
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof AclRangeCreate
     */
    'retrieve': Array<Array<string>>;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof AclRangeCreate
     */
    'update': Array<Array<string>>;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof AclRangeCreate
     */
    'delete': Array<Array<string>>;
    /**
     * MTO organizations allowed to deploy any scenario on this range
     * @type {Array<Array<string>>}
     * @memberof AclRangeCreate
     */
    'deploy': Array<Array<string>>;
    /**
     * MTO organizations allowed to undeploy any scenario on this range
     * @type {Array<Array<string>>}
     * @memberof AclRangeCreate
     */
    'undeploy': Array<Array<string>>;
}
/**
 * 
 * @export
 * @interface AclScenario
 */
export interface AclScenario {
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof AclScenario
     */
    'retrieve': Array<Array<string>>;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof AclScenario
     */
    'update': Array<Array<string>>;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof AclScenario
     */
    'delete': Array<Array<string>>;
}
/**
 * 
 * @export
 * @interface AclScenarioCreate
 */
export interface AclScenarioCreate {
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof AclScenarioCreate
     */
    'retrieve': Array<Array<string>>;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof AclScenarioCreate
     */
    'update': Array<Array<string>>;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof AclScenarioCreate
     */
    'delete': Array<Array<string>>;
}
/**
 * 
 * @export
 * @interface AiQueryRequest
 */
export interface AiQueryRequest {
    /**
     * 
     * @type {string}
     * @memberof AiQueryRequest
     */
    'query'?: string;
}
/**
 * 
 * @export
 * @interface AnsiblePlaybook
 */
export interface AnsiblePlaybook {
    /**
     * 
     * @type {string}
     * @memberof AnsiblePlaybook
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof AnsiblePlaybook
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof AnsiblePlaybook
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof AnsiblePlaybook
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof AnsiblePlaybook
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof AnsiblePlaybook
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof AnsiblePlaybook
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof AnsiblePlaybook
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Array of Parent Playbook UUIDs
     * @type {Array<string>}
     * @memberof AnsiblePlaybook
     */
    'parentPlaybooks'?: Array<string>;
    /**
     * Array of Provisioning Service Module Details
     * @type {Array<AnsibleRoleDetails>}
     * @memberof AnsiblePlaybook
     */
    'roleDetails'?: Array<AnsibleRoleDetails>;
    /**
     * ID of VM Specification - one of vmSpecification or containerSpecification is required
     * @type {string}
     * @memberof AnsiblePlaybook
     */
    'vmSpecification'?: string | null;
    /**
     * ID of Container Specification - one of vmSpecification or containerSpecification is required
     * @type {string}
     * @memberof AnsiblePlaybook
     */
    'containerSpecification'?: string | null;
    /**
     * Indicates whether RangeAnsiblePlaybook requires elevated privileges to execute
     * @type {boolean}
     * @memberof AnsiblePlaybook
     */
    'requiresElevatedPrivileges'?: boolean;
}
/**
 * 
 * @export
 * @interface AnsiblePlaybookCreate
 */
export interface AnsiblePlaybookCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof AnsiblePlaybookCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof AnsiblePlaybookCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof AnsiblePlaybookCreate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof AnsiblePlaybookCreate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Array of Parent Playbook UUIDs
     * @type {Array<string>}
     * @memberof AnsiblePlaybookCreate
     */
    'parentPlaybooks': Array<string>;
    /**
     * Array of Provisioning Service Module Details
     * @type {Array<AnsibleRoleDetails>}
     * @memberof AnsiblePlaybookCreate
     */
    'roleDetails': Array<AnsibleRoleDetails>;
    /**
     * ID of VM Specification - one of vmSpecification or containerSpecification is required
     * @type {string}
     * @memberof AnsiblePlaybookCreate
     */
    'vmSpecification'?: string | null;
    /**
     * ID of Container Specification - one of vmSpecification or containerSpecification is required
     * @type {string}
     * @memberof AnsiblePlaybookCreate
     */
    'containerSpecification'?: string | null;
    /**
     * Indicates whether RangeAnsiblePlaybook requires elevated privileges to execute
     * @type {boolean}
     * @memberof AnsiblePlaybookCreate
     */
    'requiresElevatedPrivileges'?: boolean;
}
/**
 * 
 * @export
 * @interface AnsiblePlaybookOverride
 */
export interface AnsiblePlaybookOverride {
    /**
     * User provided metadata
     * @type {object}
     * @memberof AnsiblePlaybookOverride
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof AnsiblePlaybookOverride
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Indicates whether RangeAnsiblePlaybook requires elevated privileges to execute
     * @type {boolean}
     * @memberof AnsiblePlaybookOverride
     */
    'requiresElevatedPrivileges'?: boolean;
}
/**
 * 
 * @export
 * @interface AnsiblePlaybookUpdate
 */
export interface AnsiblePlaybookUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof AnsiblePlaybookUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof AnsiblePlaybookUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof AnsiblePlaybookUpdate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof AnsiblePlaybookUpdate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Array of Parent Playbook UUIDs
     * @type {Array<string>}
     * @memberof AnsiblePlaybookUpdate
     */
    'parentPlaybooks'?: Array<string>;
    /**
     * Array of Provisioning Service Module Details
     * @type {Array<AnsibleRoleDetails>}
     * @memberof AnsiblePlaybookUpdate
     */
    'roleDetails'?: Array<AnsibleRoleDetails>;
    /**
     * ID of VM Specification - one of vmSpecification or containerSpecification is required
     * @type {string}
     * @memberof AnsiblePlaybookUpdate
     */
    'vmSpecification'?: string | null;
    /**
     * ID of Container Specification - one of vmSpecification or containerSpecification is required
     * @type {string}
     * @memberof AnsiblePlaybookUpdate
     */
    'containerSpecification'?: string | null;
    /**
     * Indicates whether RangeAnsiblePlaybook requires elevated privileges to execute
     * @type {boolean}
     * @memberof AnsiblePlaybookUpdate
     */
    'requiresElevatedPrivileges'?: boolean;
}
/**
 * 
 * @export
 * @interface AnsiblePlaybooksList200Response
 */
export interface AnsiblePlaybooksList200Response {
    /**
     * 
     * @type {number}
     * @memberof AnsiblePlaybooksList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof AnsiblePlaybooksList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof AnsiblePlaybooksList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof AnsiblePlaybooksList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<AnsiblePlaybook>}
     * @memberof AnsiblePlaybooksList200Response
     */
    'data'?: Array<AnsiblePlaybook>;
}
/**
 * 
 * @export
 * @interface AnsibleRole
 */
export interface AnsibleRole {
    /**
     * 
     * @type {string}
     * @memberof AnsibleRole
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof AnsibleRole
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof AnsibleRole
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof AnsibleRole
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof AnsibleRole
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof AnsibleRole
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof AnsibleRole
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof AnsibleRole
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Filename of the the upload
     * @type {string}
     * @memberof AnsibleRole
     */
    'filename'?: string;
    /**
     * The signed https url for downloading the image
     * @type {string}
     * @memberof AnsibleRole
     */
    'publicUrl'?: string;
    /**
     * JSON Schema for Role Variables
     * @type {object}
     * @memberof AnsibleRole
     */
    'roleVariablesSchema'?: object;
    /**
     * Size of the image in bytes
     * @type {number}
     * @memberof AnsibleRole
     */
    'size'?: number;
    /**
     * Array of CPE UUIDs
     * @type {Array<string>}
     * @memberof AnsibleRole
     */
    'systemCpeUuids'?: Array<string>;
}
/**
 * 
 * @export
 * @interface AnsibleRoleCreate
 */
export interface AnsibleRoleCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof AnsibleRoleCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof AnsibleRoleCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof AnsibleRoleCreate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof AnsibleRoleCreate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * The file to upload
     * @type {File}
     * @memberof AnsibleRoleCreate
     */
    'file': File;
    /**
     * JSON Schema for Role Variables
     * @type {object}
     * @memberof AnsibleRoleCreate
     */
    'roleVariablesSchema'?: object;
    /**
     * Array of CPE UUIDs
     * @type {Array<string>}
     * @memberof AnsibleRoleCreate
     */
    'systemCpeUuids': Array<string>;
}
/**
 * 
 * @export
 * @interface AnsibleRoleDetails
 */
export interface AnsibleRoleDetails {
    /**
     * Role Variables in JSON format
     * @type {object}
     * @memberof AnsibleRoleDetails
     */
    'roleVariables'?: object;
    /**
     * ID of the Ansible Role
     * @type {string}
     * @memberof AnsibleRoleDetails
     */
    'ansibleRole': string;
    /**
     * List of Range Volume UUIDs to be mounted
     * @type {Array<string>}
     * @memberof AnsibleRoleDetails
     */
    'roleFiles'?: Array<string>;
}
/**
 * 
 * @export
 * @interface AnsibleRoleUpdate
 */
export interface AnsibleRoleUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof AnsibleRoleUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof AnsibleRoleUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof AnsibleRoleUpdate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof AnsibleRoleUpdate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * JSON Schema for Role Variables
     * @type {object}
     * @memberof AnsibleRoleUpdate
     */
    'roleVariablesSchema'?: object;
    /**
     * Array of CPE UUIDs
     * @type {Array<string>}
     * @memberof AnsibleRoleUpdate
     */
    'systemCpeUuids'?: Array<string>;
}
/**
 * 
 * @export
 * @interface AnsibleRolesList200Response
 */
export interface AnsibleRolesList200Response {
    /**
     * 
     * @type {number}
     * @memberof AnsibleRolesList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof AnsibleRolesList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof AnsibleRolesList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof AnsibleRolesList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<AnsibleRole>}
     * @memberof AnsibleRolesList200Response
     */
    'data'?: Array<AnsibleRole>;
}
/**
 * 
 * @export
 * @interface AutoGrader
 */
export interface AutoGrader {
    /**
     * 
     * @type {string}
     * @memberof AutoGrader
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof AutoGrader
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof AutoGrader
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof AutoGrader
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof AutoGrader
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof AutoGrader
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof AutoGrader
     */
    'metadata'?: object;
    /**
     * Optional additional information to pass to the given script at runtime
     * @type {{ [key: string]: any; }}
     * @memberof AutoGrader
     */
    'context'?: { [key: string]: any; } | null;
    /**
     * The script to execute on each received event
     * @type {string}
     * @memberof AutoGrader
     */
    'script'?: string;
    /**
     * 
     * @type {string}
     * @memberof AutoGrader
     */
    'checksum'?: string;
    /**
     * Related TelemetryAgent for this AutoGrader
     * @type {string}
     * @memberof AutoGrader
     */
    'telemetryAgent'?: string;
}
/**
 * 
 * @export
 * @interface AutoGraderCreate
 */
export interface AutoGraderCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof AutoGraderCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof AutoGraderCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof AutoGraderCreate
     */
    'metadata'?: object;
    /**
     * Optional additional information to pass to the given script at runtime
     * @type {{ [key: string]: any; }}
     * @memberof AutoGraderCreate
     */
    'context'?: { [key: string]: any; } | null;
    /**
     * The script to execute on each received event
     * @type {string}
     * @memberof AutoGraderCreate
     */
    'script': string;
    /**
     * Related TelemetryAgent for this AutoGrader
     * @type {string}
     * @memberof AutoGraderCreate
     */
    'telemetryAgent': string;
}
/**
 * 
 * @export
 * @interface AutoGraderResult
 */
export interface AutoGraderResult {
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof AutoGraderResult
     */
    'answers': { [key: string]: number; };
    /**
     * 
     * @type {boolean}
     * @memberof AutoGraderResult
     */
    'success'?: boolean;
}
/**
 * 
 * @export
 * @interface AutoGraderUpdate
 */
export interface AutoGraderUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof AutoGraderUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof AutoGraderUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof AutoGraderUpdate
     */
    'metadata'?: object;
    /**
     * Optional additional information to pass to the given script at runtime
     * @type {{ [key: string]: any; }}
     * @memberof AutoGraderUpdate
     */
    'context'?: { [key: string]: any; } | null;
    /**
     * The script to execute on each received event
     * @type {string}
     * @memberof AutoGraderUpdate
     */
    'script'?: string;
    /**
     * Related TelemetryAgent for this AutoGrader
     * @type {string}
     * @memberof AutoGraderUpdate
     */
    'telemetryAgent'?: string;
}
/**
 * 
 * @export
 * @interface AutoGradersEvaluateRequest
 */
export interface AutoGradersEvaluateRequest {
    /**
     * 
     * @type {object}
     * @memberof AutoGradersEvaluateRequest
     */
    'data'?: object;
}
/**
 * 
 * @export
 * @interface AutoGradersList200Response
 */
export interface AutoGradersList200Response {
    /**
     * 
     * @type {number}
     * @memberof AutoGradersList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof AutoGradersList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof AutoGradersList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof AutoGradersList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<AutoGrader>}
     * @memberof AutoGradersList200Response
     */
    'data'?: Array<AutoGrader>;
}
/**
 * 
 * @export
 * @interface AwsMachineConfig
 */
export interface AwsMachineConfig {
    /**
     * Aws access key
     * @type {string}
     * @memberof AwsMachineConfig
     */
    'accessKey'?: string;
    /**
     * Ami aws machine image
     * @type {string}
     * @memberof AwsMachineConfig
     */
    'ami'?: string;
    /**
     * API Version of the schema
     * @type {string}
     * @memberof AwsMachineConfig
     */
    'apiVersion'?: string;
    /**
     * BlockDurationMinutes AWS spot instance duration in minutes
     * @type {string}
     * @memberof AwsMachineConfig
     */
    'blockDurationMinutes'?: string;
    /**
     * Device Name AWS root device name
     * @type {string}
     * @memberof AwsMachineConfig
     */
    'deviceName'?: string;
    /**
     * Encrypt the EBS volume using the AWS managed CMK
     * @type {boolean}
     * @memberof AwsMachineConfig
     */
    'encryptEbsVolume'?: boolean;
    /**
     * Optional endpoint URL (hostname only or fully qualified URI
     * @type {string}
     * @memberof AwsMachineConfig
     */
    'endpoint'?: string;
    /**
     * Enables or disabled the HTTP metadata endpoint on your instances
     * @type {string}
     * @memberof AwsMachineConfig
     */
    'httpEndpoint'?: string;
    /**
     * The state of token usage for your instance metadata requests
     * @type {string}
     * @memberof AwsMachineConfig
     */
    'httpTokens'?: string;
    /**
     * AWS IAM Instance Profile
     * @type {string}
     * @memberof AwsMachineConfig
     */
    'iamInstanceProfile'?: string;
    /**
     * Disable SSL when sending requests
     * @type {boolean}
     * @memberof AwsMachineConfig
     */
    'insecureTransport'?: boolean;
    /**
     * AWS Ec2 Instance type
     * @type {string}
     * @memberof AwsMachineConfig
     */
    'instanceType'?: AwsMachineConfigInstanceTypeEnum;
    /**
     * AWS keypair to use; requires --amazonec2-ssh-keypath
     * @type {string}
     * @memberof AwsMachineConfig
     */
    'keypairName'?: string;
    /**
     * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase.
     * @type {string}
     * @memberof AwsMachineConfig
     */
    'kind'?: string;
    /**
     * Custom KMS key using the AWS Managed CMK
     * @type {string}
     * @memberof AwsMachineConfig
     */
    'kmsKey'?: string;
    /**
     * Set this flag to enable CloudWatch monitoring
     * @type {boolean}
     * @memberof AwsMachineConfig
     */
    'monitoring'?: boolean;
    /**
     * Make the specified port number accessible from the Internet
     * @type {Array<number>}
     * @memberof AwsMachineConfig
     */
    'openPort'?: Array<number>;
    /**
     * Only use a private IP address
     * @type {boolean}
     * @memberof AwsMachineConfig
     */
    'privateAddressOnly'?: boolean;
    /**
     * AWS region
     * @type {string}
     * @memberof AwsMachineConfig
     */
    'region'?: string;
    /**
     * Set this flag to request spot instance
     * @type {boolean}
     * @memberof AwsMachineConfig
     */
    'requestSpotInstance'?: boolean;
    /**
     * Set retry count for recoverable failures (use -1 to disable)
     * @type {string}
     * @memberof AwsMachineConfig
     */
    'retries'?: string;
    /**
     * AWS root disk size (in GB)
     * @type {string}
     * @memberof AwsMachineConfig
     */
    'rootSize'?: string;
    /**
     * AWS Secret Key
     * @type {string}
     * @memberof AwsMachineConfig
     */
    'secretKey'?: string;
    /**
     * AWS VPC security group
     * @type {Array<string>}
     * @memberof AwsMachineConfig
     */
    'securityGroup'?: Array<string>;
    /**
     * Skip adding default rules to security groups
     * @type {boolean}
     * @memberof AwsMachineConfig
     */
    'securityGroupReadOnly'?: boolean;
    /**
     * AWS Session Token
     * @type {string}
     * @memberof AwsMachineConfig
     */
    'sessionToken'?: string;
    /**
     * AWS spot instance bid price (in dollar)
     * @type {string}
     * @memberof AwsMachineConfig
     */
    'spotPrice'?: string;
    /**
     * File contents for sshKeyContents
     * @type {string}
     * @memberof AwsMachineConfig
     */
    'sshKeyContents'?: string;
    /**
     * Set the name of the ssh user
     * @type {string}
     * @memberof AwsMachineConfig
     */
    'sshUser'?: string;
    /**
     * AWS VPC subnet id
     * @type {string}
     * @memberof AwsMachineConfig
     */
    'subnetId'?: string;
    /**
     * AWS Tags (e.g. key1,value1,key2,value2
     * @type {string}
     * @memberof AwsMachineConfig
     */
    'tags'?: string;
    /**
     * Create an EBS optimized instance
     * @type {boolean}
     * @memberof AwsMachineConfig
     */
    'useEbsOptimizedInstance'?: boolean;
    /**
     * Force the usage of private IP address
     * @type {boolean}
     * @memberof AwsMachineConfig
     */
    'usePrivateAddress'?: boolean;
    /**
     * File contents for userdata
     * @type {string}
     * @memberof AwsMachineConfig
     */
    'userdata'?: string;
    /**
     * Amazon EBS volume type
     * @type {string}
     * @memberof AwsMachineConfig
     */
    'volumeType'?: string;
    /**
     * AWS VPC id
     * @type {string}
     * @memberof AwsMachineConfig
     */
    'vpcId'?: string;
    /**
     * AWS zone for instance (i.e. a,b,c,d,e)
     * @type {string}
     * @memberof AwsMachineConfig
     */
    'zone'?: AwsMachineConfigZoneEnum;
}

export const AwsMachineConfigInstanceTypeEnum = {
    T2Micro: 't2.micro',
    T2Small: 't2.small',
    T2Medium: 't2.medium',
    T2Large: 't2.large',
    T2Xlarge: 't2.xlarge',
    T22xlarge: 't2.2xlarge',
    T3Nano: 't3.nano',
    T3Micro: 't3.micro',
    T3Small: 't3.small',
    T3Medium: 't3.medium',
    T3Large: 't3.large',
    T3Xlarge: 't3.xlarge',
    T32xlarge: 't3.2xlarge',
    M5Large: 'm5.large',
    M5Xlarge: 'm5.xlarge',
    M52xlarge: 'm5.2xlarge',
    M54xlarge: 'm5.4xlarge',
    M58xlarge: 'm5.8xlarge',
    M512xlarge: 'm5.12xlarge',
    M516xlarge: 'm5.16xlarge',
    M524xlarge: 'm5.24xlarge',
    M5Metal: 'm5.metal',
    M6iMetal: 'm6i.metal',
    C5Large: 'c5.large',
    C5Xlarge: 'c5.xlarge',
    C52xlarge: 'c5.2xlarge',
    C54xlarge: 'c5.4xlarge',
    C59xlarge: 'c5.9xlarge',
    C512xlarge: 'c5.12xlarge',
    C518xlarge: 'c5.18xlarge',
    C524xlarge: 'c5.24xlarge',
    C5Metal: 'c5.metal',
    R5Large: 'r5.large',
    R5Xlarge: 'r5.xlarge',
    R52xlarge: 'r5.2xlarge',
    R54xlarge: 'r5.4xlarge',
    R58xlarge: 'r5.8xlarge',
    R512xlarge: 'r5.12xlarge',
    R516xlarge: 'r5.16xlarge',
    R524xlarge: 'r5.24xlarge',
    R5Metal: 'r5.metal',
    I3Large: 'i3.large',
    I3Xlarge: 'i3.xlarge',
    I32xlarge: 'i3.2xlarge',
    I34xlarge: 'i3.4xlarge',
    I38xlarge: 'i3.8xlarge',
    I316xlarge: 'i3.16xlarge',
    I3Metal: 'i3.metal',
    P2Xlarge: 'p2.xlarge',
    P28xlarge: 'p2.8xlarge',
    P216xlarge: 'p2.16xlarge',
    P32xlarge: 'p3.2xlarge',
    P38xlarge: 'p3.8xlarge',
    P316xlarge: 'p3.16xlarge',
    P324xlarge: 'p3.24xlarge',
    P3Metal: 'p3.metal',
    F12xlarge: 'f1.2xlarge',
    F14xlarge: 'f1.4xlarge',
    F116xlarge: 'f1.16xlarge',
    A1Medium: 'a1.medium',
    A1Large: 'a1.large',
    A1Xlarge: 'a1.xlarge',
    A12xlarge: 'a1.2xlarge',
    D2Xlarge: 'd2.xlarge',
    D22xlarge: 'd2.2xlarge',
    D24xlarge: 'd2.4xlarge',
    D28xlarge: 'd2.8xlarge',
    H12xlarge: 'h1.2xlarge',
    H14xlarge: 'h1.4xlarge',
    H18xlarge: 'h1.8xlarge',
    H116xlarge: 'h1.16xlarge',
    X116xlarge: 'x1.16xlarge',
    X132xlarge: 'x1.32xlarge',
    X1eXlarge: 'x1e.xlarge',
    X1e2xlarge: 'x1e.2xlarge',
    X1e4xlarge: 'x1e.4xlarge',
    X1e8xlarge: 'x1e.8xlarge',
    X1e16xlarge: 'x1e.16xlarge',
    X1e32xlarge: 'x1e.32xlarge',
    P3dn2xlarge: 'p3dn.2xlarge',
    P3dn8xlarge: 'p3dn.8xlarge'
} as const;

export type AwsMachineConfigInstanceTypeEnum = typeof AwsMachineConfigInstanceTypeEnum[keyof typeof AwsMachineConfigInstanceTypeEnum];
export const AwsMachineConfigZoneEnum = {
    A: 'a',
    B: 'b',
    C: 'c',
    D: 'd',
    E: 'e'
} as const;

export type AwsMachineConfigZoneEnum = typeof AwsMachineConfigZoneEnum[keyof typeof AwsMachineConfigZoneEnum];

/**
 * 
 * @export
 * @interface AwsMachineConfigCreate
 */
export interface AwsMachineConfigCreate {
    /**
     * Aws access key
     * @type {string}
     * @memberof AwsMachineConfigCreate
     */
    'accessKey'?: string;
    /**
     * Ami aws machine image
     * @type {string}
     * @memberof AwsMachineConfigCreate
     */
    'ami'?: string;
    /**
     * API Version of the schema
     * @type {string}
     * @memberof AwsMachineConfigCreate
     */
    'apiVersion'?: string;
    /**
     * BlockDurationMinutes AWS spot instance duration in minutes
     * @type {string}
     * @memberof AwsMachineConfigCreate
     */
    'blockDurationMinutes'?: string;
    /**
     * Device Name AWS root device name
     * @type {string}
     * @memberof AwsMachineConfigCreate
     */
    'deviceName'?: string;
    /**
     * Encrypt the EBS volume using the AWS managed CMK
     * @type {boolean}
     * @memberof AwsMachineConfigCreate
     */
    'encryptEbsVolume'?: boolean;
    /**
     * Optional endpoint URL (hostname only or fully qualified URI
     * @type {string}
     * @memberof AwsMachineConfigCreate
     */
    'endpoint'?: string;
    /**
     * Enables or disabled the HTTP metadata endpoint on your instances
     * @type {string}
     * @memberof AwsMachineConfigCreate
     */
    'httpEndpoint'?: string;
    /**
     * The state of token usage for your instance metadata requests
     * @type {string}
     * @memberof AwsMachineConfigCreate
     */
    'httpTokens'?: string;
    /**
     * AWS IAM Instance Profile
     * @type {string}
     * @memberof AwsMachineConfigCreate
     */
    'iamInstanceProfile': string;
    /**
     * Disable SSL when sending requests
     * @type {boolean}
     * @memberof AwsMachineConfigCreate
     */
    'insecureTransport'?: boolean;
    /**
     * AWS Ec2 Instance type
     * @type {string}
     * @memberof AwsMachineConfigCreate
     */
    'instanceType': AwsMachineConfigCreateInstanceTypeEnum;
    /**
     * AWS keypair to use; requires --amazonec2-ssh-keypath
     * @type {string}
     * @memberof AwsMachineConfigCreate
     */
    'keypairName'?: string;
    /**
     * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase.
     * @type {string}
     * @memberof AwsMachineConfigCreate
     */
    'kind'?: string;
    /**
     * Custom KMS key using the AWS Managed CMK
     * @type {string}
     * @memberof AwsMachineConfigCreate
     */
    'kmsKey'?: string;
    /**
     * Set this flag to enable CloudWatch monitoring
     * @type {boolean}
     * @memberof AwsMachineConfigCreate
     */
    'monitoring'?: boolean;
    /**
     * Make the specified port number accessible from the Internet
     * @type {Array<number>}
     * @memberof AwsMachineConfigCreate
     */
    'openPort'?: Array<number>;
    /**
     * Only use a private IP address
     * @type {boolean}
     * @memberof AwsMachineConfigCreate
     */
    'privateAddressOnly'?: boolean;
    /**
     * AWS region
     * @type {string}
     * @memberof AwsMachineConfigCreate
     */
    'region': string;
    /**
     * Set this flag to request spot instance
     * @type {boolean}
     * @memberof AwsMachineConfigCreate
     */
    'requestSpotInstance'?: boolean;
    /**
     * Set retry count for recoverable failures (use -1 to disable)
     * @type {string}
     * @memberof AwsMachineConfigCreate
     */
    'retries'?: string;
    /**
     * AWS root disk size (in GB)
     * @type {string}
     * @memberof AwsMachineConfigCreate
     */
    'rootSize': string;
    /**
     * AWS Secret Key
     * @type {string}
     * @memberof AwsMachineConfigCreate
     */
    'secretKey'?: string;
    /**
     * AWS VPC security group
     * @type {Array<string>}
     * @memberof AwsMachineConfigCreate
     */
    'securityGroup': Array<string>;
    /**
     * Skip adding default rules to security groups
     * @type {boolean}
     * @memberof AwsMachineConfigCreate
     */
    'securityGroupReadOnly'?: boolean;
    /**
     * AWS Session Token
     * @type {string}
     * @memberof AwsMachineConfigCreate
     */
    'sessionToken'?: string;
    /**
     * AWS spot instance bid price (in dollar)
     * @type {string}
     * @memberof AwsMachineConfigCreate
     */
    'spotPrice'?: string;
    /**
     * File contents for sshKeyContents
     * @type {string}
     * @memberof AwsMachineConfigCreate
     */
    'sshKeyContents'?: string;
    /**
     * Set the name of the ssh user
     * @type {string}
     * @memberof AwsMachineConfigCreate
     */
    'sshUser'?: string;
    /**
     * AWS VPC subnet id
     * @type {string}
     * @memberof AwsMachineConfigCreate
     */
    'subnetId': string;
    /**
     * AWS Tags (e.g. key1,value1,key2,value2
     * @type {string}
     * @memberof AwsMachineConfigCreate
     */
    'tags': string;
    /**
     * Create an EBS optimized instance
     * @type {boolean}
     * @memberof AwsMachineConfigCreate
     */
    'useEbsOptimizedInstance'?: boolean;
    /**
     * Force the usage of private IP address
     * @type {boolean}
     * @memberof AwsMachineConfigCreate
     */
    'usePrivateAddress'?: boolean;
    /**
     * File contents for userdata
     * @type {string}
     * @memberof AwsMachineConfigCreate
     */
    'userdata'?: string;
    /**
     * Amazon EBS volume type
     * @type {string}
     * @memberof AwsMachineConfigCreate
     */
    'volumeType'?: string;
    /**
     * AWS VPC id
     * @type {string}
     * @memberof AwsMachineConfigCreate
     */
    'vpcId'?: string;
    /**
     * AWS zone for instance (i.e. a,b,c,d,e)
     * @type {string}
     * @memberof AwsMachineConfigCreate
     */
    'zone'?: AwsMachineConfigCreateZoneEnum;
}

export const AwsMachineConfigCreateInstanceTypeEnum = {
    T2Micro: 't2.micro',
    T2Small: 't2.small',
    T2Medium: 't2.medium',
    T2Large: 't2.large',
    T2Xlarge: 't2.xlarge',
    T22xlarge: 't2.2xlarge',
    T3Nano: 't3.nano',
    T3Micro: 't3.micro',
    T3Small: 't3.small',
    T3Medium: 't3.medium',
    T3Large: 't3.large',
    T3Xlarge: 't3.xlarge',
    T32xlarge: 't3.2xlarge',
    M5Large: 'm5.large',
    M5Xlarge: 'm5.xlarge',
    M52xlarge: 'm5.2xlarge',
    M54xlarge: 'm5.4xlarge',
    M58xlarge: 'm5.8xlarge',
    M512xlarge: 'm5.12xlarge',
    M516xlarge: 'm5.16xlarge',
    M524xlarge: 'm5.24xlarge',
    M5Metal: 'm5.metal',
    M6iMetal: 'm6i.metal',
    C5Large: 'c5.large',
    C5Xlarge: 'c5.xlarge',
    C52xlarge: 'c5.2xlarge',
    C54xlarge: 'c5.4xlarge',
    C59xlarge: 'c5.9xlarge',
    C512xlarge: 'c5.12xlarge',
    C518xlarge: 'c5.18xlarge',
    C524xlarge: 'c5.24xlarge',
    C5Metal: 'c5.metal',
    R5Large: 'r5.large',
    R5Xlarge: 'r5.xlarge',
    R52xlarge: 'r5.2xlarge',
    R54xlarge: 'r5.4xlarge',
    R58xlarge: 'r5.8xlarge',
    R512xlarge: 'r5.12xlarge',
    R516xlarge: 'r5.16xlarge',
    R524xlarge: 'r5.24xlarge',
    R5Metal: 'r5.metal',
    I3Large: 'i3.large',
    I3Xlarge: 'i3.xlarge',
    I32xlarge: 'i3.2xlarge',
    I34xlarge: 'i3.4xlarge',
    I38xlarge: 'i3.8xlarge',
    I316xlarge: 'i3.16xlarge',
    I3Metal: 'i3.metal',
    P2Xlarge: 'p2.xlarge',
    P28xlarge: 'p2.8xlarge',
    P216xlarge: 'p2.16xlarge',
    P32xlarge: 'p3.2xlarge',
    P38xlarge: 'p3.8xlarge',
    P316xlarge: 'p3.16xlarge',
    P324xlarge: 'p3.24xlarge',
    P3Metal: 'p3.metal',
    F12xlarge: 'f1.2xlarge',
    F14xlarge: 'f1.4xlarge',
    F116xlarge: 'f1.16xlarge',
    A1Medium: 'a1.medium',
    A1Large: 'a1.large',
    A1Xlarge: 'a1.xlarge',
    A12xlarge: 'a1.2xlarge',
    D2Xlarge: 'd2.xlarge',
    D22xlarge: 'd2.2xlarge',
    D24xlarge: 'd2.4xlarge',
    D28xlarge: 'd2.8xlarge',
    H12xlarge: 'h1.2xlarge',
    H14xlarge: 'h1.4xlarge',
    H18xlarge: 'h1.8xlarge',
    H116xlarge: 'h1.16xlarge',
    X116xlarge: 'x1.16xlarge',
    X132xlarge: 'x1.32xlarge',
    X1eXlarge: 'x1e.xlarge',
    X1e2xlarge: 'x1e.2xlarge',
    X1e4xlarge: 'x1e.4xlarge',
    X1e8xlarge: 'x1e.8xlarge',
    X1e16xlarge: 'x1e.16xlarge',
    X1e32xlarge: 'x1e.32xlarge',
    P3dn2xlarge: 'p3dn.2xlarge',
    P3dn8xlarge: 'p3dn.8xlarge'
} as const;

export type AwsMachineConfigCreateInstanceTypeEnum = typeof AwsMachineConfigCreateInstanceTypeEnum[keyof typeof AwsMachineConfigCreateInstanceTypeEnum];
export const AwsMachineConfigCreateZoneEnum = {
    A: 'a',
    B: 'b',
    C: 'c',
    D: 'd',
    E: 'e'
} as const;

export type AwsMachineConfigCreateZoneEnum = typeof AwsMachineConfigCreateZoneEnum[keyof typeof AwsMachineConfigCreateZoneEnum];

/**
 * 
 * @export
 * @interface AwsMachineConfigUpdate
 */
export interface AwsMachineConfigUpdate {
    /**
     * Aws access key
     * @type {string}
     * @memberof AwsMachineConfigUpdate
     */
    'accessKey'?: string;
    /**
     * Ami aws machine image
     * @type {string}
     * @memberof AwsMachineConfigUpdate
     */
    'ami'?: string;
    /**
     * API Version of the schema
     * @type {string}
     * @memberof AwsMachineConfigUpdate
     */
    'apiVersion'?: string;
    /**
     * BlockDurationMinutes AWS spot instance duration in minutes
     * @type {string}
     * @memberof AwsMachineConfigUpdate
     */
    'blockDurationMinutes'?: string;
    /**
     * Device Name AWS root device name
     * @type {string}
     * @memberof AwsMachineConfigUpdate
     */
    'deviceName'?: string;
    /**
     * Encrypt the EBS volume using the AWS managed CMK
     * @type {boolean}
     * @memberof AwsMachineConfigUpdate
     */
    'encryptEbsVolume'?: boolean;
    /**
     * Optional endpoint URL (hostname only or fully qualified URI
     * @type {string}
     * @memberof AwsMachineConfigUpdate
     */
    'endpoint'?: string;
    /**
     * Enables or disabled the HTTP metadata endpoint on your instances
     * @type {string}
     * @memberof AwsMachineConfigUpdate
     */
    'httpEndpoint'?: string;
    /**
     * The state of token usage for your instance metadata requests
     * @type {string}
     * @memberof AwsMachineConfigUpdate
     */
    'httpTokens'?: string;
    /**
     * AWS IAM Instance Profile
     * @type {string}
     * @memberof AwsMachineConfigUpdate
     */
    'iamInstanceProfile'?: string;
    /**
     * Disable SSL when sending requests
     * @type {boolean}
     * @memberof AwsMachineConfigUpdate
     */
    'insecureTransport'?: boolean;
    /**
     * AWS Ec2 Instance type
     * @type {string}
     * @memberof AwsMachineConfigUpdate
     */
    'instanceType'?: AwsMachineConfigUpdateInstanceTypeEnum;
    /**
     * AWS keypair to use; requires --amazonec2-ssh-keypath
     * @type {string}
     * @memberof AwsMachineConfigUpdate
     */
    'keypairName'?: string;
    /**
     * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase.
     * @type {string}
     * @memberof AwsMachineConfigUpdate
     */
    'kind'?: string;
    /**
     * Custom KMS key using the AWS Managed CMK
     * @type {string}
     * @memberof AwsMachineConfigUpdate
     */
    'kmsKey'?: string;
    /**
     * Set this flag to enable CloudWatch monitoring
     * @type {boolean}
     * @memberof AwsMachineConfigUpdate
     */
    'monitoring'?: boolean;
    /**
     * Make the specified port number accessible from the Internet
     * @type {Array<number>}
     * @memberof AwsMachineConfigUpdate
     */
    'openPort'?: Array<number>;
    /**
     * Only use a private IP address
     * @type {boolean}
     * @memberof AwsMachineConfigUpdate
     */
    'privateAddressOnly'?: boolean;
    /**
     * AWS region
     * @type {string}
     * @memberof AwsMachineConfigUpdate
     */
    'region'?: string;
    /**
     * Set this flag to request spot instance
     * @type {boolean}
     * @memberof AwsMachineConfigUpdate
     */
    'requestSpotInstance'?: boolean;
    /**
     * Set retry count for recoverable failures (use -1 to disable)
     * @type {string}
     * @memberof AwsMachineConfigUpdate
     */
    'retries'?: string;
    /**
     * AWS root disk size (in GB)
     * @type {string}
     * @memberof AwsMachineConfigUpdate
     */
    'rootSize'?: string;
    /**
     * AWS Secret Key
     * @type {string}
     * @memberof AwsMachineConfigUpdate
     */
    'secretKey'?: string;
    /**
     * AWS VPC security group
     * @type {Array<string>}
     * @memberof AwsMachineConfigUpdate
     */
    'securityGroup'?: Array<string>;
    /**
     * Skip adding default rules to security groups
     * @type {boolean}
     * @memberof AwsMachineConfigUpdate
     */
    'securityGroupReadOnly'?: boolean;
    /**
     * AWS Session Token
     * @type {string}
     * @memberof AwsMachineConfigUpdate
     */
    'sessionToken'?: string;
    /**
     * AWS spot instance bid price (in dollar)
     * @type {string}
     * @memberof AwsMachineConfigUpdate
     */
    'spotPrice'?: string;
    /**
     * File contents for sshKeyContents
     * @type {string}
     * @memberof AwsMachineConfigUpdate
     */
    'sshKeyContents'?: string;
    /**
     * Set the name of the ssh user
     * @type {string}
     * @memberof AwsMachineConfigUpdate
     */
    'sshUser'?: string;
    /**
     * AWS VPC subnet id
     * @type {string}
     * @memberof AwsMachineConfigUpdate
     */
    'subnetId'?: string;
    /**
     * AWS Tags (e.g. key1,value1,key2,value2
     * @type {string}
     * @memberof AwsMachineConfigUpdate
     */
    'tags'?: string;
    /**
     * Create an EBS optimized instance
     * @type {boolean}
     * @memberof AwsMachineConfigUpdate
     */
    'useEbsOptimizedInstance'?: boolean;
    /**
     * Force the usage of private IP address
     * @type {boolean}
     * @memberof AwsMachineConfigUpdate
     */
    'usePrivateAddress'?: boolean;
    /**
     * File contents for userdata
     * @type {string}
     * @memberof AwsMachineConfigUpdate
     */
    'userdata'?: string;
    /**
     * Amazon EBS volume type
     * @type {string}
     * @memberof AwsMachineConfigUpdate
     */
    'volumeType'?: string;
    /**
     * AWS VPC id
     * @type {string}
     * @memberof AwsMachineConfigUpdate
     */
    'vpcId'?: string;
    /**
     * AWS zone for instance (i.e. a,b,c,d,e)
     * @type {string}
     * @memberof AwsMachineConfigUpdate
     */
    'zone'?: AwsMachineConfigUpdateZoneEnum;
}

export const AwsMachineConfigUpdateInstanceTypeEnum = {
    T2Micro: 't2.micro',
    T2Small: 't2.small',
    T2Medium: 't2.medium',
    T2Large: 't2.large',
    T2Xlarge: 't2.xlarge',
    T22xlarge: 't2.2xlarge',
    T3Nano: 't3.nano',
    T3Micro: 't3.micro',
    T3Small: 't3.small',
    T3Medium: 't3.medium',
    T3Large: 't3.large',
    T3Xlarge: 't3.xlarge',
    T32xlarge: 't3.2xlarge',
    M5Large: 'm5.large',
    M5Xlarge: 'm5.xlarge',
    M52xlarge: 'm5.2xlarge',
    M54xlarge: 'm5.4xlarge',
    M58xlarge: 'm5.8xlarge',
    M512xlarge: 'm5.12xlarge',
    M516xlarge: 'm5.16xlarge',
    M524xlarge: 'm5.24xlarge',
    M5Metal: 'm5.metal',
    M6iMetal: 'm6i.metal',
    C5Large: 'c5.large',
    C5Xlarge: 'c5.xlarge',
    C52xlarge: 'c5.2xlarge',
    C54xlarge: 'c5.4xlarge',
    C59xlarge: 'c5.9xlarge',
    C512xlarge: 'c5.12xlarge',
    C518xlarge: 'c5.18xlarge',
    C524xlarge: 'c5.24xlarge',
    C5Metal: 'c5.metal',
    R5Large: 'r5.large',
    R5Xlarge: 'r5.xlarge',
    R52xlarge: 'r5.2xlarge',
    R54xlarge: 'r5.4xlarge',
    R58xlarge: 'r5.8xlarge',
    R512xlarge: 'r5.12xlarge',
    R516xlarge: 'r5.16xlarge',
    R524xlarge: 'r5.24xlarge',
    R5Metal: 'r5.metal',
    I3Large: 'i3.large',
    I3Xlarge: 'i3.xlarge',
    I32xlarge: 'i3.2xlarge',
    I34xlarge: 'i3.4xlarge',
    I38xlarge: 'i3.8xlarge',
    I316xlarge: 'i3.16xlarge',
    I3Metal: 'i3.metal',
    P2Xlarge: 'p2.xlarge',
    P28xlarge: 'p2.8xlarge',
    P216xlarge: 'p2.16xlarge',
    P32xlarge: 'p3.2xlarge',
    P38xlarge: 'p3.8xlarge',
    P316xlarge: 'p3.16xlarge',
    P324xlarge: 'p3.24xlarge',
    P3Metal: 'p3.metal',
    F12xlarge: 'f1.2xlarge',
    F14xlarge: 'f1.4xlarge',
    F116xlarge: 'f1.16xlarge',
    A1Medium: 'a1.medium',
    A1Large: 'a1.large',
    A1Xlarge: 'a1.xlarge',
    A12xlarge: 'a1.2xlarge',
    D2Xlarge: 'd2.xlarge',
    D22xlarge: 'd2.2xlarge',
    D24xlarge: 'd2.4xlarge',
    D28xlarge: 'd2.8xlarge',
    H12xlarge: 'h1.2xlarge',
    H14xlarge: 'h1.4xlarge',
    H18xlarge: 'h1.8xlarge',
    H116xlarge: 'h1.16xlarge',
    X116xlarge: 'x1.16xlarge',
    X132xlarge: 'x1.32xlarge',
    X1eXlarge: 'x1e.xlarge',
    X1e2xlarge: 'x1e.2xlarge',
    X1e4xlarge: 'x1e.4xlarge',
    X1e8xlarge: 'x1e.8xlarge',
    X1e16xlarge: 'x1e.16xlarge',
    X1e32xlarge: 'x1e.32xlarge',
    P3dn2xlarge: 'p3dn.2xlarge',
    P3dn8xlarge: 'p3dn.8xlarge'
} as const;

export type AwsMachineConfigUpdateInstanceTypeEnum = typeof AwsMachineConfigUpdateInstanceTypeEnum[keyof typeof AwsMachineConfigUpdateInstanceTypeEnum];
export const AwsMachineConfigUpdateZoneEnum = {
    A: 'a',
    B: 'b',
    C: 'c',
    D: 'd',
    E: 'e'
} as const;

export type AwsMachineConfigUpdateZoneEnum = typeof AwsMachineConfigUpdateZoneEnum[keyof typeof AwsMachineConfigUpdateZoneEnum];

/**
 * 
 * @export
 * @interface AwsMachinePool
 */
export interface AwsMachinePool {
    /**
     * If true, assigns the Control Plane role to machines in this pool
     * @type {boolean}
     * @memberof AwsMachinePool
     */
    'controlPlaneRole'?: boolean;
    /**
     * If true, assigns the etcd role to machines in this pool
     * @type {boolean}
     * @memberof AwsMachinePool
     */
    'etcdRole'?: boolean;
    /**
     * If true, assigns the worker role to machines in this pool
     * @type {boolean}
     * @memberof AwsMachinePool
     */
    'workerRole'?: boolean;
    /**
     * Labels to assign to machines in this pool
     * @type {{ [key: string]: string; }}
     * @memberof AwsMachinePool
     */
    'labels'?: { [key: string]: string; };
    /**
     * Name of the machine pool, should be unique for a range
     * @type {string}
     * @memberof AwsMachinePool
     */
    'name'?: string;
    /**
     * Number of machines in the pool
     * @type {number}
     * @memberof AwsMachinePool
     */
    'quantity'?: number;
    /**
     * Taints to assign to machines in this pool
     * @type {Array<MachineTaint>}
     * @memberof AwsMachinePool
     */
    'taints'?: Array<MachineTaint>;
    /**
     * Time (in secs) before a machine is considered unhealthy if it cannot be reached
     * @type {number}
     * @memberof AwsMachinePool
     */
    'unhealthyNodeTimeout'?: number;
    /**
     * 
     * @type {AwsMachineConfig}
     * @memberof AwsMachinePool
     */
    'machineConfig'?: AwsMachineConfig;
}
/**
 * 
 * @export
 * @interface AwsMachinePoolCreate
 */
export interface AwsMachinePoolCreate {
    /**
     * If true, assigns the Control Plane role to machines in this pool
     * @type {boolean}
     * @memberof AwsMachinePoolCreate
     */
    'controlPlaneRole'?: boolean;
    /**
     * If true, assigns the etcd role to machines in this pool
     * @type {boolean}
     * @memberof AwsMachinePoolCreate
     */
    'etcdRole'?: boolean;
    /**
     * If true, assigns the worker role to machines in this pool
     * @type {boolean}
     * @memberof AwsMachinePoolCreate
     */
    'workerRole'?: boolean;
    /**
     * Labels to assign to machines in this pool
     * @type {{ [key: string]: string; }}
     * @memberof AwsMachinePoolCreate
     */
    'labels'?: { [key: string]: string; };
    /**
     * Name of the machine pool, should be unique for a range
     * @type {string}
     * @memberof AwsMachinePoolCreate
     */
    'name'?: string;
    /**
     * Number of machines in the pool
     * @type {number}
     * @memberof AwsMachinePoolCreate
     */
    'quantity'?: number;
    /**
     * Taints to assign to machines in this pool
     * @type {Array<MachineTaint>}
     * @memberof AwsMachinePoolCreate
     */
    'taints'?: Array<MachineTaint>;
    /**
     * Time (in secs) before a machine is considered unhealthy if it cannot be reached
     * @type {number}
     * @memberof AwsMachinePoolCreate
     */
    'unhealthyNodeTimeout'?: number;
    /**
     * 
     * @type {AwsMachineConfigCreate}
     * @memberof AwsMachinePoolCreate
     */
    'machineConfig'?: AwsMachineConfigCreate;
}
/**
 * 
 * @export
 * @interface AwsMachinePoolUpdate
 */
export interface AwsMachinePoolUpdate {
    /**
     * If true, assigns the Control Plane role to machines in this pool
     * @type {boolean}
     * @memberof AwsMachinePoolUpdate
     */
    'controlPlaneRole'?: boolean;
    /**
     * If true, assigns the etcd role to machines in this pool
     * @type {boolean}
     * @memberof AwsMachinePoolUpdate
     */
    'etcdRole'?: boolean;
    /**
     * If true, assigns the worker role to machines in this pool
     * @type {boolean}
     * @memberof AwsMachinePoolUpdate
     */
    'workerRole'?: boolean;
    /**
     * Labels to assign to machines in this pool
     * @type {{ [key: string]: string; }}
     * @memberof AwsMachinePoolUpdate
     */
    'labels'?: { [key: string]: string; };
    /**
     * Name of the machine pool, should be unique for a range
     * @type {string}
     * @memberof AwsMachinePoolUpdate
     */
    'name'?: string;
    /**
     * Number of machines in the pool
     * @type {number}
     * @memberof AwsMachinePoolUpdate
     */
    'quantity'?: number;
    /**
     * Taints to assign to machines in this pool
     * @type {Array<MachineTaint>}
     * @memberof AwsMachinePoolUpdate
     */
    'taints'?: Array<MachineTaint>;
    /**
     * Time (in secs) before a machine is considered unhealthy if it cannot be reached
     * @type {number}
     * @memberof AwsMachinePoolUpdate
     */
    'unhealthyNodeTimeout'?: number;
    /**
     * 
     * @type {AwsMachineConfigUpdate}
     * @memberof AwsMachinePoolUpdate
     */
    'machineConfig'?: AwsMachineConfigUpdate;
}
/**
 * 
 * @export
 * @interface BackgroundJob
 */
export interface BackgroundJob {
    /**
     * 
     * @type {string}
     * @memberof BackgroundJob
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof BackgroundJob
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof BackgroundJob
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof BackgroundJob
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof BackgroundJob
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof BackgroundJob
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof BackgroundJob
     */
    'metadata'?: object;
    /**
     * The job ID assigned by the queue.
     * @type {string}
     * @memberof BackgroundJob
     */
    'jobId'?: string;
    /**
     * The queue to which the job is assigned.
     * @type {string}
     * @memberof BackgroundJob
     */
    'jobQueue'?: string;
    /**
     * The number of times the job has been attempted.
     * @type {number}
     * @memberof BackgroundJob
     */
    'attempts'?: number;
    /**
     * The maximum number of times the job can be attempted.
     * @type {number}
     * @memberof BackgroundJob
     */
    'maxAttempts'?: number;
    /**
     * The latest state of the job.
     * @type {string}
     * @memberof BackgroundJob
     */
    'state'?: BackgroundJobStateEnum;
    /**
     * The history of the job.
     * @type {Array<BackgroundJobHistory>}
     * @memberof BackgroundJob
     */
    'history'?: Array<BackgroundJobHistory>;
}

export const BackgroundJobStateEnum = {
    Queued: 'Queued',
    Running: 'Running',
    Completed: 'Completed',
    Failed: 'Failed'
} as const;

export type BackgroundJobStateEnum = typeof BackgroundJobStateEnum[keyof typeof BackgroundJobStateEnum];

/**
 * 
 * @export
 * @interface BackgroundJobHistory
 */
export interface BackgroundJobHistory {
    /**
     * The status of the job at the time of the history entry.
     * @type {string}
     * @memberof BackgroundJobHistory
     */
    'status'?: BackgroundJobHistoryStatusEnum;
    /**
     * The message associated with the history entry.
     * @type {string}
     * @memberof BackgroundJobHistory
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof BackgroundJobHistory
     */
    'timestamp'?: string;
}

export const BackgroundJobHistoryStatusEnum = {
    Queued: 'Queued',
    Running: 'Running',
    Completed: 'Completed',
    Failed: 'Failed'
} as const;

export type BackgroundJobHistoryStatusEnum = typeof BackgroundJobHistoryStatusEnum[keyof typeof BackgroundJobHistoryStatusEnum];

/**
 * 
 * @export
 * @interface BackgroundJobsList200Response
 */
export interface BackgroundJobsList200Response {
    /**
     * 
     * @type {number}
     * @memberof BackgroundJobsList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof BackgroundJobsList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof BackgroundJobsList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof BackgroundJobsList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<BackgroundJob>}
     * @memberof BackgroundJobsList200Response
     */
    'data'?: Array<BackgroundJob>;
}
/**
 * 
 * @export
 * @interface BootDetails
 */
export interface BootDetails {
    /**
     * 
     * @type {Credentials}
     * @memberof BootDetails
     */
    'credentials'?: Credentials;
    /**
     * 
     * @type {Firmware}
     * @memberof BootDetails
     */
    'firmware'?: Firmware;
    /**
     * 
     * @type {Drivers}
     * @memberof BootDetails
     */
    'drivers'?: Drivers;
    /**
     * 
     * @type {Hardware}
     * @memberof BootDetails
     */
    'hardware'?: Hardware;
    /**
     * 
     * @type {Meta}
     * @memberof BootDetails
     */
    'meta'?: Meta;
    /**
     * VM machine type
     * @type {string}
     * @memberof BootDetails
     */
    'machineType'?: BootDetailsMachineTypeEnum;
    /**
     * 
     * @type {CloudInitConfig}
     * @memberof BootDetails
     */
    'cloudInit'?: CloudInitConfig | null;
}

export const BootDetailsMachineTypeEnum = {
    Q35: 'q35',
    Pc: 'pc'
} as const;

export type BootDetailsMachineTypeEnum = typeof BootDetailsMachineTypeEnum[keyof typeof BootDetailsMachineTypeEnum];

/**
 * 
 * @export
 * @interface BootDetailsCreate
 */
export interface BootDetailsCreate {
    /**
     * 
     * @type {Credentials}
     * @memberof BootDetailsCreate
     */
    'credentials': Credentials;
    /**
     * 
     * @type {Firmware}
     * @memberof BootDetailsCreate
     */
    'firmware': Firmware;
    /**
     * 
     * @type {Drivers}
     * @memberof BootDetailsCreate
     */
    'drivers': Drivers;
    /**
     * 
     * @type {Hardware}
     * @memberof BootDetailsCreate
     */
    'hardware': Hardware;
    /**
     * 
     * @type {Meta}
     * @memberof BootDetailsCreate
     */
    'meta': Meta;
    /**
     * VM machine type
     * @type {string}
     * @memberof BootDetailsCreate
     */
    'machineType'?: BootDetailsCreateMachineTypeEnum;
    /**
     * 
     * @type {CloudInitConfig}
     * @memberof BootDetailsCreate
     */
    'cloudInit'?: CloudInitConfig | null;
}

export const BootDetailsCreateMachineTypeEnum = {
    Q35: 'q35',
    Pc: 'pc'
} as const;

export type BootDetailsCreateMachineTypeEnum = typeof BootDetailsCreateMachineTypeEnum[keyof typeof BootDetailsCreateMachineTypeEnum];

/**
 * 
 * @export
 * @interface BootDetailsUpdate
 */
export interface BootDetailsUpdate {
    /**
     * 
     * @type {Credentials}
     * @memberof BootDetailsUpdate
     */
    'credentials'?: Credentials;
    /**
     * 
     * @type {Firmware}
     * @memberof BootDetailsUpdate
     */
    'firmware'?: Firmware;
    /**
     * 
     * @type {Drivers}
     * @memberof BootDetailsUpdate
     */
    'drivers'?: Drivers;
    /**
     * 
     * @type {Hardware}
     * @memberof BootDetailsUpdate
     */
    'hardware'?: Hardware;
    /**
     * 
     * @type {Meta}
     * @memberof BootDetailsUpdate
     */
    'meta'?: Meta;
    /**
     * VM machine type
     * @type {string}
     * @memberof BootDetailsUpdate
     */
    'machineType'?: BootDetailsUpdateMachineTypeEnum;
    /**
     * 
     * @type {CloudInitConfig}
     * @memberof BootDetailsUpdate
     */
    'cloudInit'?: CloudInitConfig | null;
}

export const BootDetailsUpdateMachineTypeEnum = {
    Q35: 'q35',
    Pc: 'pc'
} as const;

export type BootDetailsUpdateMachineTypeEnum = typeof BootDetailsUpdateMachineTypeEnum[keyof typeof BootDetailsUpdateMachineTypeEnum];

/**
 * 
 * @export
 * @interface BootImage
 */
export interface BootImage {
    /**
     * UUID of the VM Image to load onto the disk
     * @type {string}
     * @memberof BootImage
     */
    'imageID'?: string;
    /**
     * Quantity of requested storage space to be allocated
     * @type {string}
     * @memberof BootImage
     */
    'storage'?: string | null;
}
/**
 * 
 * @export
 * @interface BootImageCreate
 */
export interface BootImageCreate {
    /**
     * UUID of the VM Image to load onto the disk
     * @type {string}
     * @memberof BootImageCreate
     */
    'imageID': string;
    /**
     * Quantity of requested storage space to be allocated
     * @type {string}
     * @memberof BootImageCreate
     */
    'storage'?: string | null;
}
/**
 * 
 * @export
 * @interface BootImageOverride
 */
export interface BootImageOverride {
    /**
     * UUID of the VM Image to load onto the disk
     * @type {string}
     * @memberof BootImageOverride
     */
    'imageID'?: string;
    /**
     * Quantity of requested storage space to be allocated
     * @type {string}
     * @memberof BootImageOverride
     */
    'storage'?: string | null;
}
/**
 * 
 * @export
 * @interface BootImageUpdate
 */
export interface BootImageUpdate {
    /**
     * UUID of the VM Image to load onto the disk
     * @type {string}
     * @memberof BootImageUpdate
     */
    'imageID'?: string;
    /**
     * Quantity of requested storage space to be allocated
     * @type {string}
     * @memberof BootImageUpdate
     */
    'storage'?: string | null;
}
/**
 * 
 * @export
 * @interface BuildContent
 */
export interface BuildContent {
    /**
     * 
     * @type {File}
     * @memberof BuildContent
     */
    'file': File;
    /**
     * The name of the CMI5 course
     * @type {string}
     * @memberof BuildContent
     */
    'project': string;
    /**
     * Whether or not to create / update au mappings for a course
     * @type {boolean}
     * @memberof BuildContent
     */
    'createAuMappings': boolean;
}
/**
 * 
 * @export
 * @interface BuildURLs
 */
export interface BuildURLs {
    /**
     * 
     * @type {string}
     * @memberof BuildURLs
     */
    'docs'?: string;
    /**
     * 
     * @type {string}
     * @memberof BuildURLs
     */
    'grafana'?: string;
    /**
     * 
     * @type {string}
     * @memberof BuildURLs
     */
    'lms'?: string;
    /**
     * 
     * @type {string}
     * @memberof BuildURLs
     */
    'rancher'?: string;
    /**
     * 
     * @type {string}
     * @memberof BuildURLs
     */
    'swagger'?: string;
}
/**
 * 
 * @export
 * @interface BuildVersionInfo
 */
export interface BuildVersionInfo {
    /**
     * Build ID number
     * @type {number}
     * @memberof BuildVersionInfo
     */
    'buildId'?: number;
    /**
     * Git branch of the build
     * @type {string}
     * @memberof BuildVersionInfo
     */
    'gitBranch'?: string;
    /**
     * Git commit of the build
     * @type {string}
     * @memberof BuildVersionInfo
     */
    'gitCommit'?: string;
    /**
     * 
     * @type {BuildURLs}
     * @memberof BuildVersionInfo
     */
    'urls'?: BuildURLs;
}
/**
 * 
 * @export
 * @interface CPE
 */
export interface CPE {
    /**
     * 
     * @type {string}
     * @memberof CPE
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof CPE
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof CPE
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof CPE
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof CPE
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof CPE
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof CPE
     */
    'metadata'?: object;
    /**
     * Defines the language supported in the user interface of the product
     * @type {string}
     * @memberof CPE
     */
    'lang'?: string;
    /**
     * Any other general descriptive or identifying information which is vendor- or product-specific and which does not logically fit in any other attribute value
     * @type {string}
     * @memberof CPE
     */
    'other'?: string;
    /**
     * \'a\' for a class of applications, \'o\' for a class of operating systems, \'h\' for a class of hardware devices, \'*\' for any, \'-\' for not applicable
     * @type {string}
     * @memberof CPE
     */
    'part'?: CPEPartEnum;
    /**
     * Most common and recognizable title or name of the product
     * @type {string}
     * @memberof CPE
     */
    'product'?: string;
    /**
     * Characterizes how the product is tailored to a particular market or class of end users
     * @type {string}
     * @memberof CPE
     */
    'softwareEdition'?: string;
    /**
     * Characterizes the instruction set architecture (e.g., x86) on which the product operates
     * @type {string}
     * @memberof CPE
     */
    'targetHardware'?: string;
    /**
     * Characterizes the software computing environment within which the product operates
     * @type {string}
     * @memberof CPE
     */
    'targetSoftware'?: string;
    /**
     * Vendor-specific alphanumeric strings characterizing the particular update, service pack, or point release of the product
     * @type {string}
     * @memberof CPE
     */
    'update'?: string;
    /**
     * Person or organization that manufactured or created the product
     * @type {string}
     * @memberof CPE
     */
    'vendor'?: string;
    /**
     * Vendor-specific alphanumeric strings characterizing the particular release version of the product
     * @type {string}
     * @memberof CPE
     */
    'version'?: string;
    /**
     * CPE formatted string
     * @type {string}
     * @memberof CPE
     */
    'cpeFormat'?: string;
}

export const CPEPartEnum = {
    A: 'a',
    O: 'o',
    H: 'h',
    Star: '*',
    Minus: '-'
} as const;

export type CPEPartEnum = typeof CPEPartEnum[keyof typeof CPEPartEnum];

/**
 * 
 * @export
 * @interface CaptureApi
 */
export interface CaptureApi {
    /**
     * Only lowercase letters, numbers, and \'-\' are allowed
     * @type {string}
     * @memberof CaptureApi
     */
    'instanceID'?: string;
    /**
     * Unique capture name within the Traffic Tracker
     * @type {string}
     * @memberof CaptureApi
     */
    'captureName'?: string;
    /**
     * Description of the Capture
     * @type {string}
     * @memberof CaptureApi
     */
    'captureDescription'?: string | null;
    /**
     * Target Interface
     * @type {number}
     * @memberof CaptureApi
     */
    'targetInterface': number;
    /**
     * ID of VM Specification - one of vmSpecification or containerSpecification is required
     * @type {string}
     * @memberof CaptureApi
     */
    'vmSpecification'?: string | null;
    /**
     * ID of Container Specification - one of vmSpecification or containerSpecification is required
     * @type {string}
     * @memberof CaptureApi
     */
    'containerSpecification'?: string | null;
}
/**
 * 
 * @export
 * @interface CertificateSubject
 */
export interface CertificateSubject {
    /**
     * 
     * @type {string}
     * @memberof CertificateSubject
     */
    'c'?: string;
    /**
     * 
     * @type {string}
     * @memberof CertificateSubject
     */
    'l'?: string;
    /**
     * 
     * @type {string}
     * @memberof CertificateSubject
     */
    'o'?: string;
    /**
     * 
     * @type {string}
     * @memberof CertificateSubject
     */
    'oU'?: string;
    /**
     * 
     * @type {string}
     * @memberof CertificateSubject
     */
    'sT'?: string;
}
/**
 * Chart
 * @export
 * @interface Chart
 */
export interface Chart {
    /**
     * A user provided human readable name
     * @type {string}
     * @memberof Chart
     */
    'name'?: string;
    /**
     * List of available versions
     * @type {Array<ChartVersion>}
     * @memberof Chart
     */
    'versions'?: Array<ChartVersion>;
    /**
     * Changes the icon displayed in the UI
     * @type {string}
     * @memberof Chart
     */
    'iconType'?: ChartIconTypeEnum;
}

export const ChartIconTypeEnum = {
    FileServer: 'FileServer',
    Firewall: 'Firewall',
    Internet: 'Internet',
    Laptop: 'Laptop',
    MailServer: 'MailServer',
    Mobile: 'Mobile',
    Plc: 'PLC',
    Printer: 'Printer',
    Router: 'Router',
    Server: 'Server',
    Switch: 'Switch',
    WebProxy: 'WebProxy',
    WebServer: 'WebServer',
    WirelessAccessPoint: 'WirelessAccessPoint',
    Workstation: 'Workstation'
} as const;

export type ChartIconTypeEnum = typeof ChartIconTypeEnum[keyof typeof ChartIconTypeEnum];

/**
 * Chart
 * @export
 * @interface ChartCreate
 */
export interface ChartCreate {
    /**
     * Common Platform Enumeration - post provisioning actions
     * @type {string}
     * @memberof ChartCreate
     */
    'cpe': string;
    /**
     * The file to upload
     * @type {File}
     * @memberof ChartCreate
     */
    'file': File;
    /**
     * Changes the icon displayed in the UI
     * @type {string}
     * @memberof ChartCreate
     */
    'iconType': ChartCreateIconTypeEnum;
}

export const ChartCreateIconTypeEnum = {
    FileServer: 'FileServer',
    Firewall: 'Firewall',
    Internet: 'Internet',
    Laptop: 'Laptop',
    MailServer: 'MailServer',
    Mobile: 'Mobile',
    Plc: 'PLC',
    Printer: 'Printer',
    Router: 'Router',
    Server: 'Server',
    Switch: 'Switch',
    WebProxy: 'WebProxy',
    WebServer: 'WebServer',
    WirelessAccessPoint: 'WirelessAccessPoint',
    Workstation: 'Workstation'
} as const;

export type ChartCreateIconTypeEnum = typeof ChartCreateIconTypeEnum[keyof typeof ChartCreateIconTypeEnum];

/**
 * 
 * @export
 * @interface ChartVersion
 */
export interface ChartVersion {
    /**
     * 
     * @type {string}
     * @memberof ChartVersion
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof ChartVersion
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof ChartVersion
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof ChartVersion
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof ChartVersion
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof ChartVersion
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof ChartVersion
     */
    'metadata'?: object;
    /**
     * Version of the application contained in the chart
     * @type {string}
     * @memberof ChartVersion
     */
    'appVersion'?: string;
    /**
     * Common Platform Enumeration - post provisioning actions
     * @type {string}
     * @memberof ChartVersion
     */
    'cpe'?: string;
    /**
     * Digest of the chart archive
     * @type {string}
     * @memberof ChartVersion
     */
    'digest'?: string;
    /**
     * Changes the icon displayed in the UI
     * @type {string}
     * @memberof ChartVersion
     */
    'iconType'?: ChartVersionIconTypeEnum;
    /**
     * Version of the chart
     * @type {string}
     * @memberof ChartVersion
     */
    'version'?: string;
}

export const ChartVersionIconTypeEnum = {
    FileServer: 'FileServer',
    Firewall: 'Firewall',
    Internet: 'Internet',
    Laptop: 'Laptop',
    MailServer: 'MailServer',
    Mobile: 'Mobile',
    Plc: 'PLC',
    Printer: 'Printer',
    Router: 'Router',
    Server: 'Server',
    Switch: 'Switch',
    WebProxy: 'WebProxy',
    WebServer: 'WebServer',
    WirelessAccessPoint: 'WirelessAccessPoint',
    Workstation: 'Workstation'
} as const;

export type ChartVersionIconTypeEnum = typeof ChartVersionIconTypeEnum[keyof typeof ChartVersionIconTypeEnum];

/**
 * 
 * @export
 * @interface ChartVersionsList200Response
 */
export interface ChartVersionsList200Response {
    /**
     * 
     * @type {number}
     * @memberof ChartVersionsList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof ChartVersionsList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof ChartVersionsList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ChartVersionsList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<ChartVersion>}
     * @memberof ChartVersionsList200Response
     */
    'data'?: Array<ChartVersion>;
}
/**
 * 
 * @export
 * @interface ChartsList200Response
 */
export interface ChartsList200Response {
    /**
     * 
     * @type {number}
     * @memberof ChartsList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof ChartsList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof ChartsList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ChartsList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<Chart>}
     * @memberof ChartsList200Response
     */
    'data'?: Array<Chart>;
}
/**
 * 
 * @export
 * @interface CloudInit
 */
export interface CloudInit {
    /**
     * Contains NoCloud inline cloud-init userdata. Go text templates are supported but only deterministic template functions are available.
     * @type {string}
     * @memberof CloudInit
     */
    'userData'?: string;
    /**
     * Optional template parameters. Go text templates are supported in parameter values, and non-deterministic functions (ex. randAlpha) can be used. Keys are available as parameter data in the userData template.
     * @type {{ [key: string]: string; }}
     * @memberof CloudInit
     */
    'userDataParameters'?: { [key: string]: string; } | null;
}
/**
 * 
 * @export
 * @interface CloudInitConfig
 */
export interface CloudInitConfig {
    /**
     * 
     * @type {CloudInitDataSourceType}
     * @memberof CloudInitConfig
     */
    'dataSourceType'?: CloudInitDataSourceType | null;
    /**
     * Optional network config version, defaults to 2
     * @type {number}
     * @memberof CloudInitConfig
     */
    'networkConfigVersion'?: number | null;
}


/**
 * Optional data source type, defaults to nocloud
 * @export
 * @enum {string}
 */

export const CloudInitDataSourceType = {
    Nocloud: 'nocloud',
    Configdrive: 'configdrive'
} as const;

export type CloudInitDataSourceType = typeof CloudInitDataSourceType[keyof typeof CloudInitDataSourceType];


/**
 * 
 * @export
 * @interface ClusterRangeNetwork
 */
export interface ClusterRangeNetwork {
    /**
     * 
     * @type {string}
     * @memberof ClusterRangeNetwork
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof ClusterRangeNetwork
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof ClusterRangeNetwork
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof ClusterRangeNetwork
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof ClusterRangeNetwork
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof ClusterRangeNetwork
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof ClusterRangeNetwork
     */
    'metadata'?: object;
    /**
     * If true, the ClusterRangeNetwork will not be automatically cleaned up when no RangeNetworks reference it
     * @type {boolean}
     * @memberof ClusterRangeNetwork
     */
    'persist'?: boolean;
    /**
     * Optional labels that can used by InternetGateways. Keys must be valid qualified names no longer than 63 characters matching the regex /([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]/, with an optional RFC1123 DNS subdomain prefix no longer than 253 characters matching the regex /^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$/ followed by a \'/\'. Values must be match the regex /^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$/ and be no longer than 63 characters.
     * @type {{ [key: string]: string; }}
     * @memberof ClusterRangeNetwork
     */
    'labels'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface ClusterRangeNetworkCreate
 */
export interface ClusterRangeNetworkCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof ClusterRangeNetworkCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof ClusterRangeNetworkCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof ClusterRangeNetworkCreate
     */
    'metadata'?: object;
    /**
     * If true, the ClusterRangeNetwork will not be automatically cleaned up when no RangeNetworks reference it
     * @type {boolean}
     * @memberof ClusterRangeNetworkCreate
     */
    'persist'?: boolean;
    /**
     * Optional labels that can used by InternetGateways. Keys must be valid qualified names no longer than 63 characters matching the regex /([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]/, with an optional RFC1123 DNS subdomain prefix no longer than 253 characters matching the regex /^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$/ followed by a \'/\'. Values must be match the regex /^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$/ and be no longer than 63 characters.
     * @type {{ [key: string]: string; }}
     * @memberof ClusterRangeNetworkCreate
     */
    'labels'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface ClusterRangeNetworkUpdate
 */
export interface ClusterRangeNetworkUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof ClusterRangeNetworkUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof ClusterRangeNetworkUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof ClusterRangeNetworkUpdate
     */
    'metadata'?: object;
    /**
     * If true, the ClusterRangeNetwork will not be automatically cleaned up when no RangeNetworks reference it
     * @type {boolean}
     * @memberof ClusterRangeNetworkUpdate
     */
    'persist'?: boolean;
    /**
     * Optional labels that can used by InternetGateways. Keys must be valid qualified names no longer than 63 characters matching the regex /([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]/, with an optional RFC1123 DNS subdomain prefix no longer than 253 characters matching the regex /^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$/ followed by a \'/\'. Values must be match the regex /^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$/ and be no longer than 63 characters.
     * @type {{ [key: string]: string; }}
     * @memberof ClusterRangeNetworkUpdate
     */
    'labels'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface ClusterRangeNetworksList200Response
 */
export interface ClusterRangeNetworksList200Response {
    /**
     * 
     * @type {number}
     * @memberof ClusterRangeNetworksList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterRangeNetworksList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterRangeNetworksList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterRangeNetworksList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<ClusterRangeNetwork>}
     * @memberof ClusterRangeNetworksList200Response
     */
    'data'?: Array<ClusterRangeNetwork>;
}
/**
 * 
 * @export
 * @interface ClusterRangeNetworksListByRangeId200Response
 */
export interface ClusterRangeNetworksListByRangeId200Response {
    /**
     * 
     * @type {number}
     * @memberof ClusterRangeNetworksListByRangeId200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterRangeNetworksListByRangeId200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterRangeNetworksListByRangeId200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ClusterRangeNetworksListByRangeId200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<DeployedClusterRangeNetwork>}
     * @memberof ClusterRangeNetworksListByRangeId200Response
     */
    'data'?: Array<DeployedClusterRangeNetwork>;
}
/**
 * 
 * @export
 * @interface Cmi5AUMapping
 */
export interface Cmi5AUMapping {
    /**
     * The unique id of the au
     * @type {string}
     * @memberof Cmi5AUMapping
     */
    'auId': string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof Cmi5AUMapping
     */
    'author'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof Cmi5AUMapping
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof Cmi5AUMapping
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof Cmi5AUMapping
     */
    'name'?: string;
    /**
     * The scenarios associated with the au
     * @type {Array<string>}
     * @memberof Cmi5AUMapping
     */
    'scenarios': Array<string>;
}
/**
 * 
 * @export
 * @interface Cmi5AuMappingCreate
 */
export interface Cmi5AuMappingCreate {
    /**
     * The unique id of the au
     * @type {string}
     * @memberof Cmi5AuMappingCreate
     */
    'auId': string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof Cmi5AuMappingCreate
     */
    'name': string;
    /**
     * The scenarios associated with the au
     * @type {Array<string>}
     * @memberof Cmi5AuMappingCreate
     */
    'scenarios': Array<string>;
}
/**
 * 
 * @export
 * @interface Cmi5AuMappingList200Response
 */
export interface Cmi5AuMappingList200Response {
    /**
     * 
     * @type {number}
     * @memberof Cmi5AuMappingList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof Cmi5AuMappingList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof Cmi5AuMappingList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Cmi5AuMappingList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<Cmi5AUMapping>}
     * @memberof Cmi5AuMappingList200Response
     */
    'data'?: Array<Cmi5AUMapping>;
}
/**
 * 
 * @export
 * @interface Cmi5AuMappingUpdate
 */
export interface Cmi5AuMappingUpdate {
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof Cmi5AuMappingUpdate
     */
    'name'?: string;
    /**
     * The scenarios associated with the au
     * @type {Array<string>}
     * @memberof Cmi5AuMappingUpdate
     */
    'scenarios': Array<string>;
}
/**
 * 
 * @export
 * @interface Cmi5Class
 */
export interface Cmi5Class {
    /**
     * Name of the class
     * @type {string}
     * @memberof Cmi5Class
     */
    'name'?: string;
    /**
     * Range UUID of the class
     * @type {string}
     * @memberof Cmi5Class
     */
    'rangeId'?: string;
}
/**
 * 
 * @export
 * @interface Cmi5CourseRegistrationList200Response
 */
export interface Cmi5CourseRegistrationList200Response {
    /**
     * 
     * @type {number}
     * @memberof Cmi5CourseRegistrationList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof Cmi5CourseRegistrationList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof Cmi5CourseRegistrationList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Cmi5CourseRegistrationList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<Cmi5Registration>}
     * @memberof Cmi5CourseRegistrationList200Response
     */
    'data'?: Array<Cmi5Registration>;
}
/**
 * 
 * @export
 * @interface Cmi5Registration
 */
export interface Cmi5Registration {
    /**
     * The course registration ID
     * @type {string}
     * @memberof Cmi5Registration
     */
    'registrationId'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof Cmi5Registration
     */
    'author'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof Cmi5Registration
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof Cmi5Registration
     */
    'dateEdited'?: string;
    /**
     * A list of deployed scenario UUIDs
     * @type {Array<string>}
     * @memberof Cmi5Registration
     * @deprecated
     */
    'deployedScenarios'?: Array<string>;
    /**
     * A map of AU IDs/patterns to deployed scenario UUIDs
     * @type {{ [key: string]: string; }}
     * @memberof Cmi5Registration
     */
    'scenarios'?: { [key: string]: string; };
    /**
     * The id of the range this registration is associated with
     * @type {string}
     * @memberof Cmi5Registration
     */
    'rangeId'?: string;
    /**
     * The latest auth token associated with this registration
     * @type {string}
     * @memberof Cmi5Registration
     */
    'latestToken'?: string;
    /**
     * The CMI5 actor
     * @type {{ [key: string]: any; }}
     * @memberof Cmi5Registration
     */
    'actor'?: { [key: string]: any; };
    /**
     * The CMI5 endpoint
     * @type {string}
     * @memberof Cmi5Registration
     */
    'endpoint'?: string;
    /**
     * Activity ID
     * @type {string}
     * @memberof Cmi5Registration
     */
    'activityId'?: string;
}
/**
 * 
 * @export
 * @interface Cmi5RegistrationAu
 */
export interface Cmi5RegistrationAu {
    /**
     * 
     * @type {string}
     * @memberof Cmi5RegistrationAu
     */
    'rangeId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Cmi5RegistrationAu
     */
    'deployedScenarios'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Cmi5RegistrationAu
     */
    'classId'?: string;
}
/**
 * 
 * @export
 * @interface Conflict
 */
export interface Conflict {
    /**
     * The error name
     * @type {string}
     * @memberof Conflict
     */
    'name': string;
    /**
     * An error message
     * @type {string}
     * @memberof Conflict
     */
    'message': string;
    /**
     * The status code of the exception
     * @type {number}
     * @memberof Conflict
     */
    'status': number;
    /**
     * A list of related errors
     * @type {Array<GenericError>}
     * @memberof Conflict
     */
    'errors'?: Array<GenericError>;
    /**
     * The stack trace (only in development mode)
     * @type {string}
     * @memberof Conflict
     */
    'stack'?: string;
}
/**
 * Container
 * @export
 * @interface Container
 */
export interface Container {
    /**
     * Sets the name of the container within the system
     * @type {string}
     * @memberof Container
     */
    'name'?: string;
    /**
     * List of available versions
     * @type {Array<ContainerTag>}
     * @memberof Container
     */
    'tags'?: Array<ContainerTag>;
}
/**
 * Container
 * @export
 * @interface ContainerCreate
 */
export interface ContainerCreate {
    /**
     * The file to upload
     * @type {File}
     * @memberof ContainerCreate
     */
    'file': File;
    /**
     * Sets the name of the container within the system
     * @type {string}
     * @memberof ContainerCreate
     */
    'name'?: string;
    /**
     * Sets the tag of the container within the system
     * @type {string}
     * @memberof ContainerCreate
     */
    'tag': string;
}
/**
 * 
 * @export
 * @interface ContainerInterface
 */
export interface ContainerInterface {
    /**
     * Optional MAC address, if not provided one will be randomly generated.      NOTE: Containers currently only support MAC addresses with the private prefix of \"0A:58\".
     * @type {string}
     * @memberof ContainerInterface
     */
    'macAddress'?: string | null;
    /**
     * Optional unique identifier, only used with advanced networking
     * @type {string}
     * @memberof ContainerInterface
     */
    'id'?: string;
    /**
     * Optional interface name
     * @type {string}
     * @memberof ContainerInterface
     */
    'interfaceName'?: string;
    /**
     * Optional list of network ports to mirror to this interface
     * @type {Array<MirrorPort>}
     * @memberof ContainerInterface
     */
    'mirrorPorts'?: Array<MirrorPort>;
    /**
     * Optional ID of a range network, if not provided the default network will be used
     * @type {string}
     * @memberof ContainerInterface
     */
    'rangeNetwork'?: string | null;
    /**
     * Optional ID of a range host network, only one of rangeIP, rangeAutoIP, rangeNetwork, or rangeHostNetwork should be provided
     * @type {string}
     * @memberof ContainerInterface
     */
    'rangeHostNetwork'?: string | null;
    /**
     * Optional ID of a range IP, only one of rangeIP, rangeAutoIP, rangeNetwork, or rangeHostNetwork should be provided
     * @type {string}
     * @memberof ContainerInterface
     */
    'rangeIP'?: string | null;
    /**
     * Optional ID of a range auto IP, only one of rangeIP, rangeAutoIP, rangeNetwork, or rangeHostNetwork should be provided
     * @type {string}
     * @memberof ContainerInterface
     */
    'rangeAutoIP'?: string | null;
    /**
     * Optional name of the Range IP that is injected into the container helm values
     * @type {string}
     * @memberof ContainerInterface
     */
    'rangeIPName'?: string | null;
    /**
     * If true, the default gateway of the associated Range IP will be attached to this interface
     * @type {boolean}
     * @memberof ContainerInterface
     */
    'defaultGateway'?: boolean;
}
/**
 * 
 * @export
 * @interface ContainerInterfaceCreate
 */
export interface ContainerInterfaceCreate {
    /**
     * Optional MAC address, if not provided one will be randomly generated.      NOTE: Containers currently only support MAC addresses with the private prefix of \"0A:58\".
     * @type {string}
     * @memberof ContainerInterfaceCreate
     */
    'macAddress'?: string | null;
    /**
     * Optional unique identifier, only used with advanced networking
     * @type {string}
     * @memberof ContainerInterfaceCreate
     */
    'id'?: string;
    /**
     * Optional interface name
     * @type {string}
     * @memberof ContainerInterfaceCreate
     */
    'interfaceName'?: string;
    /**
     * Optional list of network ports to mirror to this interface
     * @type {Array<MirrorPort>}
     * @memberof ContainerInterfaceCreate
     */
    'mirrorPorts'?: Array<MirrorPort>;
    /**
     * Optional ID of a range network, if not provided the default network will be used
     * @type {string}
     * @memberof ContainerInterfaceCreate
     */
    'rangeNetwork'?: string | null;
    /**
     * Optional ID of a range host network, only one of rangeIP, rangeAutoIP, rangeNetwork, or rangeHostNetwork should be provided
     * @type {string}
     * @memberof ContainerInterfaceCreate
     */
    'rangeHostNetwork'?: string | null;
    /**
     * Optional ID of a range IP, only one of rangeIP, rangeAutoIP, rangeNetwork, or rangeHostNetwork should be provided
     * @type {string}
     * @memberof ContainerInterfaceCreate
     */
    'rangeIP'?: string | null;
    /**
     * Optional ID of a range auto IP, only one of rangeIP, rangeAutoIP, rangeNetwork, or rangeHostNetwork should be provided
     * @type {string}
     * @memberof ContainerInterfaceCreate
     */
    'rangeAutoIP'?: string | null;
    /**
     * Optional name of the Range IP that is injected into the container helm values
     * @type {string}
     * @memberof ContainerInterfaceCreate
     */
    'rangeIPName'?: string | null;
    /**
     * If true, the default gateway of the associated Range IP will be attached to this interface
     * @type {boolean}
     * @memberof ContainerInterfaceCreate
     */
    'defaultGateway'?: boolean;
}
/**
 * 
 * @export
 * @interface ContainerInterfaceUpdate
 */
export interface ContainerInterfaceUpdate {
    /**
     * Optional MAC address, if not provided one will be randomly generated.      NOTE: Containers currently only support MAC addresses with the private prefix of \"0A:58\".
     * @type {string}
     * @memberof ContainerInterfaceUpdate
     */
    'macAddress'?: string | null;
    /**
     * Optional unique identifier, only used with advanced networking
     * @type {string}
     * @memberof ContainerInterfaceUpdate
     */
    'id'?: string;
    /**
     * Optional interface name
     * @type {string}
     * @memberof ContainerInterfaceUpdate
     */
    'interfaceName'?: string;
    /**
     * Optional list of network ports to mirror to this interface
     * @type {Array<MirrorPort>}
     * @memberof ContainerInterfaceUpdate
     */
    'mirrorPorts'?: Array<MirrorPort>;
    /**
     * Optional ID of a range network, if not provided the default network will be used
     * @type {string}
     * @memberof ContainerInterfaceUpdate
     */
    'rangeNetwork'?: string | null;
    /**
     * Optional ID of a range host network, only one of rangeIP, rangeAutoIP, rangeNetwork, or rangeHostNetwork should be provided
     * @type {string}
     * @memberof ContainerInterfaceUpdate
     */
    'rangeHostNetwork'?: string | null;
    /**
     * Optional ID of a range IP, only one of rangeIP, rangeAutoIP, rangeNetwork, or rangeHostNetwork should be provided
     * @type {string}
     * @memberof ContainerInterfaceUpdate
     */
    'rangeIP'?: string | null;
    /**
     * Optional ID of a range auto IP, only one of rangeIP, rangeAutoIP, rangeNetwork, or rangeHostNetwork should be provided
     * @type {string}
     * @memberof ContainerInterfaceUpdate
     */
    'rangeAutoIP'?: string | null;
    /**
     * Optional name of the Range IP that is injected into the container helm values
     * @type {string}
     * @memberof ContainerInterfaceUpdate
     */
    'rangeIPName'?: string | null;
    /**
     * If true, the default gateway of the associated Range IP will be attached to this interface
     * @type {boolean}
     * @memberof ContainerInterfaceUpdate
     */
    'defaultGateway'?: boolean;
}
/**
 * 
 * @export
 * @interface ContainerSpecification
 */
export interface ContainerSpecification {
    /**
     * 
     * @type {string}
     * @memberof ContainerSpecification
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof ContainerSpecification
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof ContainerSpecification
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof ContainerSpecification
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof ContainerSpecification
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof ContainerSpecification
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof ContainerSpecification
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof ContainerSpecification
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * The name of an existing chart.
     * @type {string}
     * @memberof ContainerSpecification
     */
    'chart'?: string;
    /**
     * Version of the chart.
     * @type {string}
     * @memberof ContainerSpecification
     */
    'chartVersion'?: string;
    /**
     * Values to use with the chart. Must validate against the chart version schema.
     * @type {object}
     * @memberof ContainerSpecification
     */
    'values'?: object;
    /**
     * Optional templated parameters to use with the chart. Go text templates are supported in values, and non-deterministic functions (ex. randAlpha) can be used. This can be used to inject random data at runtime or provide simple overridable chart values, for example.
     * @type {{ [key: string]: string; }}
     * @memberof ContainerSpecification
     */
    'parameters'?: { [key: string]: string; } | null;
    /**
     * Advanced networking mode allows network interfaces to be assigned to specific pods in the associated chart.
     * @type {boolean}
     * @memberof ContainerSpecification
     */
    'advancedNetworking'?: boolean;
    /**
     * Whether the control network NIC is enabled. At least 1 interface is required if false
     * @type {boolean}
     * @memberof ContainerSpecification
     */
    'controlNetNicEnabled'?: boolean;
    /**
     * Display icon for the chart
     * @type {string}
     * @memberof ContainerSpecification
     */
    'iconType'?: ContainerSpecificationIconTypeEnum;
    /**
     * Optional mapping of range certificates names and IDs
     * @type {{ [key: string]: string; }}
     * @memberof ContainerSpecification
     */
    'rangeCerts'?: { [key: string]: string; };
    /**
     * Optional mapping of DNS record names of range DNS record IDs
     * @type {{ [key: string]: string; }}
     * @memberof ContainerSpecification
     */
    'rangeDNSRecords'?: { [key: string]: string; };
    /**
     * Ordered list of interfaces to attach to the container
     * @type {Array<ContainerInterface>}
     * @memberof ContainerSpecification
     */
    'interfaces'?: Array<ContainerInterface>;
    /**
     * Optional mapping of volume name of range volume IDs
     * @type {{ [key: string]: string; }}
     * @memberof ContainerSpecification
     */
    'rangeVolumes'?: { [key: string]: string; };
}

export const ContainerSpecificationIconTypeEnum = {
    FileServer: 'FileServer',
    Firewall: 'Firewall',
    Internet: 'Internet',
    Laptop: 'Laptop',
    MailServer: 'MailServer',
    Mobile: 'Mobile',
    Plc: 'PLC',
    Printer: 'Printer',
    Router: 'Router',
    Server: 'Server',
    Switch: 'Switch',
    WebProxy: 'WebProxy',
    WebServer: 'WebServer',
    WirelessAccessPoint: 'WirelessAccessPoint',
    Workstation: 'Workstation'
} as const;

export type ContainerSpecificationIconTypeEnum = typeof ContainerSpecificationIconTypeEnum[keyof typeof ContainerSpecificationIconTypeEnum];

/**
 * 
 * @export
 * @interface ContainerSpecificationCreate
 */
export interface ContainerSpecificationCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof ContainerSpecificationCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof ContainerSpecificationCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof ContainerSpecificationCreate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof ContainerSpecificationCreate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * The name of an existing chart.
     * @type {string}
     * @memberof ContainerSpecificationCreate
     */
    'chart': string;
    /**
     * Version of the chart.
     * @type {string}
     * @memberof ContainerSpecificationCreate
     */
    'chartVersion': string;
    /**
     * Values to use with the chart. Must validate against the chart version schema.
     * @type {object}
     * @memberof ContainerSpecificationCreate
     */
    'values': object;
    /**
     * Optional templated parameters to use with the chart. Go text templates are supported in values, and non-deterministic functions (ex. randAlpha) can be used. This can be used to inject random data at runtime or provide simple overridable chart values, for example.
     * @type {{ [key: string]: string; }}
     * @memberof ContainerSpecificationCreate
     */
    'parameters'?: { [key: string]: string; } | null;
    /**
     * Advanced networking mode allows network interfaces to be assigned to specific pods in the associated chart.
     * @type {boolean}
     * @memberof ContainerSpecificationCreate
     */
    'advancedNetworking'?: boolean;
    /**
     * Whether the control network NIC is enabled. At least 1 interface is required if false
     * @type {boolean}
     * @memberof ContainerSpecificationCreate
     */
    'controlNetNicEnabled'?: boolean;
    /**
     * Optional mapping of range certificates names and IDs
     * @type {{ [key: string]: string; }}
     * @memberof ContainerSpecificationCreate
     */
    'rangeCerts'?: { [key: string]: string; };
    /**
     * Optional mapping of DNS record names of range DNS record IDs
     * @type {{ [key: string]: string; }}
     * @memberof ContainerSpecificationCreate
     */
    'rangeDNSRecords'?: { [key: string]: string; };
    /**
     * Ordered list of interfaces to attach to the container
     * @type {Array<ContainerInterfaceCreate>}
     * @memberof ContainerSpecificationCreate
     */
    'interfaces'?: Array<ContainerInterfaceCreate>;
    /**
     * Optional mapping of volume name of range volume IDs
     * @type {{ [key: string]: string; }}
     * @memberof ContainerSpecificationCreate
     */
    'rangeVolumes'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface ContainerSpecificationOverride
 */
export interface ContainerSpecificationOverride {
    /**
     * User provided metadata
     * @type {object}
     * @memberof ContainerSpecificationOverride
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof ContainerSpecificationOverride
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * The name of an existing chart.
     * @type {string}
     * @memberof ContainerSpecificationOverride
     */
    'chart'?: string;
    /**
     * Version of the chart.
     * @type {string}
     * @memberof ContainerSpecificationOverride
     */
    'chartVersion'?: string;
    /**
     * Values to use with the chart. Must validate against the chart version schema.
     * @type {object}
     * @memberof ContainerSpecificationOverride
     */
    'values'?: object;
    /**
     * Optional templated parameters to use with the chart. Go text templates are supported in values, and non-deterministic functions (ex. randAlpha) can be used. This can be used to inject random data at runtime or provide simple overridable chart values, for example.
     * @type {{ [key: string]: string; }}
     * @memberof ContainerSpecificationOverride
     */
    'parameters'?: { [key: string]: string; } | null;
    /**
     * Advanced networking mode allows network interfaces to be assigned to specific pods in the associated chart.
     * @type {boolean}
     * @memberof ContainerSpecificationOverride
     */
    'advancedNetworking'?: boolean;
    /**
     * Whether the control network NIC is enabled. At least 1 interface is required if false
     * @type {boolean}
     * @memberof ContainerSpecificationOverride
     */
    'controlNetNicEnabled'?: boolean;
}
/**
 * 
 * @export
 * @interface ContainerSpecificationUpdate
 */
export interface ContainerSpecificationUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof ContainerSpecificationUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof ContainerSpecificationUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof ContainerSpecificationUpdate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof ContainerSpecificationUpdate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * The name of an existing chart.
     * @type {string}
     * @memberof ContainerSpecificationUpdate
     */
    'chart'?: string;
    /**
     * Version of the chart.
     * @type {string}
     * @memberof ContainerSpecificationUpdate
     */
    'chartVersion'?: string;
    /**
     * Values to use with the chart. Must validate against the chart version schema.
     * @type {object}
     * @memberof ContainerSpecificationUpdate
     */
    'values'?: object;
    /**
     * Optional templated parameters to use with the chart. Go text templates are supported in values, and non-deterministic functions (ex. randAlpha) can be used. This can be used to inject random data at runtime or provide simple overridable chart values, for example.
     * @type {{ [key: string]: string; }}
     * @memberof ContainerSpecificationUpdate
     */
    'parameters'?: { [key: string]: string; } | null;
    /**
     * Advanced networking mode allows network interfaces to be assigned to specific pods in the associated chart.
     * @type {boolean}
     * @memberof ContainerSpecificationUpdate
     */
    'advancedNetworking'?: boolean;
    /**
     * Whether the control network NIC is enabled. At least 1 interface is required if false
     * @type {boolean}
     * @memberof ContainerSpecificationUpdate
     */
    'controlNetNicEnabled'?: boolean;
    /**
     * Optional mapping of range certificates names and IDs
     * @type {{ [key: string]: string; }}
     * @memberof ContainerSpecificationUpdate
     */
    'rangeCerts'?: { [key: string]: string; };
    /**
     * Optional mapping of DNS record names of range DNS record IDs
     * @type {{ [key: string]: string; }}
     * @memberof ContainerSpecificationUpdate
     */
    'rangeDNSRecords'?: { [key: string]: string; };
    /**
     * Ordered list of interfaces to attach to the container
     * @type {Array<ContainerInterfaceUpdate>}
     * @memberof ContainerSpecificationUpdate
     */
    'interfaces'?: Array<ContainerInterfaceUpdate>;
    /**
     * Optional mapping of volume name of range volume IDs
     * @type {{ [key: string]: string; }}
     * @memberof ContainerSpecificationUpdate
     */
    'rangeVolumes'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface ContainerSpecificationsList200Response
 */
export interface ContainerSpecificationsList200Response {
    /**
     * 
     * @type {number}
     * @memberof ContainerSpecificationsList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof ContainerSpecificationsList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof ContainerSpecificationsList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ContainerSpecificationsList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<ContainerSpecification>}
     * @memberof ContainerSpecificationsList200Response
     */
    'data'?: Array<ContainerSpecification>;
}
/**
 * Container
 * @export
 * @interface ContainerTag
 */
export interface ContainerTag {
    /**
     * Container name
     * @type {string}
     * @memberof ContainerTag
     */
    'name'?: string;
    /**
     * Container tag
     * @type {string}
     * @memberof ContainerTag
     */
    'tag'?: string;
}
/**
 * 
 * @export
 * @interface ContainersList200Response
 */
export interface ContainersList200Response {
    /**
     * 
     * @type {number}
     * @memberof ContainersList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof ContainersList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof ContainersList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ContainersList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<Container>}
     * @memberof ContainersList200Response
     */
    'data'?: Array<Container>;
}
/**
 * Country Codes
 * @export
 * @interface CountryCodes
 */
export interface CountryCodes {
    /**
     * Country Codes JSON
     * @type {object}
     * @memberof CountryCodes
     */
    'countryCodes'?: object;
}
/**
 * 
 * @export
 * @interface CourseContent
 */
export interface CourseContent {
    /**
     * 
     * @type {File}
     * @memberof CourseContent
     */
    'file': File;
    /**
     * The name of the CMI5 course
     * @type {string}
     * @memberof CourseContent
     */
    'project': string;
}
/**
 * 
 * @export
 * @interface CourseMapping
 */
export interface CourseMapping {
    /**
     * 
     * @type {string}
     * @memberof CourseMapping
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof CourseMapping
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof CourseMapping
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof CourseMapping
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof CourseMapping
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof CourseMapping
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof CourseMapping
     */
    'metadata'?: object;
    /**
     * Course Id
     * @type {string}
     * @memberof CourseMapping
     */
    'courseId'?: string;
    /**
     * Scenario Id
     * @type {string}
     * @memberof CourseMapping
     */
    'scenarioId'?: string;
}
/**
 * 
 * @export
 * @interface CourseMappingCreate
 */
export interface CourseMappingCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof CourseMappingCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof CourseMappingCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof CourseMappingCreate
     */
    'metadata'?: object;
    /**
     * Course Id
     * @type {string}
     * @memberof CourseMappingCreate
     */
    'courseId': string;
    /**
     * Scenario Id
     * @type {string}
     * @memberof CourseMappingCreate
     */
    'scenarioId': string;
}
/**
 * 
 * @export
 * @interface CourseMappingList200Response
 */
export interface CourseMappingList200Response {
    /**
     * 
     * @type {number}
     * @memberof CourseMappingList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof CourseMappingList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof CourseMappingList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof CourseMappingList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<CourseMapping>}
     * @memberof CourseMappingList200Response
     */
    'data'?: Array<CourseMapping>;
}
/**
 * 
 * @export
 * @interface CourseMappingUpdate
 */
export interface CourseMappingUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof CourseMappingUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof CourseMappingUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof CourseMappingUpdate
     */
    'metadata'?: object;
    /**
     * Course Id
     * @type {string}
     * @memberof CourseMappingUpdate
     */
    'courseId'?: string;
    /**
     * Scenario Id
     * @type {string}
     * @memberof CourseMappingUpdate
     */
    'scenarioId'?: string;
}
/**
 * 
 * @export
 * @interface CoursesGrantRequest
 */
export interface CoursesGrantRequest {
    /**
     * 
     * @type {string}
     * @memberof CoursesGrantRequest
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface CpeCreate
 */
export interface CpeCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof CpeCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof CpeCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof CpeCreate
     */
    'metadata'?: object;
    /**
     * Defines the language supported in the user interface of the product
     * @type {string}
     * @memberof CpeCreate
     */
    'lang'?: string;
    /**
     * Any other general descriptive or identifying information which is vendor- or product-specific and which does not logically fit in any other attribute value
     * @type {string}
     * @memberof CpeCreate
     */
    'other'?: string;
    /**
     * \'a\' for a class of applications, \'o\' for a class of operating systems, \'h\' for a class of hardware devices, \'*\' for any, \'-\' for not applicable
     * @type {string}
     * @memberof CpeCreate
     */
    'part'?: CpeCreatePartEnum;
    /**
     * Most common and recognizable title or name of the product
     * @type {string}
     * @memberof CpeCreate
     */
    'product'?: string;
    /**
     * Characterizes how the product is tailored to a particular market or class of end users
     * @type {string}
     * @memberof CpeCreate
     */
    'softwareEdition'?: string;
    /**
     * Characterizes the instruction set architecture (e.g., x86) on which the product operates
     * @type {string}
     * @memberof CpeCreate
     */
    'targetHardware'?: string;
    /**
     * Characterizes the software computing environment within which the product operates
     * @type {string}
     * @memberof CpeCreate
     */
    'targetSoftware'?: string;
    /**
     * Vendor-specific alphanumeric strings characterizing the particular update, service pack, or point release of the product
     * @type {string}
     * @memberof CpeCreate
     */
    'update'?: string;
    /**
     * Person or organization that manufactured or created the product
     * @type {string}
     * @memberof CpeCreate
     */
    'vendor'?: string;
    /**
     * Vendor-specific alphanumeric strings characterizing the particular release version of the product
     * @type {string}
     * @memberof CpeCreate
     */
    'version'?: string;
}

export const CpeCreatePartEnum = {
    A: 'a',
    O: 'o',
    H: 'h',
    Star: '*',
    Minus: '-'
} as const;

export type CpeCreatePartEnum = typeof CpeCreatePartEnum[keyof typeof CpeCreatePartEnum];

/**
 * 
 * @export
 * @interface CpeList200Response
 */
export interface CpeList200Response {
    /**
     * 
     * @type {number}
     * @memberof CpeList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof CpeList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof CpeList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof CpeList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<CPE>}
     * @memberof CpeList200Response
     */
    'data'?: Array<CPE>;
}
/**
 * 
 * @export
 * @interface CpeUpdate
 */
export interface CpeUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof CpeUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof CpeUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof CpeUpdate
     */
    'metadata'?: object;
    /**
     * Defines the language supported in the user interface of the product
     * @type {string}
     * @memberof CpeUpdate
     */
    'lang'?: string;
    /**
     * Any other general descriptive or identifying information which is vendor- or product-specific and which does not logically fit in any other attribute value
     * @type {string}
     * @memberof CpeUpdate
     */
    'other'?: string;
    /**
     * \'a\' for a class of applications, \'o\' for a class of operating systems, \'h\' for a class of hardware devices, \'*\' for any, \'-\' for not applicable
     * @type {string}
     * @memberof CpeUpdate
     */
    'part'?: CpeUpdatePartEnum;
    /**
     * Most common and recognizable title or name of the product
     * @type {string}
     * @memberof CpeUpdate
     */
    'product'?: string;
    /**
     * Characterizes how the product is tailored to a particular market or class of end users
     * @type {string}
     * @memberof CpeUpdate
     */
    'softwareEdition'?: string;
    /**
     * Characterizes the instruction set architecture (e.g., x86) on which the product operates
     * @type {string}
     * @memberof CpeUpdate
     */
    'targetHardware'?: string;
    /**
     * Characterizes the software computing environment within which the product operates
     * @type {string}
     * @memberof CpeUpdate
     */
    'targetSoftware'?: string;
    /**
     * Vendor-specific alphanumeric strings characterizing the particular update, service pack, or point release of the product
     * @type {string}
     * @memberof CpeUpdate
     */
    'update'?: string;
    /**
     * Person or organization that manufactured or created the product
     * @type {string}
     * @memberof CpeUpdate
     */
    'vendor'?: string;
    /**
     * Vendor-specific alphanumeric strings characterizing the particular release version of the product
     * @type {string}
     * @memberof CpeUpdate
     */
    'version'?: string;
}

export const CpeUpdatePartEnum = {
    A: 'a',
    O: 'o',
    H: 'h',
    Star: '*',
    Minus: '-'
} as const;

export type CpeUpdatePartEnum = typeof CpeUpdatePartEnum[keyof typeof CpeUpdatePartEnum];

/**
 * 
 * @export
 * @interface Credentials
 */
export interface Credentials {
    /**
     * Local administrator username
     * @type {string}
     * @memberof Credentials
     */
    'adminUsername'?: string;
    /**
     * Local administrator password
     * @type {string}
     * @memberof Credentials
     */
    'adminPassword'?: string;
}
/**
 * 
 * @export
 * @interface DHCPConfig
 */
export interface DHCPConfig {
    /**
     * IP address of a DHCP server associated with this network
     * @type {string}
     * @memberof DHCPConfig
     */
    'dhcpServer': string;
    /**
     * Optional DNS server IP addresses
     * @type {Array<string>}
     * @memberof DHCPConfig
     */
    'dnsServers'?: Array<string>;
    /**
     * Optional static reservations of MAC addresses to IP addresses
     * @type {{ [key: string]: string; }}
     * @memberof DHCPConfig
     */
    'staticReservations'?: { [key: string]: string; };
    /**
     * Optional DHCP pool ranges
     * @type {Array<DHCPPool>}
     * @memberof DHCPConfig
     */
    'pools'?: Array<DHCPPool>;
}
/**
 * 
 * @export
 * @interface DHCPPool
 */
export interface DHCPPool {
    /**
     * IP address at the beginning of the DHCP pool range
     * @type {string}
     * @memberof DHCPPool
     */
    'start': string;
    /**
     * IP address at the end of the DHCP pool range
     * @type {string}
     * @memberof DHCPPool
     */
    'end': string;
}
/**
 * 
 * @export
 * @interface DeployedAnsiblePlaybook
 */
export interface DeployedAnsiblePlaybook {
    /**
     * 
     * @type {string}
     * @memberof DeployedAnsiblePlaybook
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof DeployedAnsiblePlaybook
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof DeployedAnsiblePlaybook
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof DeployedAnsiblePlaybook
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof DeployedAnsiblePlaybook
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof DeployedAnsiblePlaybook
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof DeployedAnsiblePlaybook
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof DeployedAnsiblePlaybook
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Array of Parent Playbook UUIDs
     * @type {Array<string>}
     * @memberof DeployedAnsiblePlaybook
     */
    'parentPlaybooks'?: Array<string>;
    /**
     * Array of Provisioning Service Module Details
     * @type {Array<AnsibleRoleDetails>}
     * @memberof DeployedAnsiblePlaybook
     */
    'roleDetails'?: Array<AnsibleRoleDetails>;
    /**
     * ID of VM Specification - one of vmSpecification or containerSpecification is required
     * @type {string}
     * @memberof DeployedAnsiblePlaybook
     */
    'vmSpecification'?: string | null;
    /**
     * ID of Container Specification - one of vmSpecification or containerSpecification is required
     * @type {string}
     * @memberof DeployedAnsiblePlaybook
     */
    'containerSpecification'?: string | null;
    /**
     * Indicates whether RangeAnsiblePlaybook requires elevated privileges to execute
     * @type {boolean}
     * @memberof DeployedAnsiblePlaybook
     */
    'requiresElevatedPrivileges'?: boolean;
    /**
     * Indicates whether RangeAnsiblePlaybook is ready
     * @type {boolean}
     * @memberof DeployedAnsiblePlaybook
     */
    'ready'?: boolean;
    /**
     * Provisioning Service Composite\'s Status
     * @type {string}
     * @memberof DeployedAnsiblePlaybook
     */
    'status'?: string;
    /**
     * A human readable status message of the Ansible Playbook
     * @type {string}
     * @memberof DeployedAnsiblePlaybook
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface DeployedClusterRangeNetwork
 */
export interface DeployedClusterRangeNetwork {
    /**
     * 
     * @type {string}
     * @memberof DeployedClusterRangeNetwork
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof DeployedClusterRangeNetwork
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof DeployedClusterRangeNetwork
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof DeployedClusterRangeNetwork
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof DeployedClusterRangeNetwork
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof DeployedClusterRangeNetwork
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof DeployedClusterRangeNetwork
     */
    'metadata'?: object;
    /**
     * If true, the ClusterRangeNetwork will not be automatically cleaned up when no RangeNetworks reference it
     * @type {boolean}
     * @memberof DeployedClusterRangeNetwork
     */
    'persist'?: boolean;
    /**
     * Optional labels that can used by InternetGateways. Keys must be valid qualified names no longer than 63 characters matching the regex /([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]/, with an optional RFC1123 DNS subdomain prefix no longer than 253 characters matching the regex /^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$/ followed by a \'/\'. Values must be match the regex /^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$/ and be no longer than 63 characters.
     * @type {{ [key: string]: string; }}
     * @memberof DeployedClusterRangeNetwork
     */
    'labels'?: { [key: string]: string; };
    /**
     * Status of the cluster range network
     * @type {string}
     * @memberof DeployedClusterRangeNetwork
     */
    'status'?: string;
    /**
     * Human readable message when an error occurs
     * @type {string}
     * @memberof DeployedClusterRangeNetwork
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface DeployedEventNode
 */
export interface DeployedEventNode {
    /**
     * 
     * @type {string}
     * @memberof DeployedEventNode
     */
    'uuid'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof DeployedEventNode
     */
    'name'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof DeployedEventNode
     */
    'description'?: string;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<string>}
     * @memberof DeployedEventNode
     */
    'scenarioGroups'?: Array<DeployedEventNodeScenarioGroupsEnum>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeployedEventNode
     */
    'packages'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeployedEventNode
     */
    'subEvents'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof DeployedEventNode
     */
    'status'?: DeployedEventNodeStatusEnum;
    /**
     * Status message
     * @type {string}
     * @memberof DeployedEventNode
     */
    'message'?: string;
}

export const DeployedEventNodeScenarioGroupsEnum = {
    BlueCell: 'blueCell',
    RedCell: 'redCell',
    WhiteCell: 'whiteCell',
    ScenarioAdmin: 'scenarioAdmin'
} as const;

export type DeployedEventNodeScenarioGroupsEnum = typeof DeployedEventNodeScenarioGroupsEnum[keyof typeof DeployedEventNodeScenarioGroupsEnum];
export const DeployedEventNodeStatusEnum = {
    Unknown: 'Unknown',
    Ready: 'Ready',
    NotReady: 'NotReady',
    Creating: 'Creating',
    Error: 'Error',
    Deleting: 'Deleting',
    Stopped: 'Stopped'
} as const;

export type DeployedEventNodeStatusEnum = typeof DeployedEventNodeStatusEnum[keyof typeof DeployedEventNodeStatusEnum];

/**
 * 
 * @export
 * @interface DeployedEventsList200Response
 */
export interface DeployedEventsList200Response {
    /**
     * 
     * @type {number}
     * @memberof DeployedEventsList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedEventsList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedEventsList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedEventsList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<DeployedEventNode>}
     * @memberof DeployedEventsList200Response
     */
    'data'?: Array<DeployedEventNode>;
}
/**
 * 
 * @export
 * @interface DeployedGhostAgent
 */
export interface DeployedGhostAgent {
    /**
     * 
     * @type {string}
     * @memberof DeployedGhostAgent
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof DeployedGhostAgent
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof DeployedGhostAgent
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof DeployedGhostAgent
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof DeployedGhostAgent
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof DeployedGhostAgent
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof DeployedGhostAgent
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof DeployedGhostAgent
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * User that the ghost agent will run as
     * @type {string}
     * @memberof DeployedGhostAgent
     */
    'ghostUser'?: string;
    /**
     * Password of the user that the ghost agent will run as
     * @type {string}
     * @memberof DeployedGhostAgent
     */
    'ghostPassword'?: string;
    /**
     * Array of Parent Playbook UUIDs
     * @type {Array<string>}
     * @memberof DeployedGhostAgent
     */
    'parentPlaybooks'?: Array<string>;
    /**
     * Optional GhostC2Server, if not specified runtime control of the client is not possible
     * @type {string}
     * @memberof DeployedGhostAgent
     */
    'c2Server'?: string | null;
    /**
     * Optional traffic profile to execute on startup
     * @type {string}
     * @memberof DeployedGhostAgent
     */
    'profile'?: string | null;
    /**
     * The target Range VM
     * @type {string}
     * @memberof DeployedGhostAgent
     */
    'vmSpecification'?: string;
    /**
     * Provisioning Service Module is ready
     * @type {boolean}
     * @memberof DeployedGhostAgent
     */
    'ready'?: boolean;
    /**
     * Status of the ghost agent
     * @type {string}
     * @memberof DeployedGhostAgent
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface DeployedGhostAgentsList200Response
 */
export interface DeployedGhostAgentsList200Response {
    /**
     * 
     * @type {number}
     * @memberof DeployedGhostAgentsList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedGhostAgentsList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedGhostAgentsList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedGhostAgentsList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<DeployedGhostAgent>}
     * @memberof DeployedGhostAgentsList200Response
     */
    'data'?: Array<DeployedGhostAgent>;
}
/**
 * 
 * @export
 * @interface DeployedGhostC2Server
 */
export interface DeployedGhostC2Server {
    /**
     * 
     * @type {string}
     * @memberof DeployedGhostC2Server
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof DeployedGhostC2Server
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof DeployedGhostC2Server
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof DeployedGhostC2Server
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof DeployedGhostC2Server
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof DeployedGhostC2Server
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof DeployedGhostC2Server
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof DeployedGhostC2Server
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Hostname of the C2 server - must be unique in a scenario
     * @type {string}
     * @memberof DeployedGhostC2Server
     */
    'hostname'?: string;
    /**
     * Optional size of Ghost database
     * @type {string}
     * @memberof DeployedGhostC2Server
     */
    'storage'?: string;
    /**
     * Status of the Ghost C2 Server
     * @type {string}
     * @memberof DeployedGhostC2Server
     */
    'status'?: DeployedGhostC2ServerStatusEnum;
    /**
     * Optional status message
     * @type {string}
     * @memberof DeployedGhostC2Server
     */
    'message'?: string;
}

export const DeployedGhostC2ServerStatusEnum = {
    Unknown: 'Unknown',
    Ready: 'Ready',
    NotReady: 'NotReady',
    Creating: 'Creating',
    Error: 'Error',
    Deleting: 'Deleting',
    Stopped: 'Stopped'
} as const;

export type DeployedGhostC2ServerStatusEnum = typeof DeployedGhostC2ServerStatusEnum[keyof typeof DeployedGhostC2ServerStatusEnum];

/**
 * 
 * @export
 * @interface DeployedGhostC2ServersList200Response
 */
export interface DeployedGhostC2ServersList200Response {
    /**
     * 
     * @type {number}
     * @memberof DeployedGhostC2ServersList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedGhostC2ServersList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedGhostC2ServersList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedGhostC2ServersList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<DeployedGhostC2Server>}
     * @memberof DeployedGhostC2ServersList200Response
     */
    'data'?: Array<DeployedGhostC2Server>;
}
/**
 * 
 * @export
 * @interface DeployedGhostClient
 */
export interface DeployedGhostClient {
    /**
     * 
     * @type {string}
     * @memberof DeployedGhostClient
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof DeployedGhostClient
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof DeployedGhostClient
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof DeployedGhostClient
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof DeployedGhostClient
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof DeployedGhostClient
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof DeployedGhostClient
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof DeployedGhostClient
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Optional list of DNS nameserver IPs
     * @type {Array<string>}
     * @memberof DeployedGhostClient
     */
    'nameservers'?: Array<string>;
    /**
     * Optional GhostC2Server, if not specified runtime control of the client is not possible
     * @type {string}
     * @memberof DeployedGhostClient
     */
    'c2Server'?: string | null;
    /**
     * IP address of this client on the network - one of rangeIP or rangeAutoIP is required
     * @type {string}
     * @memberof DeployedGhostClient
     */
    'rangeIP'?: string | null;
    /**
     * IP address of this client on the network - one of rangeIP or rangeAutoIP is required
     * @type {string}
     * @memberof DeployedGhostClient
     */
    'rangeAutoIP'?: string | null;
    /**
     * Optional traffic profile to execute on startup
     * @type {string}
     * @memberof DeployedGhostClient
     */
    'profile'?: string | null;
}
/**
 * 
 * @export
 * @interface DeployedGhostClientsList200Response
 */
export interface DeployedGhostClientsList200Response {
    /**
     * 
     * @type {number}
     * @memberof DeployedGhostClientsList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedGhostClientsList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedGhostClientsList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedGhostClientsList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<DeployedGhostClient>}
     * @memberof DeployedGhostClientsList200Response
     */
    'data'?: Array<DeployedGhostClient>;
}
/**
 * 
 * @export
 * @interface DeployedGhostMachinesList200Response
 */
export interface DeployedGhostMachinesList200Response {
    /**
     * 
     * @type {number}
     * @memberof DeployedGhostMachinesList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedGhostMachinesList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedGhostMachinesList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedGhostMachinesList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<GhostMachine>}
     * @memberof DeployedGhostMachinesList200Response
     */
    'data'?: Array<GhostMachine>;
}
/**
 * 
 * @export
 * @interface DeployedGhostMachinesPublishTrafficProfileRequest
 */
export interface DeployedGhostMachinesPublishTrafficProfileRequest {
    /**
     * 
     * @type {string}
     * @memberof DeployedGhostMachinesPublishTrafficProfileRequest
     */
    'ghostTrafficProfileId': string;
}
/**
 * 
 * @export
 * @interface DeployedGhostTrafficProfile
 */
export interface DeployedGhostTrafficProfile {
    /**
     * 
     * @type {string}
     * @memberof DeployedGhostTrafficProfile
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof DeployedGhostTrafficProfile
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof DeployedGhostTrafficProfile
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof DeployedGhostTrafficProfile
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof DeployedGhostTrafficProfile
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof DeployedGhostTrafficProfile
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof DeployedGhostTrafficProfile
     */
    'metadata'?: object;
    /**
     * Array of Ghost Traffic Details
     * @type {Array<GhostTrafficDetails>}
     * @memberof DeployedGhostTrafficProfile
     */
    'trafficDetails'?: Array<GhostTrafficDetails>;
    /**
     * Generated Ghost timeline
     * @type {string}
     * @memberof DeployedGhostTrafficProfile
     */
    'timeline'?: string;
}
/**
 * 
 * @export
 * @interface DeployedGhostTrafficProfilesList200Response
 */
export interface DeployedGhostTrafficProfilesList200Response {
    /**
     * 
     * @type {number}
     * @memberof DeployedGhostTrafficProfilesList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedGhostTrafficProfilesList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedGhostTrafficProfilesList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedGhostTrafficProfilesList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<DeployedGhostTrafficProfile>}
     * @memberof DeployedGhostTrafficProfilesList200Response
     */
    'data'?: Array<DeployedGhostTrafficProfile>;
}
/**
 * 
 * @export
 * @interface DeployedInternetGateway
 */
export interface DeployedInternetGateway {
    /**
     * 
     * @type {string}
     * @memberof DeployedInternetGateway
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof DeployedInternetGateway
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof DeployedInternetGateway
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof DeployedInternetGateway
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof DeployedInternetGateway
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof DeployedInternetGateway
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof DeployedInternetGateway
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof DeployedInternetGateway
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Labels used to select a ClusterRangeNetwork. Keys must be valid qualified names no longer than 63 characters matching the regex /([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]/, with an optional RFC1123 DNS subdomain prefix no longer than 253 characters matching the regex /^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$/ followed by a \'/\'. Values must be match the regex /^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$/ and be no longer than 63 characters.
     * @type {{ [key: string]: string; }}
     * @memberof DeployedInternetGateway
     */
    'labels'?: { [key: string]: string; };
    /**
     * IP address of the internet gateway on the network
     * @type {string}
     * @memberof DeployedInternetGateway
     */
    'rangeIP'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeployedInternetGateway
     */
    'status'?: DeployedInternetGatewayStatusEnum;
    /**
     * Status message
     * @type {string}
     * @memberof DeployedInternetGateway
     */
    'message'?: string;
}

export const DeployedInternetGatewayStatusEnum = {
    Unknown: 'Unknown',
    Ready: 'Ready',
    NotReady: 'NotReady',
    Creating: 'Creating',
    Error: 'Error',
    Deleting: 'Deleting',
    Stopped: 'Stopped'
} as const;

export type DeployedInternetGatewayStatusEnum = typeof DeployedInternetGatewayStatusEnum[keyof typeof DeployedInternetGatewayStatusEnum];

/**
 * 
 * @export
 * @interface DeployedInternetGatewaysList200Response
 */
export interface DeployedInternetGatewaysList200Response {
    /**
     * 
     * @type {number}
     * @memberof DeployedInternetGatewaysList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedInternetGatewaysList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedInternetGatewaysList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedInternetGatewaysList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<DeployedInternetGateway>}
     * @memberof DeployedInternetGatewaysList200Response
     */
    'data'?: Array<DeployedInternetGateway>;
}
/**
 * 
 * @export
 * @interface DeployedMirrorPort
 */
export interface DeployedMirrorPort {
    /**
     * Zero-based index of the associated VM or container interface to mirror
     * @type {number}
     * @memberof DeployedMirrorPort
     */
    'interfaceIndex': number;
    /**
     * ID of the VM specification to mirror to the associated network interface
     * @type {string}
     * @memberof DeployedMirrorPort
     */
    'vmSpecification'?: string;
    /**
     * ID of the container specification to mirror to the associated network interface
     * @type {string}
     * @memberof DeployedMirrorPort
     */
    'containerSpecification'?: string;
}
/**
 * 
 * @export
 * @interface DeployedPackageDetail
 */
export interface DeployedPackageDetail {
    /**
     * 
     * @type {string}
     * @memberof DeployedPackageDetail
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof DeployedPackageDetail
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof DeployedPackageDetail
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof DeployedPackageDetail
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof DeployedPackageDetail
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof DeployedPackageDetail
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof DeployedPackageDetail
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof DeployedPackageDetail
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Status of the package
     * @type {string}
     * @memberof DeployedPackageDetail
     */
    'status'?: DeployedPackageDetailStatusEnum;
    /**
     * Status message
     * @type {string}
     * @memberof DeployedPackageDetail
     */
    'message'?: string;
}

export const DeployedPackageDetailStatusEnum = {
    Unknown: 'Unknown',
    Ready: 'Ready',
    NotReady: 'NotReady',
    Creating: 'Creating',
    Error: 'Error',
    Deleting: 'Deleting',
    Stopped: 'Stopped'
} as const;

export type DeployedPackageDetailStatusEnum = typeof DeployedPackageDetailStatusEnum[keyof typeof DeployedPackageDetailStatusEnum];

/**
 * 
 * @export
 * @interface DeployedPackagesList200Response
 */
export interface DeployedPackagesList200Response {
    /**
     * 
     * @type {number}
     * @memberof DeployedPackagesList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedPackagesList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedPackagesList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedPackagesList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<DeployedPackageDetail>}
     * @memberof DeployedPackagesList200Response
     */
    'data'?: Array<DeployedPackageDetail>;
}
/**
 * 
 * @export
 * @interface DeployedRangeAnsiblePlaybooksList200Response
 */
export interface DeployedRangeAnsiblePlaybooksList200Response {
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeAnsiblePlaybooksList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeAnsiblePlaybooksList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeAnsiblePlaybooksList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeAnsiblePlaybooksList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<DeployedAnsiblePlaybook>}
     * @memberof DeployedRangeAnsiblePlaybooksList200Response
     */
    'data'?: Array<DeployedAnsiblePlaybook>;
}
/**
 * 
 * @export
 * @interface DeployedRangeAutoIP
 */
export interface DeployedRangeAutoIP {
    /**
     * 
     * @type {string}
     * @memberof DeployedRangeAutoIP
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof DeployedRangeAutoIP
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof DeployedRangeAutoIP
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof DeployedRangeAutoIP
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof DeployedRangeAutoIP
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof DeployedRangeAutoIP
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof DeployedRangeAutoIP
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof DeployedRangeAutoIP
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * The IP address
     * @type {string}
     * @memberof DeployedRangeAutoIP
     */
    'address'?: string | null;
    /**
     * Latitude
     * @type {string}
     * @memberof DeployedRangeAutoIP
     */
    'latitude'?: string | null;
    /**
     * Longitude
     * @type {string}
     * @memberof DeployedRangeAutoIP
     */
    'longitude'?: string | null;
    /**
     * The ISO 3166 country code
     * @type {string}
     * @memberof DeployedRangeAutoIP
     */
    'countryCode'?: string | null;
    /**
     * Network CIDR Address
     * @type {string}
     * @memberof DeployedRangeAutoIP
     */
    'cidr'?: string;
    /**
     * Indicates whether the Range Auto IP is ready or not
     * @type {boolean}
     * @memberof DeployedRangeAutoIP
     */
    'ready'?: boolean;
    /**
     * Deployed Range Auto IP status
     * @type {string}
     * @memberof DeployedRangeAutoIP
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface DeployedRangeAutoIPsList200Response
 */
export interface DeployedRangeAutoIPsList200Response {
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeAutoIPsList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeAutoIPsList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeAutoIPsList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeAutoIPsList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<DeployedRangeAutoIP>}
     * @memberof DeployedRangeAutoIPsList200Response
     */
    'data'?: Array<DeployedRangeAutoIP>;
}
/**
 * 
 * @export
 * @interface DeployedRangeAutoL3Network
 */
export interface DeployedRangeAutoL3Network {
    /**
     * 
     * @type {string}
     * @memberof DeployedRangeAutoL3Network
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof DeployedRangeAutoL3Network
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof DeployedRangeAutoL3Network
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof DeployedRangeAutoL3Network
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof DeployedRangeAutoL3Network
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof DeployedRangeAutoL3Network
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof DeployedRangeAutoL3Network
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof DeployedRangeAutoL3Network
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Network CIDR Address
     * @type {string}
     * @memberof DeployedRangeAutoL3Network
     */
    'cidr'?: string;
    /**
     * Latitude
     * @type {string}
     * @memberof DeployedRangeAutoL3Network
     */
    'latitude'?: string;
    /**
     * Longitude
     * @type {string}
     * @memberof DeployedRangeAutoL3Network
     */
    'longitude'?: string;
    /**
     * Network Default Gateway
     * @type {string}
     * @memberof DeployedRangeAutoL3Network
     */
    'defaultGateway'?: string | null;
    /**
     * The calculated IP version from the CIDR
     * @type {number}
     * @memberof DeployedRangeAutoL3Network
     */
    'ipVersion'?: number | null;
    /**
     * The name of the RangeRouter that is closest to this network
     * @type {string}
     * @memberof DeployedRangeAutoL3Network
     */
    'nearestRangeRouter'?: string;
    /**
     * The range network from the service interface of the nearest RangeRouter
     * @type {string}
     * @memberof DeployedRangeAutoL3Network
     */
    'rangeNetwork'?: string;
    /**
     * The calculated prefix length from the CIDR
     * @type {number}
     * @memberof DeployedRangeAutoL3Network
     */
    'prefixLength'?: number | null;
}
/**
 * 
 * @export
 * @interface DeployedRangeAutoL3NetworksList200Response
 */
export interface DeployedRangeAutoL3NetworksList200Response {
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeAutoL3NetworksList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeAutoL3NetworksList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeAutoL3NetworksList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeAutoL3NetworksList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<DeployedRangeAutoL3Network>}
     * @memberof DeployedRangeAutoL3NetworksList200Response
     */
    'data'?: Array<DeployedRangeAutoL3Network>;
}
/**
 * 
 * @export
 * @interface DeployedRangeBGP
 */
export interface DeployedRangeBGP {
    /**
     * 
     * @type {string}
     * @memberof DeployedRangeBGP
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof DeployedRangeBGP
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof DeployedRangeBGP
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof DeployedRangeBGP
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof DeployedRangeBGP
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof DeployedRangeBGP
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof DeployedRangeBGP
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof DeployedRangeBGP
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * The Autonomous System Number for this BGP Network
     * @type {number}
     * @memberof DeployedRangeBGP
     */
    'asn'?: number;
    /**
     * Range routers that belong to this ASN
     * @type {Array<string>}
     * @memberof DeployedRangeBGP
     */
    'rangeRouters'?: Array<string>;
}
/**
 * 
 * @export
 * @interface DeployedRangeBGPLink
 */
export interface DeployedRangeBGPLink {
    /**
     * 
     * @type {string}
     * @memberof DeployedRangeBGPLink
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof DeployedRangeBGPLink
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof DeployedRangeBGPLink
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof DeployedRangeBGPLink
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof DeployedRangeBGPLink
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof DeployedRangeBGPLink
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof DeployedRangeBGPLink
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof DeployedRangeBGPLink
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * ASN of node 1
     * @type {number}
     * @memberof DeployedRangeBGPLink
     */
    'node1ASN'?: number;
    /**
     * ASN of node 2
     * @type {number}
     * @memberof DeployedRangeBGPLink
     */
    'node2ASN'?: number;
    /**
     * One of the endpoints of the BGP link
     * @type {string}
     * @memberof DeployedRangeBGPLink
     */
    'node1'?: string;
    /**
     * One of the endpoints of the BGP link
     * @type {string}
     * @memberof DeployedRangeBGPLink
     */
    'node2'?: string;
}
/**
 * 
 * @export
 * @interface DeployedRangeBgPsList200Response
 */
export interface DeployedRangeBgPsList200Response {
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeBgPsList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeBgPsList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeBgPsList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeBgPsList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<DeployedRangeBGP>}
     * @memberof DeployedRangeBgPsList200Response
     */
    'data'?: Array<DeployedRangeBGP>;
}
/**
 * 
 * @export
 * @interface DeployedRangeBgpLinksList200Response
 */
export interface DeployedRangeBgpLinksList200Response {
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeBgpLinksList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeBgpLinksList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeBgpLinksList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeBgpLinksList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<DeployedRangeBGPLink>}
     * @memberof DeployedRangeBgpLinksList200Response
     */
    'data'?: Array<DeployedRangeBGPLink>;
}
/**
 * 
 * @export
 * @interface DeployedRangeCert
 */
export interface DeployedRangeCert {
    /**
     * 
     * @type {string}
     * @memberof DeployedRangeCert
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof DeployedRangeCert
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof DeployedRangeCert
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof DeployedRangeCert
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof DeployedRangeCert
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof DeployedRangeCert
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof DeployedRangeCert
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof DeployedRangeCert
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * the common name (CN) for the certificate subject in the requested CSR
     * @type {string}
     * @memberof DeployedRangeCert
     */
    'cn'?: string;
    /**
     * 
     * @type {DeployedRangeCertKey}
     * @memberof DeployedRangeCert
     */
    'key'?: DeployedRangeCertKey | null;
    /**
     * the list of subject alternative names for the requested CSR
     * @type {Array<string>}
     * @memberof DeployedRangeCert
     */
    'hosts'?: Array<string>;
    /**
     * the certificate subject for the requested CSR
     * @type {Array<CertificateSubject>}
     * @memberof DeployedRangeCert
     */
    'certSubjects'?: Array<CertificateSubject>;
    /**
     * the signing profile for the signer
     * @type {string}
     * @memberof DeployedRangeCert
     */
    'profile'?: string;
    /**
     * The UUID of the PKI server to request the certificate from
     * @type {string}
     * @memberof DeployedRangeCert
     */
    'rangePki'?: string;
    /**
     * Indicates whether the range certificate is ready or not
     * @type {boolean}
     * @memberof DeployedRangeCert
     */
    'ready'?: boolean;
    /**
     * Deployed range certificate status
     * @type {string}
     * @memberof DeployedRangeCert
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface DeployedRangeCertKey
 */
export interface DeployedRangeCertKey {
    /**
     * The key algorithm for the newly generated private key, if non-default value provided then the key size must be provided as well
     * @type {string}
     * @memberof DeployedRangeCertKey
     */
    'algo': DeployedRangeCertKeyAlgoEnum;
    /**
     * The key size for the newly generated private key - For rsa: Accepts exact sizes [2048, 4096, 8192] - For ecdsa: Accepts exact sizes [256, 384, 521] - For ed25519: Accepts exact size [256]
     * @type {number}
     * @memberof DeployedRangeCertKey
     */
    'size': number;
}

export const DeployedRangeCertKeyAlgoEnum = {
    Rsa: 'rsa',
    Ecdsa: 'ecdsa',
    Ed25519: 'ed25519'
} as const;

export type DeployedRangeCertKeyAlgoEnum = typeof DeployedRangeCertKeyAlgoEnum[keyof typeof DeployedRangeCertKeyAlgoEnum];

/**
 * 
 * @export
 * @interface DeployedRangeCertificatesList200Response
 */
export interface DeployedRangeCertificatesList200Response {
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeCertificatesList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeCertificatesList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeCertificatesList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeCertificatesList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<DeployedRangeCert>}
     * @memberof DeployedRangeCertificatesList200Response
     */
    'data'?: Array<DeployedRangeCert>;
}
/**
 * 
 * @export
 * @interface DeployedRangeConsole
 */
export interface DeployedRangeConsole {
    /**
     * 
     * @type {string}
     * @memberof DeployedRangeConsole
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof DeployedRangeConsole
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof DeployedRangeConsole
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof DeployedRangeConsole
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof DeployedRangeConsole
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof DeployedRangeConsole
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof DeployedRangeConsole
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof DeployedRangeConsole
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Console protocol
     * @type {string}
     * @memberof DeployedRangeConsole
     */
    'protocol'?: DeployedRangeConsoleProtocolEnum;
    /**
     * 
     * @type {GuacamoleConnectionParameters}
     * @memberof DeployedRangeConsole
     */
    'parameters'?: GuacamoleConnectionParameters | null;
    /**
     * Range VM to access - only one of rangeVM or rangeContainer is specified
     * @type {string}
     * @memberof DeployedRangeConsole
     */
    'rangeVM'?: string | null;
    /**
     * Range container to access - only one of rangeVM or rangeContainer is specified
     * @type {string}
     * @memberof DeployedRangeConsole
     */
    'rangeContainer'?: string | null;
    /**
     * The console URL
     * @type {string}
     * @memberof DeployedRangeConsole
     */
    'url'?: string | null;
    /**
     * Fully qualified domain name for the guacamole service
     * @type {string}
     * @memberof DeployedRangeConsole
     */
    'domain'?: string | null;
    /**
     * Status of the range console
     * @type {string}
     * @memberof DeployedRangeConsole
     */
    'status'?: DeployedRangeConsoleStatusEnum;
    /**
     * Set when an error has occurred
     * @type {string}
     * @memberof DeployedRangeConsole
     */
    'message'?: string;
    /**
     * 
     * @type {GuacamoleConnectionDetails}
     * @memberof DeployedRangeConsole
     */
    'details'?: GuacamoleConnectionDetails;
}

export const DeployedRangeConsoleProtocolEnum = {
    Rdp: 'rdp',
    Vnc: 'vnc',
    Ssh: 'ssh',
    Telnet: 'telnet',
    Hypervisor: 'hypervisor',
    Kubernetes: 'kubernetes'
} as const;

export type DeployedRangeConsoleProtocolEnum = typeof DeployedRangeConsoleProtocolEnum[keyof typeof DeployedRangeConsoleProtocolEnum];
export const DeployedRangeConsoleStatusEnum = {
    Unknown: 'Unknown',
    Ready: 'Ready',
    NotReady: 'NotReady',
    Creating: 'Creating',
    Error: 'Error',
    Deleting: 'Deleting',
    Stopped: 'Stopped'
} as const;

export type DeployedRangeConsoleStatusEnum = typeof DeployedRangeConsoleStatusEnum[keyof typeof DeployedRangeConsoleStatusEnum];

/**
 * 
 * @export
 * @interface DeployedRangeConsolesList200Response
 */
export interface DeployedRangeConsolesList200Response {
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeConsolesList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeConsolesList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeConsolesList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeConsolesList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<DeployedRangeConsole>}
     * @memberof DeployedRangeConsolesList200Response
     */
    'data'?: Array<DeployedRangeConsole>;
}
/**
 * 
 * @export
 * @interface DeployedRangeDNSRecord
 */
export interface DeployedRangeDNSRecord {
    /**
     * 
     * @type {string}
     * @memberof DeployedRangeDNSRecord
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof DeployedRangeDNSRecord
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof DeployedRangeDNSRecord
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof DeployedRangeDNSRecord
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof DeployedRangeDNSRecord
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof DeployedRangeDNSRecord
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof DeployedRangeDNSRecord
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof DeployedRangeDNSRecord
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Class of the record
     * @type {string}
     * @memberof DeployedRangeDNSRecord
     */
    'recordClass'?: string;
    /**
     * The time to live of the record
     * @type {number}
     * @memberof DeployedRangeDNSRecord
     */
    'ttl'?: number;
    /**
     * The type of record
     * @type {string}
     * @memberof DeployedRangeDNSRecord
     */
    'type'?: string;
    /**
     * The data for the record
     * @type {string}
     * @memberof DeployedRangeDNSRecord
     */
    'data'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeployedRangeDNSRecord
     */
    'zone'?: string;
    /**
     * Indicates whether the range DNS record is ready or not
     * @type {boolean}
     * @memberof DeployedRangeDNSRecord
     */
    'ready'?: boolean;
    /**
     * Deployed range DNS record status
     * @type {string}
     * @memberof DeployedRangeDNSRecord
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface DeployedRangeDNSServer
 */
export interface DeployedRangeDNSServer {
    /**
     * 
     * @type {string}
     * @memberof DeployedRangeDNSServer
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof DeployedRangeDNSServer
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof DeployedRangeDNSServer
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof DeployedRangeDNSServer
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof DeployedRangeDNSServer
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof DeployedRangeDNSServer
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof DeployedRangeDNSServer
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof DeployedRangeDNSServer
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * 
     * @type {string}
     * @memberof DeployedRangeDNSServer
     */
    'type'?: DeployedRangeDNSServerTypeEnum;
    /**
     * Array of tags that zones can match against
     * @type {Array<string>}
     * @memberof DeployedRangeDNSServer
     */
    'tags'?: Array<string>;
    /**
     * Mapping of IP name to range IP IDs
     * @type {object}
     * @memberof DeployedRangeDNSServer
     */
    'rangeIPs'?: object;
    /**
     * Indicates whether the range DNS server is ready or not
     * @type {boolean}
     * @memberof DeployedRangeDNSServer
     */
    'ready'?: boolean;
    /**
     * Deployed range DNS zone status
     * @type {string}
     * @memberof DeployedRangeDNSServer
     */
    'status'?: string;
}

export const DeployedRangeDNSServerTypeEnum = {
    Authoritative: 'authoritative',
    Root: 'root',
    Recursive: 'recursive'
} as const;

export type DeployedRangeDNSServerTypeEnum = typeof DeployedRangeDNSServerTypeEnum[keyof typeof DeployedRangeDNSServerTypeEnum];

/**
 * 
 * @export
 * @interface DeployedRangeDNSZone
 */
export interface DeployedRangeDNSZone {
    /**
     * 
     * @type {string}
     * @memberof DeployedRangeDNSZone
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof DeployedRangeDNSZone
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof DeployedRangeDNSZone
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof DeployedRangeDNSZone
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof DeployedRangeDNSZone
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof DeployedRangeDNSZone
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof DeployedRangeDNSZone
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof DeployedRangeDNSZone
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Time to Live for records in the zone
     * @type {number}
     * @memberof DeployedRangeDNSZone
     */
    'ttl'?: number;
    /**
     * Primary Master Nameserver for the zone
     * @type {string}
     * @memberof DeployedRangeDNSZone
     */
    'masterNs'?: string;
    /**
     * Email address of administrator for the zone
     * @type {string}
     * @memberof DeployedRangeDNSZone
     */
    'email'?: string;
    /**
     * Serial number for the zone
     * @type {number}
     * @memberof DeployedRangeDNSZone
     */
    'serial'?: number;
    /**
     * Number of seconds after which secondary nameservers should query the master to detect zone changes
     * @type {number}
     * @memberof DeployedRangeDNSZone
     */
    'refresh'?: number;
    /**
     * Number of seconds after which secondary nameservers should retry request if master doesn\'t respond
     * @type {number}
     * @memberof DeployedRangeDNSZone
     */
    'retry'?: number;
    /**
     * Number of seconds after which secondary nameservers should stop answering request for the zone if master doesn\'t respond
     * @type {number}
     * @memberof DeployedRangeDNSZone
     */
    'expire'?: number;
    /**
     * Minimum TTL for resolvers
     * @type {number}
     * @memberof DeployedRangeDNSZone
     */
    'minimumTTL'?: number;
    /**
     * DNS servers matching one or more of the given tags will use this zone
     * @type {Array<string>}
     * @memberof DeployedRangeDNSZone
     */
    'tagSelectors'?: Array<string>;
    /**
     * Indicates whether the range DNS zone is ready or not
     * @type {boolean}
     * @memberof DeployedRangeDNSZone
     */
    'ready'?: boolean;
    /**
     * Deployed range DNS zone status
     * @type {string}
     * @memberof DeployedRangeDNSZone
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface DeployedRangeDnsRecordsList200Response
 */
export interface DeployedRangeDnsRecordsList200Response {
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeDnsRecordsList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeDnsRecordsList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeDnsRecordsList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeDnsRecordsList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<DeployedRangeDNSRecord>}
     * @memberof DeployedRangeDnsRecordsList200Response
     */
    'data'?: Array<DeployedRangeDNSRecord>;
}
/**
 * 
 * @export
 * @interface DeployedRangeDnsServersList200Response
 */
export interface DeployedRangeDnsServersList200Response {
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeDnsServersList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeDnsServersList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeDnsServersList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeDnsServersList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<DeployedRangeDNSServer>}
     * @memberof DeployedRangeDnsServersList200Response
     */
    'data'?: Array<DeployedRangeDNSServer>;
}
/**
 * 
 * @export
 * @interface DeployedRangeDnsZonesList200Response
 */
export interface DeployedRangeDnsZonesList200Response {
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeDnsZonesList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeDnsZonesList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeDnsZonesList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeDnsZonesList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<DeployedRangeDNSZone>}
     * @memberof DeployedRangeDnsZonesList200Response
     */
    'data'?: Array<DeployedRangeDNSZone>;
}
/**
 * 
 * @export
 * @interface DeployedRangeHostNetwork
 */
export interface DeployedRangeHostNetwork {
    /**
     * 
     * @type {string}
     * @memberof DeployedRangeHostNetwork
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof DeployedRangeHostNetwork
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof DeployedRangeHostNetwork
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof DeployedRangeHostNetwork
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof DeployedRangeHostNetwork
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof DeployedRangeHostNetwork
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof DeployedRangeHostNetwork
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof DeployedRangeHostNetwork
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Unique and memorable device identifier representing a hardware network device that is directly connected to this network
     * @type {string}
     * @memberof DeployedRangeHostNetwork
     */
    'deviceId'?: string;
}
/**
 * 
 * @export
 * @interface DeployedRangeHostNetworksList200Response
 */
export interface DeployedRangeHostNetworksList200Response {
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeHostNetworksList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeHostNetworksList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeHostNetworksList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeHostNetworksList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<DeployedRangeHostNetwork>}
     * @memberof DeployedRangeHostNetworksList200Response
     */
    'data'?: Array<DeployedRangeHostNetwork>;
}
/**
 * 
 * @export
 * @interface DeployedRangeIP
 */
export interface DeployedRangeIP {
    /**
     * 
     * @type {string}
     * @memberof DeployedRangeIP
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof DeployedRangeIP
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof DeployedRangeIP
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof DeployedRangeIP
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof DeployedRangeIP
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof DeployedRangeIP
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof DeployedRangeIP
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof DeployedRangeIP
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * IP address
     * @type {string}
     * @memberof DeployedRangeIP
     */
    'address'?: string | null;
    /**
     * Country Code
     * @type {string}
     * @memberof DeployedRangeIP
     */
    'countryCode'?: string | null;
    /**
     * Latitude
     * @type {string}
     * @memberof DeployedRangeIP
     */
    'latitude'?: string | null;
    /**
     * Longitude
     * @type {string}
     * @memberof DeployedRangeIP
     */
    'longitude'?: string | null;
    /**
     * Set the IP out to public internet, any value means true
     * @type {boolean}
     * @memberof DeployedRangeIP
     */
    'controlNet'?: boolean;
    /**
     * Optional list of DNS servers
     * @type {Array<string>}
     * @memberof DeployedRangeIP
     */
    'dnsServers'?: Array<string>;
    /**
     * ID of a range L3 network
     * @type {string}
     * @memberof DeployedRangeIP
     */
    'rangeL3Network'?: string;
    /**
     * Indicates whether the range IP is ready or not
     * @type {boolean}
     * @memberof DeployedRangeIP
     */
    'ready'?: boolean;
    /**
     * Deployed range IP status
     * @type {string}
     * @memberof DeployedRangeIP
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface DeployedRangeIPsList200Response
 */
export interface DeployedRangeIPsList200Response {
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeIPsList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeIPsList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeIPsList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeIPsList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<DeployedRangeIP>}
     * @memberof DeployedRangeIPsList200Response
     */
    'data'?: Array<DeployedRangeIP>;
}
/**
 * 
 * @export
 * @interface DeployedRangeL3Network
 */
export interface DeployedRangeL3Network {
    /**
     * 
     * @type {string}
     * @memberof DeployedRangeL3Network
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof DeployedRangeL3Network
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof DeployedRangeL3Network
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof DeployedRangeL3Network
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof DeployedRangeL3Network
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof DeployedRangeL3Network
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof DeployedRangeL3Network
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof DeployedRangeL3Network
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Network CIDR Address
     * @type {string}
     * @memberof DeployedRangeL3Network
     */
    'cidr'?: string;
    /**
     * Latitude
     * @type {string}
     * @memberof DeployedRangeL3Network
     */
    'latitude'?: string;
    /**
     * Longitude
     * @type {string}
     * @memberof DeployedRangeL3Network
     */
    'longitude'?: string;
    /**
     * Network Default Gateway
     * @type {string}
     * @memberof DeployedRangeL3Network
     */
    'defaultGateway'?: string | null;
    /**
     * 
     * @type {DHCPConfig}
     * @memberof DeployedRangeL3Network
     */
    'dhcpConfig'?: DHCPConfig | null;
    /**
     * Optional ID of a range network
     * @type {string}
     * @memberof DeployedRangeL3Network
     */
    'rangeNetwork'?: string | null;
}
/**
 * 
 * @export
 * @interface DeployedRangeL3NetworksList200Response
 */
export interface DeployedRangeL3NetworksList200Response {
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeL3NetworksList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeL3NetworksList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeL3NetworksList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeL3NetworksList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<DeployedRangeL3Network>}
     * @memberof DeployedRangeL3NetworksList200Response
     */
    'data'?: Array<DeployedRangeL3Network>;
}
/**
 * 
 * @export
 * @interface DeployedRangeNetwork
 */
export interface DeployedRangeNetwork {
    /**
     * 
     * @type {string}
     * @memberof DeployedRangeNetwork
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof DeployedRangeNetwork
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof DeployedRangeNetwork
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof DeployedRangeNetwork
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof DeployedRangeNetwork
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof DeployedRangeNetwork
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof DeployedRangeNetwork
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof DeployedRangeNetwork
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Optional Cluster Range Network. If specified, this Range Network will be linked to a cluster-wide network that can be shared between scenarios.
     * @type {string}
     * @memberof DeployedRangeNetwork
     */
    'clusterRangeNetwork'?: string | null;
}
/**
 * 
 * @export
 * @interface DeployedRangeNetworksList200Response
 */
export interface DeployedRangeNetworksList200Response {
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeNetworksList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeNetworksList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeNetworksList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeNetworksList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<DeployedRangeNetwork>}
     * @memberof DeployedRangeNetworksList200Response
     */
    'data'?: Array<DeployedRangeNetwork>;
}
/**
 * 
 * @export
 * @interface DeployedRangePkIsList200Response
 */
export interface DeployedRangePkIsList200Response {
    /**
     * 
     * @type {number}
     * @memberof DeployedRangePkIsList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangePkIsList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangePkIsList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangePkIsList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<DeployedRangePki>}
     * @memberof DeployedRangePkIsList200Response
     */
    'data'?: Array<DeployedRangePki>;
}
/**
 * 
 * @export
 * @interface DeployedRangePki
 */
export interface DeployedRangePki {
    /**
     * 
     * @type {string}
     * @memberof DeployedRangePki
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof DeployedRangePki
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof DeployedRangePki
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof DeployedRangePki
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof DeployedRangePki
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof DeployedRangePki
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof DeployedRangePki
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof DeployedRangePki
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * 
     * @type {RangePkiCertificateProfile}
     * @memberof DeployedRangePki
     */
    'certificates'?: RangePkiCertificateProfile;
    /**
     * 
     * @type {RangePkiIntermediateProfile}
     * @memberof DeployedRangePki
     */
    'intermediate'?: RangePkiIntermediateProfile;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeployedRangePki
     */
    'hosts'?: Array<string>;
    /**
     * 
     * @type {Array<RangePkiCertificateSubject>}
     * @memberof DeployedRangePki
     */
    'names'?: Array<RangePkiCertificateSubject>;
    /**
     * 
     * @type {DeployedRangeCertKey}
     * @memberof DeployedRangePki
     */
    'key'?: DeployedRangeCertKey | null;
    /**
     * 
     * @type {string}
     * @memberof DeployedRangePki
     */
    'cN'?: string | null;
    /**
     * 
     * @type {DeployedRangePkiKeyPairData}
     * @memberof DeployedRangePki
     */
    'keyPairData'?: DeployedRangePkiKeyPairData | null;
    /**
     * The signing profile for the signer for bundling
     * @type {string}
     * @memberof DeployedRangePki
     */
    'bundleProfile'?: string;
    /**
     * The name of the Pki to sign the current CSR
     * @type {string}
     * @memberof DeployedRangePki
     */
    'parentCAHost'?: string | null;
    /**
     * Indicates whether the range pki is ready or not
     * @type {boolean}
     * @memberof DeployedRangePki
     */
    'ready'?: boolean;
    /**
     * Deployed range pki status
     * @type {string}
     * @memberof DeployedRangePki
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface DeployedRangePkiKeyPairData
 */
export interface DeployedRangePkiKeyPairData {
    /**
     * 
     * @type {string}
     * @memberof DeployedRangePkiKeyPairData
     */
    'publicKey': string;
    /**
     * 
     * @type {string}
     * @memberof DeployedRangePkiKeyPairData
     */
    'privateKey': string;
}
/**
 * 
 * @export
 * @interface DeployedRangeRouter
 */
export interface DeployedRangeRouter {
    /**
     * 
     * @type {string}
     * @memberof DeployedRangeRouter
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof DeployedRangeRouter
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof DeployedRangeRouter
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof DeployedRangeRouter
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof DeployedRangeRouter
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof DeployedRangeRouter
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof DeployedRangeRouter
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof DeployedRangeRouter
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Hostname of the router instance
     * @type {string}
     * @memberof DeployedRangeRouter
     */
    'hostname'?: string;
    /**
     * Country Code
     * @type {string}
     * @memberof DeployedRangeRouter
     */
    'countryCode'?: string | null;
    /**
     * Latitude
     * @type {string}
     * @memberof DeployedRangeRouter
     */
    'latitude'?: string | null;
    /**
     * Longitude
     * @type {string}
     * @memberof DeployedRangeRouter
     */
    'longitude'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeployedRangeRouter
     */
    'protocols'?: Array<DeployedRangeRouterProtocolsEnum>;
    /**
     * 
     * @type {Array<DeployedRangeRouterInterface>}
     * @memberof DeployedRangeRouter
     */
    'interfaces'?: Array<DeployedRangeRouterInterface>;
}

export const DeployedRangeRouterProtocolsEnum = {
    Ospf: 'ospf',
    Rip: 'rip',
    Bgp: 'bgp'
} as const;

export type DeployedRangeRouterProtocolsEnum = typeof DeployedRangeRouterProtocolsEnum[keyof typeof DeployedRangeRouterProtocolsEnum];

/**
 * 
 * @export
 * @interface DeployedRangeRouterInterface
 */
export interface DeployedRangeRouterInterface {
    /**
     * 
     * @type {RangeRouterInterfaceType}
     * @memberof DeployedRangeRouterInterface
     */
    'interfaceType'?: RangeRouterInterfaceType | null;
    /**
     * IP addresses assigned to the interface
     * @type {Array<string>}
     * @memberof DeployedRangeRouterInterface
     */
    'rangeIPs'?: Array<string>;
    /**
     * Optional ID of a range network
     * @type {string}
     * @memberof DeployedRangeRouterInterface
     */
    'rangeNetwork'?: string | null;
}


/**
 * 
 * @export
 * @interface DeployedRangeRoutersList200Response
 */
export interface DeployedRangeRoutersList200Response {
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeRoutersList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeRoutersList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeRoutersList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeRoutersList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<DeployedRangeRouter>}
     * @memberof DeployedRangeRoutersList200Response
     */
    'data'?: Array<DeployedRangeRouter>;
}
/**
 * 
 * @export
 * @interface DeployedRangeTorNet
 */
export interface DeployedRangeTorNet {
    /**
     * 
     * @type {string}
     * @memberof DeployedRangeTorNet
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof DeployedRangeTorNet
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof DeployedRangeTorNet
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof DeployedRangeTorNet
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof DeployedRangeTorNet
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof DeployedRangeTorNet
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof DeployedRangeTorNet
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof DeployedRangeTorNet
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Tor version
     * @type {string}
     * @memberof DeployedRangeTorNet
     */
    'version'?: DeployedRangeTorNetVersionEnum;
    /**
     * Tor directory authorities
     * @type {Array<RangeTorNode>}
     * @memberof DeployedRangeTorNet
     */
    'directoryAuthorities'?: Array<RangeTorNode>;
    /**
     * Tor relays
     * @type {Array<RangeTorNode>}
     * @memberof DeployedRangeTorNet
     */
    'relays'?: Array<RangeTorNode>;
    /**
     * Tor exit nodes
     * @type {Array<RangeTorNode>}
     * @memberof DeployedRangeTorNet
     */
    'exitNodes'?: Array<RangeTorNode>;
}

export const DeployedRangeTorNetVersionEnum = {
    _04711: '0.4.7.11'
} as const;

export type DeployedRangeTorNetVersionEnum = typeof DeployedRangeTorNetVersionEnum[keyof typeof DeployedRangeTorNetVersionEnum];

/**
 * 
 * @export
 * @interface DeployedRangeTorNetsList200Response
 */
export interface DeployedRangeTorNetsList200Response {
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeTorNetsList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeTorNetsList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeTorNetsList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeTorNetsList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<DeployedRangeTorNet>}
     * @memberof DeployedRangeTorNetsList200Response
     */
    'data'?: Array<DeployedRangeTorNet>;
}
/**
 * 
 * @export
 * @interface DeployedRangeVMsList200Response
 */
export interface DeployedRangeVMsList200Response {
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeVMsList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeVMsList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeVMsList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeVMsList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<RangeVM>}
     * @memberof DeployedRangeVMsList200Response
     */
    'data'?: Array<RangeVM>;
}
/**
 * 
 * @export
 * @interface DeployedRangeVolume
 */
export interface DeployedRangeVolume {
    /**
     * 
     * @type {string}
     * @memberof DeployedRangeVolume
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof DeployedRangeVolume
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof DeployedRangeVolume
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof DeployedRangeVolume
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof DeployedRangeVolume
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof DeployedRangeVolume
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof DeployedRangeVolume
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof DeployedRangeVolume
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * The type of storage for this volume
     * @type {string}
     * @memberof DeployedRangeVolume
     */
    'storageClass'?: string | null;
    /**
     * Quantity of requested storage space to be allocated. Minimum supported value: 100M
     * @type {string}
     * @memberof DeployedRangeVolume
     */
    'storage'?: string;
    /**
     * Optional ID of the volume to be downloaded to the range
     * @type {string}
     * @memberof DeployedRangeVolume
     */
    'volume'?: string | null;
    /**
     * Indicates whether the range volume is ready or not
     * @type {boolean}
     * @memberof DeployedRangeVolume
     */
    'ready'?: boolean;
    /**
     * Deployed range volume status
     * @type {string}
     * @memberof DeployedRangeVolume
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface DeployedRangeVolumesList200Response
 */
export interface DeployedRangeVolumesList200Response {
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeVolumesList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeVolumesList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeVolumesList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedRangeVolumesList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<DeployedRangeVolume>}
     * @memberof DeployedRangeVolumesList200Response
     */
    'data'?: Array<DeployedRangeVolume>;
}
/**
 * 
 * @export
 * @interface DeployedScenario
 */
export interface DeployedScenario {
    /**
     * 
     * @type {string}
     * @memberof DeployedScenario
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof DeployedScenario
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof DeployedScenario
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof DeployedScenario
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof DeployedScenario
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof DeployedScenario
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof DeployedScenario
     */
    'metadata'?: object;
    /**
     * Deprecated in favor of metadata
     * @type {Array<string>}
     * @memberof DeployedScenario
     * @deprecated
     */
    'metadata_tags'?: Array<string>;
    /**
     * Array of Draft UUIDs that this scenario is a part of
     * @type {Array<string>}
     * @memberof DeployedScenario
     */
    'drafts'?: Array<string>;
    /**
     * MTO path and group for users to access this scenario
     * @type {Array<MTOPermissions>}
     * @memberof DeployedScenario
     */
    'mtoPermissions'?: Array<MTOPermissions>;
    /**
     * ID of the scenario this was deployed from
     * @type {string}
     * @memberof DeployedScenario
     */
    'scenarioId'?: string;
    /**
     * Values passed to the scenario when it was created
     * @type {object}
     * @memberof DeployedScenario
     */
    'scenarioValues'?: object;
    /**
     * The UUID of the event tree
     * @type {string}
     * @memberof DeployedScenario
     */
    'eventTree'?: string | null;
    /**
     * Status of the scenario
     * @type {string}
     * @memberof DeployedScenario
     */
    'status'?: DeployedScenarioStatusEnum;
    /**
     * Optional status message
     * @type {string}
     * @memberof DeployedScenario
     */
    'message'?: string;
    /**
     * Email of the user who deployed the scenario
     * @type {string}
     * @memberof DeployedScenario
     */
    'deployedBy'?: string;
    /**
     * Id of the student assigned to the scenario
     * @type {string}
     * @memberof DeployedScenario
     */
    'studentId'?: string | null;
    /**
     * Username of the student assigned to the scenario
     * @type {string}
     * @memberof DeployedScenario
     */
    'studentUsername'?: string | null;
    /**
     * Whether the scenario is assigned to a student
     * @type {boolean}
     * @memberof DeployedScenario
     */
    'assigned'?: boolean | null;
    /**
     * Id of the class the scenario is assigned to
     * @type {string}
     * @memberof DeployedScenario
     */
    'classId'?: string | null;
}

export const DeployedScenarioStatusEnum = {
    Unknown: 'Unknown',
    Ready: 'Ready',
    NotReady: 'NotReady',
    Creating: 'Creating',
    Error: 'Error',
    Deleting: 'Deleting',
    Stopped: 'Stopped'
} as const;

export type DeployedScenarioStatusEnum = typeof DeployedScenarioStatusEnum[keyof typeof DeployedScenarioStatusEnum];

/**
 * 
 * @export
 * @interface DeployedScenarioDetail
 */
export interface DeployedScenarioDetail {
    /**
     * 
     * @type {string}
     * @memberof DeployedScenarioDetail
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof DeployedScenarioDetail
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof DeployedScenarioDetail
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof DeployedScenarioDetail
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof DeployedScenarioDetail
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof DeployedScenarioDetail
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof DeployedScenarioDetail
     */
    'metadata'?: object;
    /**
     * Deprecated in favor of metadata
     * @type {Array<string>}
     * @memberof DeployedScenarioDetail
     * @deprecated
     */
    'metadata_tags'?: Array<string>;
    /**
     * Array of Draft UUIDs that this scenario is a part of
     * @type {Array<string>}
     * @memberof DeployedScenarioDetail
     */
    'drafts'?: Array<string>;
    /**
     * MTO path and group for users to access this scenario
     * @type {Array<MTOPermissions>}
     * @memberof DeployedScenarioDetail
     */
    'mtoPermissions'?: Array<MTOPermissions>;
    /**
     * ID of the scenario this was deployed from
     * @type {string}
     * @memberof DeployedScenarioDetail
     */
    'scenarioId'?: string;
    /**
     * Values passed to the scenario when it was created
     * @type {object}
     * @memberof DeployedScenarioDetail
     */
    'scenarioValues'?: object;
    /**
     * List of deployed packages
     * @type {Array<DeployedPackageDetail>}
     * @memberof DeployedScenarioDetail
     */
    'packages'?: Array<DeployedPackageDetail>;
    /**
     * The UUID of the event tree
     * @type {string}
     * @memberof DeployedScenarioDetail
     */
    'eventTree'?: string | null;
    /**
     * Status of the scenario
     * @type {string}
     * @memberof DeployedScenarioDetail
     */
    'status'?: DeployedScenarioDetailStatusEnum;
    /**
     * Optional status message
     * @type {string}
     * @memberof DeployedScenarioDetail
     */
    'message'?: string;
    /**
     * Email of the user who deployed the scenario
     * @type {string}
     * @memberof DeployedScenarioDetail
     */
    'deployedBy'?: string;
    /**
     * Id of the student assigned to the scenario
     * @type {string}
     * @memberof DeployedScenarioDetail
     */
    'studentId'?: string | null;
    /**
     * Username of the student assigned to the scenario
     * @type {string}
     * @memberof DeployedScenarioDetail
     */
    'studentUsername'?: string | null;
    /**
     * Whether the scenario is assigned to a student
     * @type {boolean}
     * @memberof DeployedScenarioDetail
     */
    'assigned'?: boolean | null;
    /**
     * Id of the class the scenario is assigned to
     * @type {string}
     * @memberof DeployedScenarioDetail
     */
    'classId'?: string | null;
}

export const DeployedScenarioDetailStatusEnum = {
    Unknown: 'Unknown',
    Ready: 'Ready',
    NotReady: 'NotReady',
    Creating: 'Creating',
    Error: 'Error',
    Deleting: 'Deleting',
    Stopped: 'Stopped'
} as const;

export type DeployedScenarioDetailStatusEnum = typeof DeployedScenarioDetailStatusEnum[keyof typeof DeployedScenarioDetailStatusEnum];

/**
 * Grant or revoke access to specific users for the given scenario
 * @export
 * @interface DeployedScenarioPermission
 */
export interface DeployedScenarioPermission {
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof DeployedScenarioPermission
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof DeployedScenarioPermission
     */
    'dateEdited'?: string;
    /**
     * If true, all scenario group permissions are enforced; otherwise, only scenarioAdmins can access the scenario and any blue/red/whiteCell users\' access is revoked
     * @type {boolean}
     * @memberof DeployedScenarioPermission
     */
    'enabled'?: boolean;
    /**
     * List of SSO usernames in the Blue Cell scenario group
     * @type {Array<string>}
     * @memberof DeployedScenarioPermission
     */
    'blueCell'?: Array<string>;
    /**
     * List of SSO usernames in the Red Cell scenario group
     * @type {Array<string>}
     * @memberof DeployedScenarioPermission
     */
    'redCell'?: Array<string>;
    /**
     * List of SSO usernames in the White Cell scenario group
     * @type {Array<string>}
     * @memberof DeployedScenarioPermission
     */
    'whiteCell'?: Array<string>;
    /**
     * List of SSO usernames in the Scenario Admin scenario group
     * @type {Array<string>}
     * @memberof DeployedScenarioPermission
     */
    'scenarioAdmin'?: Array<string>;
}
/**
 * 
 * @export
 * @interface DeployedTelemetryAgent
 */
export interface DeployedTelemetryAgent {
    /**
     * 
     * @type {string}
     * @memberof DeployedTelemetryAgent
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof DeployedTelemetryAgent
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof DeployedTelemetryAgent
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof DeployedTelemetryAgent
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof DeployedTelemetryAgent
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof DeployedTelemetryAgent
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof DeployedTelemetryAgent
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof DeployedTelemetryAgent
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Interval that the script will run in seconds
     * @type {number}
     * @memberof DeployedTelemetryAgent
     */
    'interval'?: number;
    /**
     * Script to run
     * @type {string}
     * @memberof DeployedTelemetryAgent
     */
    'script'?: string;
    /**
     * Ansible Role ID
     * @type {string}
     * @memberof DeployedTelemetryAgent
     */
    'ansibleRoleId'?: string;
    /**
     * Ansible User
     * @type {string}
     * @memberof DeployedTelemetryAgent
     */
    'ansibleUser'?: string;
    /**
     * Ansible Password
     * @type {string}
     * @memberof DeployedTelemetryAgent
     */
    'ansiblePassword'?: string;
    /**
     * UUID of RangeVM to have Telegraf Installed
     * @type {string}
     * @memberof DeployedTelemetryAgent
     */
    'targetRangeVm'?: string;
    /**
     * Provisioning Service Module is ready
     * @type {boolean}
     * @memberof DeployedTelemetryAgent
     */
    'ready'?: boolean;
    /**
     * Provisioning Service Module\'s Status
     * @type {string}
     * @memberof DeployedTelemetryAgent
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface DeployedTelemetryAgentsList200Response
 */
export interface DeployedTelemetryAgentsList200Response {
    /**
     * 
     * @type {number}
     * @memberof DeployedTelemetryAgentsList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedTelemetryAgentsList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedTelemetryAgentsList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedTelemetryAgentsList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<DeployedTelemetryAgent>}
     * @memberof DeployedTelemetryAgentsList200Response
     */
    'data'?: Array<DeployedTelemetryAgent>;
}
/**
 * 
 * @export
 * @interface DeployedTrafficTracker
 */
export interface DeployedTrafficTracker {
    /**
     * 
     * @type {string}
     * @memberof DeployedTrafficTracker
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof DeployedTrafficTracker
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof DeployedTrafficTracker
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof DeployedTrafficTracker
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof DeployedTrafficTracker
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof DeployedTrafficTracker
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof DeployedTrafficTracker
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof DeployedTrafficTracker
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * 
     * @type {Array<Stream>}
     * @memberof DeployedTrafficTracker
     */
    'streams'?: Array<Stream>;
    /**
     * Network Overrides
     * @type {Array<string>}
     * @memberof DeployedTrafficTracker
     */
    'networkOverrides'?: Array<string>;
    /**
     * List of Captures
     * @type {Array<CaptureApi>}
     * @memberof DeployedTrafficTracker
     */
    'captures'?: Array<CaptureApi>;
    /**
     * Provisioning Service Module is ready
     * @type {boolean}
     * @memberof DeployedTrafficTracker
     */
    'ready'?: boolean;
    /**
     * Provisioning Service Module\'s Status
     * @type {string}
     * @memberof DeployedTrafficTracker
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface DeployedTrafficTrackersList200Response
 */
export interface DeployedTrafficTrackersList200Response {
    /**
     * 
     * @type {number}
     * @memberof DeployedTrafficTrackersList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedTrafficTrackersList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedTrafficTrackersList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DeployedTrafficTrackersList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<DeployedTrafficTracker>}
     * @memberof DeployedTrafficTrackersList200Response
     */
    'data'?: Array<DeployedTrafficTracker>;
}
/**
 * 
 * @export
 * @interface DesignAIResponse
 */
export interface DesignAIResponse {
    /**
     * AI response
     * @type {string}
     * @memberof DesignAIResponse
     */
    'response': string;
    /**
     * 
     * @type {Array<DesignAIResponseToolCallsInner>}
     * @memberof DesignAIResponse
     */
    'toolCalls': Array<DesignAIResponseToolCallsInner>;
}
/**
 * @type DesignAIResponseToolCallsInner
 * @export
 */
export type DesignAIResponseToolCallsInner = { type: 'addPackage' } & DesignAIToolCallAddPackage | { type: 'importScenario' } & DesignAIToolCallImportScenario;

/**
 * 
 * @export
 * @interface DesignAIToolCallAddPackage
 */
export interface DesignAIToolCallAddPackage {
    /**
     * 
     * @type {string}
     * @memberof DesignAIToolCallAddPackage
     */
    'type': DesignAIToolCallAddPackageTypeEnum;
    /**
     * Package UUID to import
     * @type {string}
     * @memberof DesignAIToolCallAddPackage
     */
    'package'?: string;
}

export const DesignAIToolCallAddPackageTypeEnum = {
    ImportScenario: 'importScenario',
    AddPackage: 'addPackage'
} as const;

export type DesignAIToolCallAddPackageTypeEnum = typeof DesignAIToolCallAddPackageTypeEnum[keyof typeof DesignAIToolCallAddPackageTypeEnum];

/**
 * 
 * @export
 * @interface DesignAIToolCallImportScenario
 */
export interface DesignAIToolCallImportScenario {
    /**
     * 
     * @type {string}
     * @memberof DesignAIToolCallImportScenario
     */
    'type': DesignAIToolCallImportScenarioTypeEnum;
    /**
     * Draft State UUID to import
     * @type {string}
     * @memberof DesignAIToolCallImportScenario
     */
    'draftState'?: string;
    /**
     * Draft UUID to import
     * @type {string}
     * @memberof DesignAIToolCallImportScenario
     */
    'draft'?: string;
}

export const DesignAIToolCallImportScenarioTypeEnum = {
    ImportScenario: 'importScenario',
    AddPackage: 'addPackage'
} as const;

export type DesignAIToolCallImportScenarioTypeEnum = typeof DesignAIToolCallImportScenarioTypeEnum[keyof typeof DesignAIToolCallImportScenarioTypeEnum];

/**
 * 
 * @export
 * @interface Draft
 */
export interface Draft {
    /**
     * 
     * @type {string}
     * @memberof Draft
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof Draft
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof Draft
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof Draft
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof Draft
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof Draft
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof Draft
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface DraftCreate
 */
export interface DraftCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof DraftCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof DraftCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof DraftCreate
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface DraftPayload
 */
export interface DraftPayload {
    /**
     * Type of the payload
     * @type {string}
     * @memberof DraftPayload
     */
    'type': DraftPayloadTypeEnum;
    /**
     * Unique key of the entity in the draft
     * @type {string}
     * @memberof DraftPayload
     */
    'key': string;
    /**
     * API version of the payload
     * @type {number}
     * @memberof DraftPayload
     */
    'apiVersion'?: number;
    /**
     * Entity payload
     * @type {object}
     * @memberof DraftPayload
     */
    'payload': object;
}

export const DraftPayloadTypeEnum = {
    AnsiblePlaybook: 'AnsiblePlaybook',
    AutoGrader: 'AutoGrader',
    Cpe: 'CPE',
    ClusterRangeNetwork: 'ClusterRangeNetwork',
    ContainerSpecification: 'ContainerSpecification',
    GhostAgent: 'GhostAgent',
    GhostC2Server: 'GhostC2Server',
    GhostClient: 'GhostClient',
    GhostTraffic: 'GhostTraffic',
    GhostTrafficProfile: 'GhostTrafficProfile',
    EventTree: 'EventTree',
    InternetGateway: 'InternetGateway',
    Package: 'Package',
    RangeAutoIp: 'RangeAutoIP',
    RangeAutoL3Network: 'RangeAutoL3Network',
    RangeBgp: 'RangeBGP',
    RangeBgpLink: 'RangeBGPLink',
    RangeCert: 'RangeCert',
    RangeConsole: 'RangeConsole',
    RangeDnsRecord: 'RangeDNSRecord',
    RangeDnsServer: 'RangeDNSServer',
    RangeDnsZone: 'RangeDNSZone',
    RangeIp: 'RangeIP',
    RangeL3Network: 'RangeL3Network',
    RangeHostNetwork: 'RangeHostNetwork',
    RangeNetwork: 'RangeNetwork',
    RangePki: 'RangePki',
    RangeRouter: 'RangeRouter',
    RangeTorNet: 'RangeTorNet',
    RangeVolume: 'RangeVolume',
    Scenario: 'Scenario',
    TelemetryAgent: 'TelemetryAgent',
    TrafficTracker: 'TrafficTracker',
    VmSpecification: 'VMSpecification'
} as const;

export type DraftPayloadTypeEnum = typeof DraftPayloadTypeEnum[keyof typeof DraftPayloadTypeEnum];

/**
 * 
 * @export
 * @interface DraftReference
 */
export interface DraftReference {
    /**
     * Type of the reference
     * @type {string}
     * @memberof DraftReference
     */
    'type': string;
    /**
     * Unique key of the entity in the draft
     * @type {string}
     * @memberof DraftReference
     */
    'key': string;
    /**
     * ID of the referenced entity
     * @type {string}
     * @memberof DraftReference
     */
    'uuid': string;
}
/**
 * 
 * @export
 * @interface DraftState
 */
export interface DraftState {
    /**
     * 
     * @type {string}
     * @memberof DraftState
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof DraftState
     */
    'dateCreated'?: string;
    /**
     * Unique version number used for optimistic locking
     * @type {number}
     * @memberof DraftState
     */
    'version': number;
    /**
     * Opaque JSON storage for draft state
     * @type {object}
     * @memberof DraftState
     */
    'state': object;
    /**
     * Array of payloads owned by this draft state
     * @type {Array<DraftPayload>}
     * @memberof DraftState
     */
    'payloads': Array<DraftPayload>;
    /**
     * Array of references to resources not owned by this draft state
     * @type {Array<DraftReference>}
     * @memberof DraftState
     */
    'references': Array<DraftReference>;
    /**
     * Map of unique keys to UUIDs
     * @type {{ [key: string]: string; }}
     * @memberof DraftState
     */
    'published'?: { [key: string]: string; };
    /**
     * Optional user provided information about the draft state
     * @type {string}
     * @memberof DraftState
     */
    'note'?: string;
    /**
     * Related draft for this draft state
     * @type {string}
     * @memberof DraftState
     */
    'draft'?: string;
    /**
     * If true, the payloads will be created/updated
     * @type {boolean}
     * @memberof DraftState
     */
    'publish'?: boolean;
}
/**
 * 
 * @export
 * @interface DraftStateCreate
 */
export interface DraftStateCreate {
    /**
     * Unique version number used for optimistic locking
     * @type {number}
     * @memberof DraftStateCreate
     */
    'version': number;
    /**
     * Opaque JSON storage for draft state
     * @type {object}
     * @memberof DraftStateCreate
     */
    'state': object;
    /**
     * Array of payloads owned by this draft state
     * @type {Array<DraftPayload>}
     * @memberof DraftStateCreate
     */
    'payloads': Array<DraftPayload>;
    /**
     * Array of references to resources not owned by this draft state
     * @type {Array<DraftReference>}
     * @memberof DraftStateCreate
     */
    'references': Array<DraftReference>;
    /**
     * Optional user provided information about the draft state
     * @type {string}
     * @memberof DraftStateCreate
     */
    'note'?: string;
    /**
     * If true, the payloads will be created/updated
     * @type {boolean}
     * @memberof DraftStateCreate
     */
    'publish'?: boolean;
}
/**
 * 
 * @export
 * @interface DraftStatesList200Response
 */
export interface DraftStatesList200Response {
    /**
     * 
     * @type {number}
     * @memberof DraftStatesList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof DraftStatesList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof DraftStatesList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DraftStatesList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<DraftState>}
     * @memberof DraftStatesList200Response
     */
    'data'?: Array<DraftState>;
}
/**
 * 
 * @export
 * @interface DraftUpdate
 */
export interface DraftUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof DraftUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof DraftUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof DraftUpdate
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface DraftsList200Response
 */
export interface DraftsList200Response {
    /**
     * 
     * @type {number}
     * @memberof DraftsList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof DraftsList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof DraftsList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DraftsList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<Draft>}
     * @memberof DraftsList200Response
     */
    'data'?: Array<Draft>;
}
/**
 * 
 * @export
 * @interface Drivers
 */
export interface Drivers {
    /**
     * Optional disk driver, defaulted to virtio
     * @type {string}
     * @memberof Drivers
     */
    'disk'?: DriversDiskEnum;
    /**
     * Optional network driver, defaulted to virtio
     * @type {string}
     * @memberof Drivers
     */
    'network'?: DriversNetworkEnum;
    /**
     * 
     * @type {InputDeviceType}
     * @memberof Drivers
     */
    'inputDevice'?: InputDeviceType | null;
}

export const DriversDiskEnum = {
    Sata: 'sata',
    Scsi: 'scsi',
    Virtio: 'virtio'
} as const;

export type DriversDiskEnum = typeof DriversDiskEnum[keyof typeof DriversDiskEnum];
export const DriversNetworkEnum = {
    E1000: 'e1000',
    E1000e: 'e1000e',
    Ne2kPci: 'ne2k_pci',
    Pcnet: 'pcnet',
    Rtl8139: 'rtl8139',
    Virtio: 'virtio'
} as const;

export type DriversNetworkEnum = typeof DriversNetworkEnum[keyof typeof DriversNetworkEnum];

/**
 * AWS Environment
 * @export
 * @interface EnvironmentAws
 */
export interface EnvironmentAws {
    /**
     * The author of the AWS environment.
     * @type {string}
     * @memberof EnvironmentAws
     */
    'author'?: string;
    /**
     * An environment specification ID.
     * @type {string}
     * @memberof EnvironmentAws
     */
    'environmentSpec'?: string;
    /**
     * An environment credentials ID.
     * @type {string}
     * @memberof EnvironmentAws
     */
    'environmentCredentials'?: string;
    /**
     * The availability zone of the AWS environment.
     * @type {string}
     * @memberof EnvironmentAws
     */
    'awsAvailabilityZone'?: string;
    /**
     * The region of the AWS environment.
     * @type {string}
     * @memberof EnvironmentAws
     */
    'awsRegion'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof EnvironmentAws
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof EnvironmentAws
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof EnvironmentAws
     */
    'name'?: string;
    /**
     * A v4 UUID.
     * @type {string}
     * @memberof EnvironmentAws
     */
    'uuid'?: string;
    /**
     * Indicates whether the range container is ready or not
     * @type {boolean}
     * @memberof EnvironmentAws
     */
    'ready'?: boolean;
    /**
     * Deployed range container status
     * @type {object}
     * @memberof EnvironmentAws
     */
    'status'?: object;
    /**
     * Error message, empty if no error present.
     * @type {string}
     * @memberof EnvironmentAws
     */
    'message'?: string;
    /**
     * Description of the Environment
     * @type {string}
     * @memberof EnvironmentAws
     */
    'description'?: string;
}
/**
 * AWS Environment
 * @export
 * @interface EnvironmentAwsCreate
 */
export interface EnvironmentAwsCreate {
    /**
     * An environment specification ID.
     * @type {string}
     * @memberof EnvironmentAwsCreate
     */
    'environmentSpec': string;
    /**
     * An environment credentials ID.
     * @type {string}
     * @memberof EnvironmentAwsCreate
     */
    'environmentCredentials': string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof EnvironmentAwsCreate
     */
    'name': string;
    /**
     * Description of the Environment
     * @type {string}
     * @memberof EnvironmentAwsCreate
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface EnvironmentAwsCredentialList200Response
 */
export interface EnvironmentAwsCredentialList200Response {
    /**
     * 
     * @type {number}
     * @memberof EnvironmentAwsCredentialList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentAwsCredentialList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentAwsCredentialList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentAwsCredentialList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<EnvironmentCredentialAws>}
     * @memberof EnvironmentAwsCredentialList200Response
     */
    'data'?: Array<EnvironmentCredentialAws>;
}
/**
 * 
 * @export
 * @interface EnvironmentAwsList200Response
 */
export interface EnvironmentAwsList200Response {
    /**
     * 
     * @type {number}
     * @memberof EnvironmentAwsList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentAwsList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentAwsList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentAwsList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<EnvironmentAws>}
     * @memberof EnvironmentAwsList200Response
     */
    'data'?: Array<EnvironmentAws>;
}
/**
 * Environment AWS Region
 * @export
 * @interface EnvironmentAwsRegion
 */
export interface EnvironmentAwsRegion {
    /**
     * Name of the region
     * @type {string}
     * @memberof EnvironmentAwsRegion
     */
    'region'?: string;
    /**
     * List of zones in the region
     * @type {Array<string>}
     * @memberof EnvironmentAwsRegion
     */
    'zones'?: Array<string>;
}
/**
 * 
 * @export
 * @interface EnvironmentAwsSpecificationList200Response
 */
export interface EnvironmentAwsSpecificationList200Response {
    /**
     * 
     * @type {number}
     * @memberof EnvironmentAwsSpecificationList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentAwsSpecificationList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentAwsSpecificationList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentAwsSpecificationList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<EnvironmentSpecificationAws>}
     * @memberof EnvironmentAwsSpecificationList200Response
     */
    'data'?: Array<EnvironmentSpecificationAws>;
}
/**
 * AWS Environment
 * @export
 * @interface EnvironmentAwsUpdate
 */
export interface EnvironmentAwsUpdate {
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof EnvironmentAwsUpdate
     */
    'name'?: string;
    /**
     * Description of the Environment
     * @type {string}
     * @memberof EnvironmentAwsUpdate
     */
    'description'?: string;
}
/**
 * AWS Environment Credentials
 * @export
 * @interface EnvironmentCredentialAws
 */
export interface EnvironmentCredentialAws {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentCredentialAws
     */
    'uuid'?: string;
    /**
     * The default region to use when creating clusters in AWS.
     * @type {string}
     * @memberof EnvironmentCredentialAws
     */
    'defaultRegion'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof EnvironmentCredentialAws
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof EnvironmentCredentialAws
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof EnvironmentCredentialAws
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof EnvironmentCredentialAws
     */
    'name'?: string;
    /**
     * The author of the AWS environment.
     * @type {string}
     * @memberof EnvironmentCredentialAws
     */
    'author'?: string;
    /**
     * The ID of an AWS access key.
     * @type {string}
     * @memberof EnvironmentCredentialAws
     */
    'accessKeyId'?: string;
    /**
     * The secret of an AWS access key.
     * @type {string}
     * @memberof EnvironmentCredentialAws
     */
    'accessKeySecret'?: string;
    /**
     * Rancher environment credentials id.
     * @type {string}
     * @memberof EnvironmentCredentialAws
     */
    'environmentCredentialRancher'?: string;
}
/**
 * AWS Environment Credentials
 * @export
 * @interface EnvironmentCredentialAwsCreate
 */
export interface EnvironmentCredentialAwsCreate {
    /**
     * The default region to use when creating clusters in AWS.
     * @type {string}
     * @memberof EnvironmentCredentialAwsCreate
     */
    'defaultRegion': string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof EnvironmentCredentialAwsCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof EnvironmentCredentialAwsCreate
     */
    'name': string;
    /**
     * The ID of an AWS access key.
     * @type {string}
     * @memberof EnvironmentCredentialAwsCreate
     */
    'accessKeyId': string;
    /**
     * The secret of an AWS access key.
     * @type {string}
     * @memberof EnvironmentCredentialAwsCreate
     */
    'accessKeySecret': string;
    /**
     * Rancher environment credentials id.
     * @type {string}
     * @memberof EnvironmentCredentialAwsCreate
     */
    'environmentCredentialRancher': string;
}
/**
 * AWS Environment Credentials
 * @export
 * @interface EnvironmentCredentialAwsUpdate
 */
export interface EnvironmentCredentialAwsUpdate {
    /**
     * The default region to use when creating clusters in AWS.
     * @type {string}
     * @memberof EnvironmentCredentialAwsUpdate
     */
    'defaultRegion'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof EnvironmentCredentialAwsUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof EnvironmentCredentialAwsUpdate
     */
    'name'?: string;
    /**
     * The ID of an AWS access key.
     * @type {string}
     * @memberof EnvironmentCredentialAwsUpdate
     */
    'accessKeyId'?: string;
    /**
     * The secret of an AWS access key.
     * @type {string}
     * @memberof EnvironmentCredentialAwsUpdate
     */
    'accessKeySecret'?: string;
    /**
     * Rancher environment credentials id.
     * @type {string}
     * @memberof EnvironmentCredentialAwsUpdate
     */
    'environmentCredentialRancher'?: string;
}
/**
 * Rancher Environment Credentials
 * @export
 * @interface EnvironmentCredentialRancher
 */
export interface EnvironmentCredentialRancher {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentCredentialRancher
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof EnvironmentCredentialRancher
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof EnvironmentCredentialRancher
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof EnvironmentCredentialRancher
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof EnvironmentCredentialRancher
     */
    'name'?: string;
    /**
     * The author of the Rancher environment.
     * @type {string}
     * @memberof EnvironmentCredentialRancher
     */
    'author'?: string;
    /**
     * Rancher access key.
     * @type {string}
     * @memberof EnvironmentCredentialRancher
     */
    'accessKey'?: string;
    /**
     * Rancher secret key.
     * @type {string}
     * @memberof EnvironmentCredentialRancher
     */
    'secretKey'?: string;
    /**
     * Rancher token key.
     * @type {string}
     * @memberof EnvironmentCredentialRancher
     */
    'tokenKey'?: string;
    /**
     * Rancher URL.
     * @type {string}
     * @memberof EnvironmentCredentialRancher
     */
    'url'?: string;
    /**
     * Rancher connection timeout (in seconds).
     * @type {number}
     * @memberof EnvironmentCredentialRancher
     */
    'timeout'?: number;
    /**
     * Ignore TLS certificate warnings.
     * @type {boolean}
     * @memberof EnvironmentCredentialRancher
     */
    'insecureTls'?: boolean;
    /**
     * Rancher CA certificates.
     * @type {string}
     * @memberof EnvironmentCredentialRancher
     */
    'caCerts'?: string;
}
/**
 * Rancher Environment Credentials
 * @export
 * @interface EnvironmentCredentialRancherCreate
 */
export interface EnvironmentCredentialRancherCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof EnvironmentCredentialRancherCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof EnvironmentCredentialRancherCreate
     */
    'name': string;
    /**
     * Rancher access key.
     * @type {string}
     * @memberof EnvironmentCredentialRancherCreate
     */
    'accessKey': string;
    /**
     * Rancher secret key.
     * @type {string}
     * @memberof EnvironmentCredentialRancherCreate
     */
    'secretKey': string;
    /**
     * Rancher token key.
     * @type {string}
     * @memberof EnvironmentCredentialRancherCreate
     */
    'tokenKey'?: string;
    /**
     * Rancher URL.
     * @type {string}
     * @memberof EnvironmentCredentialRancherCreate
     */
    'url': string;
    /**
     * Rancher connection timeout (in seconds).
     * @type {number}
     * @memberof EnvironmentCredentialRancherCreate
     */
    'timeout'?: number;
    /**
     * Ignore TLS certificate warnings.
     * @type {boolean}
     * @memberof EnvironmentCredentialRancherCreate
     */
    'insecureTls': boolean;
    /**
     * Rancher CA certificates.
     * @type {string}
     * @memberof EnvironmentCredentialRancherCreate
     */
    'caCerts'?: string;
}
/**
 * Rancher Environment Credentials
 * @export
 * @interface EnvironmentCredentialRancherUpdate
 */
export interface EnvironmentCredentialRancherUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof EnvironmentCredentialRancherUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof EnvironmentCredentialRancherUpdate
     */
    'name'?: string;
    /**
     * Rancher access key.
     * @type {string}
     * @memberof EnvironmentCredentialRancherUpdate
     */
    'accessKey'?: string;
    /**
     * Rancher secret key.
     * @type {string}
     * @memberof EnvironmentCredentialRancherUpdate
     */
    'secretKey'?: string;
    /**
     * Rancher token key.
     * @type {string}
     * @memberof EnvironmentCredentialRancherUpdate
     */
    'tokenKey'?: string;
    /**
     * Rancher URL.
     * @type {string}
     * @memberof EnvironmentCredentialRancherUpdate
     */
    'url'?: string;
    /**
     * Rancher connection timeout (in seconds).
     * @type {number}
     * @memberof EnvironmentCredentialRancherUpdate
     */
    'timeout'?: number;
    /**
     * Ignore TLS certificate warnings.
     * @type {boolean}
     * @memberof EnvironmentCredentialRancherUpdate
     */
    'insecureTls'?: boolean;
    /**
     * Rancher CA certificates.
     * @type {string}
     * @memberof EnvironmentCredentialRancherUpdate
     */
    'caCerts'?: string;
}
/**
 * Vsphere Environment Credentials
 * @export
 * @interface EnvironmentCredentialVsphere
 */
export interface EnvironmentCredentialVsphere {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentCredentialVsphere
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof EnvironmentCredentialVsphere
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof EnvironmentCredentialVsphere
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof EnvironmentCredentialVsphere
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof EnvironmentCredentialVsphere
     */
    'name'?: string;
    /**
     * The author of the Vsphere environment.
     * @type {string}
     * @memberof EnvironmentCredentialVsphere
     */
    'author'?: string;
    /**
     * Vsphere username.
     * @type {string}
     * @memberof EnvironmentCredentialVsphere
     */
    'username'?: string;
    /**
     * Vsphere password.
     * @type {string}
     * @memberof EnvironmentCredentialVsphere
     */
    'password'?: string;
    /**
     * Vcenter hostname.
     * @type {string}
     * @memberof EnvironmentCredentialVsphere
     */
    'vcenter'?: string;
    /**
     * Vcenter port.
     * @type {number}
     * @memberof EnvironmentCredentialVsphere
     */
    'port'?: number;
    /**
     * Rancher environment credentials id.
     * @type {string}
     * @memberof EnvironmentCredentialVsphere
     */
    'environmentCredentialRancher'?: string;
}
/**
 * Vsphere Environment Credentials
 * @export
 * @interface EnvironmentCredentialVsphereCreate
 */
export interface EnvironmentCredentialVsphereCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof EnvironmentCredentialVsphereCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof EnvironmentCredentialVsphereCreate
     */
    'name': string;
    /**
     * Vsphere username.
     * @type {string}
     * @memberof EnvironmentCredentialVsphereCreate
     */
    'username': string;
    /**
     * Vsphere password.
     * @type {string}
     * @memberof EnvironmentCredentialVsphereCreate
     */
    'password': string;
    /**
     * Vcenter hostname.
     * @type {string}
     * @memberof EnvironmentCredentialVsphereCreate
     */
    'vcenter': string;
    /**
     * Vcenter port.
     * @type {number}
     * @memberof EnvironmentCredentialVsphereCreate
     */
    'port': number;
    /**
     * Rancher environment credentials id.
     * @type {string}
     * @memberof EnvironmentCredentialVsphereCreate
     */
    'environmentCredentialRancher': string;
}
/**
 * Vsphere Environment Credentials
 * @export
 * @interface EnvironmentCredentialVsphereUpdate
 */
export interface EnvironmentCredentialVsphereUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof EnvironmentCredentialVsphereUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof EnvironmentCredentialVsphereUpdate
     */
    'name'?: string;
    /**
     * Vsphere username.
     * @type {string}
     * @memberof EnvironmentCredentialVsphereUpdate
     */
    'username'?: string;
    /**
     * Vsphere password.
     * @type {string}
     * @memberof EnvironmentCredentialVsphereUpdate
     */
    'password'?: string;
    /**
     * Vcenter hostname.
     * @type {string}
     * @memberof EnvironmentCredentialVsphereUpdate
     */
    'vcenter'?: string;
    /**
     * Vcenter port.
     * @type {number}
     * @memberof EnvironmentCredentialVsphereUpdate
     */
    'port'?: number;
    /**
     * Rancher environment credentials id.
     * @type {string}
     * @memberof EnvironmentCredentialVsphereUpdate
     */
    'environmentCredentialRancher'?: string;
}
/**
 * 
 * @export
 * @interface EnvironmentRancherCredentialList200Response
 */
export interface EnvironmentRancherCredentialList200Response {
    /**
     * 
     * @type {number}
     * @memberof EnvironmentRancherCredentialList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentRancherCredentialList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentRancherCredentialList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentRancherCredentialList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<EnvironmentCredentialRancher>}
     * @memberof EnvironmentRancherCredentialList200Response
     */
    'data'?: Array<EnvironmentCredentialRancher>;
}
/**
 * AWS Environment Specification
 * @export
 * @interface EnvironmentSpecificationAws
 */
export interface EnvironmentSpecificationAws {
    /**
     * 
     * @type {string}
     * @memberof EnvironmentSpecificationAws
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof EnvironmentSpecificationAws
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof EnvironmentSpecificationAws
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof EnvironmentSpecificationAws
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof EnvironmentSpecificationAws
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof EnvironmentSpecificationAws
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof EnvironmentSpecificationAws
     */
    'metadata'?: object;
    /**
     * The availability zone of the AWS environment.
     * @type {string}
     * @memberof EnvironmentSpecificationAws
     */
    'awsAvailabilityZone'?: string;
    /**
     * The region of the AWS environment.
     * @type {string}
     * @memberof EnvironmentSpecificationAws
     */
    'awsRegion'?: string;
}
/**
 * AWS Environment Specification
 * @export
 * @interface EnvironmentSpecificationAwsCreate
 */
export interface EnvironmentSpecificationAwsCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof EnvironmentSpecificationAwsCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof EnvironmentSpecificationAwsCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof EnvironmentSpecificationAwsCreate
     */
    'metadata'?: object;
    /**
     * The availability zone of the AWS environment.
     * @type {string}
     * @memberof EnvironmentSpecificationAwsCreate
     */
    'awsAvailabilityZone': string;
    /**
     * The region of the AWS environment.
     * @type {string}
     * @memberof EnvironmentSpecificationAwsCreate
     */
    'awsRegion': string;
}
/**
 * AWS Environment Specification
 * @export
 * @interface EnvironmentSpecificationAwsUpdate
 */
export interface EnvironmentSpecificationAwsUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof EnvironmentSpecificationAwsUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof EnvironmentSpecificationAwsUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof EnvironmentSpecificationAwsUpdate
     */
    'metadata'?: object;
    /**
     * The availability zone of the AWS environment.
     * @type {string}
     * @memberof EnvironmentSpecificationAwsUpdate
     */
    'awsAvailabilityZone'?: string;
    /**
     * The region of the AWS environment.
     * @type {string}
     * @memberof EnvironmentSpecificationAwsUpdate
     */
    'awsRegion'?: string;
}
/**
 * 
 * @export
 * @interface EnvironmentVsphereCredentialList200Response
 */
export interface EnvironmentVsphereCredentialList200Response {
    /**
     * 
     * @type {number}
     * @memberof EnvironmentVsphereCredentialList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentVsphereCredentialList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentVsphereCredentialList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof EnvironmentVsphereCredentialList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<EnvironmentCredentialVsphere>}
     * @memberof EnvironmentVsphereCredentialList200Response
     */
    'data'?: Array<EnvironmentCredentialVsphere>;
}
/**
 * 
 * @export
 * @interface EventNode
 */
export interface EventNode {
    /**
     * 
     * @type {string}
     * @memberof EventNode
     */
    'uuid'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof EventNode
     */
    'name'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof EventNode
     */
    'description'?: string;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<string>}
     * @memberof EventNode
     */
    'scenarioGroups'?: Array<EventNodeScenarioGroupsEnum>;
    /**
     * List of package IDs
     * @type {Array<string>}
     * @memberof EventNode
     */
    'packages': Array<string>;
    /**
     * List of sub events
     * @type {Array<EventNode>}
     * @memberof EventNode
     */
    'subEvents'?: Array<EventNode>;
}

export const EventNodeScenarioGroupsEnum = {
    BlueCell: 'blueCell',
    RedCell: 'redCell',
    WhiteCell: 'whiteCell',
    ScenarioAdmin: 'scenarioAdmin'
} as const;

export type EventNodeScenarioGroupsEnum = typeof EventNodeScenarioGroupsEnum[keyof typeof EventNodeScenarioGroupsEnum];

/**
 * 
 * @export
 * @interface EventNodeCreate
 */
export interface EventNodeCreate {
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof EventNodeCreate
     */
    'name': string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof EventNodeCreate
     */
    'description'?: string;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<string>}
     * @memberof EventNodeCreate
     */
    'scenarioGroups'?: Array<EventNodeCreateScenarioGroupsEnum>;
    /**
     * List of package IDs
     * @type {Array<string>}
     * @memberof EventNodeCreate
     */
    'packages': Array<string>;
    /**
     * List of sub events
     * @type {Array<EventNodeCreate>}
     * @memberof EventNodeCreate
     */
    'subEvents'?: Array<EventNodeCreate>;
}

export const EventNodeCreateScenarioGroupsEnum = {
    BlueCell: 'blueCell',
    RedCell: 'redCell',
    WhiteCell: 'whiteCell',
    ScenarioAdmin: 'scenarioAdmin'
} as const;

export type EventNodeCreateScenarioGroupsEnum = typeof EventNodeCreateScenarioGroupsEnum[keyof typeof EventNodeCreateScenarioGroupsEnum];

/**
 * 
 * @export
 * @interface EventNodeUpdate
 */
export interface EventNodeUpdate {
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof EventNodeUpdate
     */
    'name'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof EventNodeUpdate
     */
    'description'?: string;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<string>}
     * @memberof EventNodeUpdate
     */
    'scenarioGroups'?: Array<EventNodeUpdateScenarioGroupsEnum>;
    /**
     * List of package IDs
     * @type {Array<string>}
     * @memberof EventNodeUpdate
     */
    'packages': Array<string>;
    /**
     * List of sub events
     * @type {Array<EventNodeUpdate>}
     * @memberof EventNodeUpdate
     */
    'subEvents'?: Array<EventNodeUpdate>;
}

export const EventNodeUpdateScenarioGroupsEnum = {
    BlueCell: 'blueCell',
    RedCell: 'redCell',
    WhiteCell: 'whiteCell',
    ScenarioAdmin: 'scenarioAdmin'
} as const;

export type EventNodeUpdateScenarioGroupsEnum = typeof EventNodeUpdateScenarioGroupsEnum[keyof typeof EventNodeUpdateScenarioGroupsEnum];

/**
 * 
 * @export
 * @interface EventTree
 */
export interface EventTree {
    /**
     * 
     * @type {string}
     * @memberof EventTree
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof EventTree
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof EventTree
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof EventTree
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof EventTree
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof EventTree
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof EventTree
     */
    'metadata'?: object;
    /**
     * List of events
     * @type {Array<EventNode>}
     * @memberof EventTree
     */
    'events': Array<EventNode>;
}
/**
 * 
 * @export
 * @interface EventTreeCreate
 */
export interface EventTreeCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof EventTreeCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof EventTreeCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof EventTreeCreate
     */
    'metadata'?: object;
    /**
     * List of events
     * @type {Array<EventNodeCreate>}
     * @memberof EventTreeCreate
     */
    'events': Array<EventNodeCreate>;
}
/**
 * 
 * @export
 * @interface EventTreeUpdate
 */
export interface EventTreeUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof EventTreeUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof EventTreeUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof EventTreeUpdate
     */
    'metadata'?: object;
    /**
     * List of events
     * @type {Array<EventNodeUpdate>}
     * @memberof EventTreeUpdate
     */
    'events': Array<EventNodeUpdate>;
}
/**
 * 
 * @export
 * @interface EventTreesList200Response
 */
export interface EventTreesList200Response {
    /**
     * 
     * @type {number}
     * @memberof EventTreesList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof EventTreesList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof EventTreesList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof EventTreesList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<EventTree>}
     * @memberof EventTreesList200Response
     */
    'data'?: Array<EventTree>;
}
/**
 * 
 * @export
 * @interface Firmware
 */
export interface Firmware {
    /**
     * The VM image require EFI BIOS. Must be true if secureBoot is true.
     * @type {boolean}
     * @memberof Firmware
     */
    'efi'?: boolean;
    /**
     * The VM requires secure boot
     * @type {boolean}
     * @memberof Firmware
     */
    'secureBoot'?: boolean;
}
/**
 * 
 * @export
 * @interface GenericError
 */
export interface GenericError {
    [key: string]: any;

    /**
     * The error name
     * @type {string}
     * @memberof GenericError
     */
    'name': string;
    /**
     * An error message
     * @type {string}
     * @memberof GenericError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface GhostAgent
 */
export interface GhostAgent {
    /**
     * 
     * @type {string}
     * @memberof GhostAgent
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof GhostAgent
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof GhostAgent
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof GhostAgent
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof GhostAgent
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof GhostAgent
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof GhostAgent
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof GhostAgent
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * User that the ghost agent will run as
     * @type {string}
     * @memberof GhostAgent
     */
    'ghostUser'?: string;
    /**
     * Password of the user that the ghost agent will run as
     * @type {string}
     * @memberof GhostAgent
     */
    'ghostPassword'?: string;
    /**
     * Array of Parent Playbook UUIDs
     * @type {Array<string>}
     * @memberof GhostAgent
     */
    'parentPlaybooks'?: Array<string>;
    /**
     * Optional GhostC2Server, if not specified runtime control of the client is not possible
     * @type {string}
     * @memberof GhostAgent
     */
    'c2Server'?: string | null;
    /**
     * Optional traffic profile to execute on startup
     * @type {string}
     * @memberof GhostAgent
     */
    'profile'?: string | null;
    /**
     * The target Range VM
     * @type {string}
     * @memberof GhostAgent
     */
    'vmSpecification'?: string;
}
/**
 * 
 * @export
 * @interface GhostAgentCreate
 */
export interface GhostAgentCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof GhostAgentCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof GhostAgentCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof GhostAgentCreate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof GhostAgentCreate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * User that the ghost agent will run as
     * @type {string}
     * @memberof GhostAgentCreate
     */
    'ghostUser': string;
    /**
     * Password of the user that the ghost agent will run as
     * @type {string}
     * @memberof GhostAgentCreate
     */
    'ghostPassword': string;
    /**
     * Array of Parent Playbook UUIDs
     * @type {Array<string>}
     * @memberof GhostAgentCreate
     */
    'parentPlaybooks': Array<string>;
    /**
     * Optional GhostC2Server, if not specified runtime control of the client is not possible
     * @type {string}
     * @memberof GhostAgentCreate
     */
    'c2Server'?: string | null;
    /**
     * Optional traffic profile to execute on startup
     * @type {string}
     * @memberof GhostAgentCreate
     */
    'profile'?: string | null;
    /**
     * The target Range VM
     * @type {string}
     * @memberof GhostAgentCreate
     */
    'vmSpecification': string;
}
/**
 * 
 * @export
 * @interface GhostAgentOverride
 */
export interface GhostAgentOverride {
    /**
     * User provided metadata
     * @type {object}
     * @memberof GhostAgentOverride
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof GhostAgentOverride
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * User that the ghost agent will run as
     * @type {string}
     * @memberof GhostAgentOverride
     */
    'ghostUser'?: string;
    /**
     * Password of the user that the ghost agent will run as
     * @type {string}
     * @memberof GhostAgentOverride
     */
    'ghostPassword'?: string;
}
/**
 * 
 * @export
 * @interface GhostAgentUpdate
 */
export interface GhostAgentUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof GhostAgentUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof GhostAgentUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof GhostAgentUpdate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof GhostAgentUpdate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * User that the ghost agent will run as
     * @type {string}
     * @memberof GhostAgentUpdate
     */
    'ghostUser'?: string;
    /**
     * Password of the user that the ghost agent will run as
     * @type {string}
     * @memberof GhostAgentUpdate
     */
    'ghostPassword'?: string;
    /**
     * Array of Parent Playbook UUIDs
     * @type {Array<string>}
     * @memberof GhostAgentUpdate
     */
    'parentPlaybooks'?: Array<string>;
    /**
     * Optional GhostC2Server, if not specified runtime control of the client is not possible
     * @type {string}
     * @memberof GhostAgentUpdate
     */
    'c2Server'?: string | null;
    /**
     * Optional traffic profile to execute on startup
     * @type {string}
     * @memberof GhostAgentUpdate
     */
    'profile'?: string | null;
    /**
     * The target Range VM
     * @type {string}
     * @memberof GhostAgentUpdate
     */
    'vmSpecification'?: string;
}
/**
 * 
 * @export
 * @interface GhostAgentsList200Response
 */
export interface GhostAgentsList200Response {
    /**
     * 
     * @type {number}
     * @memberof GhostAgentsList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof GhostAgentsList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof GhostAgentsList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof GhostAgentsList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<GhostAgent>}
     * @memberof GhostAgentsList200Response
     */
    'data'?: Array<GhostAgent>;
}
/**
 * 
 * @export
 * @interface GhostBrowserConfig
 */
export interface GhostBrowserConfig {
    /**
     * Maximum number of requests to make when crawling
     * @type {number}
     * @memberof GhostBrowserConfig
     */
    'crawlTasksMaximum'?: number;
    /**
     * Determines how often the same site is visited in a row
     * @type {number}
     * @memberof GhostBrowserConfig
     */
    'stickiness'?: number;
    /**
     * Minimum number of requests to make on the same site
     * @type {number}
     * @memberof GhostBrowserConfig
     */
    'stickinessDepthMin'?: number;
    /**
     * Maximum number of requests to make on the same site
     * @type {number}
     * @memberof GhostBrowserConfig
     */
    'stickinessDepthMax'?: number;
    /**
     * Number of sites to remember that were previously visited; these will not be randomly chosen again
     * @type {number}
     * @memberof GhostBrowserConfig
     */
    'visitedRemember'?: number;
    /**
     * Restarts the browser process after navigating this many times (Windows clients only)
     * @type {number}
     * @memberof GhostBrowserConfig
     */
    'actionsBeforeRestart'?: number;
    /**
     * When true, the browser is started in incognito mode
     * @type {boolean}
     * @memberof GhostBrowserConfig
     */
    'incognito'?: boolean;
    /**
     * When true, styles are blocked
     * @type {boolean}
     * @memberof GhostBrowserConfig
     */
    'blockStyles'?: boolean;
    /**
     * When true, images are blocked
     * @type {boolean}
     * @memberof GhostBrowserConfig
     */
    'blockImages'?: boolean;
    /**
     * When true, flash is blocked
     * @type {boolean}
     * @memberof GhostBrowserConfig
     */
    'blockFlash'?: boolean;
    /**
     * When true, scripts are blocked
     * @type {boolean}
     * @memberof GhostBrowserConfig
     */
    'blockScripts'?: boolean;
    /**
     * When true, javascript is enabled in the webdriver. Must be true if using executeScript events
     * @type {boolean}
     * @memberof GhostBrowserConfig
     */
    'enableJavascript'?: boolean;
    /**
     * When true, the browser will be launched in headless (no-UI) mode. Must be true for containerized Ghost Clients
     * @type {boolean}
     * @memberof GhostBrowserConfig
     */
    'isHeadless'?: boolean;
}
/**
 * 
 * @export
 * @interface GhostBrowserEventBrowse
 */
export interface GhostBrowserEventBrowse {
    /**
     * Optional delay in milliseconds before executing the event
     * @type {number}
     * @memberof GhostBrowserEventBrowse
     */
    'delayBefore'?: number;
    /**
     * Optional delay in milliseconds after executing the event
     * @type {number}
     * @memberof GhostBrowserEventBrowse
     */
    'delayAfter'?: number;
    /**
     * 
     * @type {string}
     * @memberof GhostBrowserEventBrowse
     */
    'type': GhostBrowserEventBrowseTypeEnum;
    /**
     * Site to browse to
     * @type {string}
     * @memberof GhostBrowserEventBrowse
     */
    'site': string;
}

export const GhostBrowserEventBrowseTypeEnum = {
    Browse: 'browse',
    Crawl: 'crawl',
    Random: 'random',
    TypeKeys: 'typeKeys',
    Click: 'click',
    ExecuteScript: 'executeScript'
} as const;

export type GhostBrowserEventBrowseTypeEnum = typeof GhostBrowserEventBrowseTypeEnum[keyof typeof GhostBrowserEventBrowseTypeEnum];

/**
 * 
 * @export
 * @interface GhostBrowserEventClick
 */
export interface GhostBrowserEventClick {
    /**
     * Optional delay in milliseconds before executing the event
     * @type {number}
     * @memberof GhostBrowserEventClick
     */
    'delayBefore'?: number;
    /**
     * Optional delay in milliseconds after executing the event
     * @type {number}
     * @memberof GhostBrowserEventClick
     */
    'delayAfter'?: number;
    /**
     * 
     * @type {string}
     * @memberof GhostBrowserEventClick
     */
    'type': GhostBrowserEventClickTypeEnum;
    /**
     * Target of the element to click
     * @type {string}
     * @memberof GhostBrowserEventClick
     */
    'target': string;
    /**
     * Target type of the element
     * @type {string}
     * @memberof GhostBrowserEventClick
     */
    'targetType': GhostBrowserEventClickTargetTypeEnum;
}

export const GhostBrowserEventClickTypeEnum = {
    Browse: 'browse',
    Crawl: 'crawl',
    Random: 'random',
    TypeKeys: 'typeKeys',
    Click: 'click',
    ExecuteScript: 'executeScript'
} as const;

export type GhostBrowserEventClickTypeEnum = typeof GhostBrowserEventClickTypeEnum[keyof typeof GhostBrowserEventClickTypeEnum];
export const GhostBrowserEventClickTargetTypeEnum = {
    Name: 'name',
    Id: 'id',
    Cssselector: 'cssselector',
    Linktext: 'linktext'
} as const;

export type GhostBrowserEventClickTargetTypeEnum = typeof GhostBrowserEventClickTargetTypeEnum[keyof typeof GhostBrowserEventClickTargetTypeEnum];

/**
 * 
 * @export
 * @interface GhostBrowserEventCrawl
 */
export interface GhostBrowserEventCrawl {
    /**
     * Optional delay in milliseconds before executing the event
     * @type {number}
     * @memberof GhostBrowserEventCrawl
     */
    'delayBefore'?: number;
    /**
     * Optional delay in milliseconds after executing the event
     * @type {number}
     * @memberof GhostBrowserEventCrawl
     */
    'delayAfter'?: number;
    /**
     * 
     * @type {string}
     * @memberof GhostBrowserEventCrawl
     */
    'type': GhostBrowserEventCrawlTypeEnum;
    /**
     * List of sites to crawl
     * @type {Array<string>}
     * @memberof GhostBrowserEventCrawl
     */
    'sites': Array<string>;
}

export const GhostBrowserEventCrawlTypeEnum = {
    Browse: 'browse',
    Crawl: 'crawl',
    Random: 'random',
    TypeKeys: 'typeKeys',
    Click: 'click',
    ExecuteScript: 'executeScript'
} as const;

export type GhostBrowserEventCrawlTypeEnum = typeof GhostBrowserEventCrawlTypeEnum[keyof typeof GhostBrowserEventCrawlTypeEnum];

/**
 * 
 * @export
 * @interface GhostBrowserEventExecuteScript
 */
export interface GhostBrowserEventExecuteScript {
    /**
     * Optional delay in milliseconds before executing the event
     * @type {number}
     * @memberof GhostBrowserEventExecuteScript
     */
    'delayBefore'?: number;
    /**
     * Optional delay in milliseconds after executing the event
     * @type {number}
     * @memberof GhostBrowserEventExecuteScript
     */
    'delayAfter'?: number;
    /**
     * 
     * @type {string}
     * @memberof GhostBrowserEventExecuteScript
     */
    'type': GhostBrowserEventExecuteScriptTypeEnum;
    /**
     * Script contents
     * @type {string}
     * @memberof GhostBrowserEventExecuteScript
     */
    'script': string;
}

export const GhostBrowserEventExecuteScriptTypeEnum = {
    Browse: 'browse',
    Crawl: 'crawl',
    Random: 'random',
    TypeKeys: 'typeKeys',
    Click: 'click',
    ExecuteScript: 'executeScript'
} as const;

export type GhostBrowserEventExecuteScriptTypeEnum = typeof GhostBrowserEventExecuteScriptTypeEnum[keyof typeof GhostBrowserEventExecuteScriptTypeEnum];

/**
 * 
 * @export
 * @interface GhostBrowserEventRandom
 */
export interface GhostBrowserEventRandom {
    /**
     * Optional delay in milliseconds before executing the event
     * @type {number}
     * @memberof GhostBrowserEventRandom
     */
    'delayBefore'?: number;
    /**
     * Optional delay in milliseconds after executing the event
     * @type {number}
     * @memberof GhostBrowserEventRandom
     */
    'delayAfter'?: number;
    /**
     * 
     * @type {string}
     * @memberof GhostBrowserEventRandom
     */
    'type': GhostBrowserEventRandomTypeEnum;
    /**
     * List of sites to randomly browse to
     * @type {Array<string>}
     * @memberof GhostBrowserEventRandom
     */
    'sites': Array<string>;
}

export const GhostBrowserEventRandomTypeEnum = {
    Browse: 'browse',
    Crawl: 'crawl',
    Random: 'random',
    TypeKeys: 'typeKeys',
    Click: 'click',
    ExecuteScript: 'executeScript'
} as const;

export type GhostBrowserEventRandomTypeEnum = typeof GhostBrowserEventRandomTypeEnum[keyof typeof GhostBrowserEventRandomTypeEnum];

/**
 * 
 * @export
 * @interface GhostBrowserEventTypeKeys
 */
export interface GhostBrowserEventTypeKeys {
    /**
     * Optional delay in milliseconds before executing the event
     * @type {number}
     * @memberof GhostBrowserEventTypeKeys
     */
    'delayBefore'?: number;
    /**
     * Optional delay in milliseconds after executing the event
     * @type {number}
     * @memberof GhostBrowserEventTypeKeys
     */
    'delayAfter'?: number;
    /**
     * 
     * @type {string}
     * @memberof GhostBrowserEventTypeKeys
     */
    'type': GhostBrowserEventTypeKeysTypeEnum;
    /**
     * Target of the element to send keypresses to
     * @type {string}
     * @memberof GhostBrowserEventTypeKeys
     */
    'target': string;
    /**
     * Target type of the element
     * @type {string}
     * @memberof GhostBrowserEventTypeKeys
     */
    'targetType': GhostBrowserEventTypeKeysTargetTypeEnum;
    /**
     * Keys to send to the element
     * @type {string}
     * @memberof GhostBrowserEventTypeKeys
     */
    'keys': string;
}

export const GhostBrowserEventTypeKeysTypeEnum = {
    Browse: 'browse',
    Crawl: 'crawl',
    Random: 'random',
    TypeKeys: 'typeKeys',
    Click: 'click',
    ExecuteScript: 'executeScript'
} as const;

export type GhostBrowserEventTypeKeysTypeEnum = typeof GhostBrowserEventTypeKeysTypeEnum[keyof typeof GhostBrowserEventTypeKeysTypeEnum];
export const GhostBrowserEventTypeKeysTargetTypeEnum = {
    Name: 'name',
    Id: 'id'
} as const;

export type GhostBrowserEventTypeKeysTargetTypeEnum = typeof GhostBrowserEventTypeKeysTargetTypeEnum[keyof typeof GhostBrowserEventTypeKeysTargetTypeEnum];

/**
 * 
 * @export
 * @interface GhostC2Server
 */
export interface GhostC2Server {
    /**
     * 
     * @type {string}
     * @memberof GhostC2Server
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof GhostC2Server
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof GhostC2Server
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof GhostC2Server
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof GhostC2Server
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof GhostC2Server
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof GhostC2Server
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof GhostC2Server
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Hostname of the C2 server - must be unique in a scenario
     * @type {string}
     * @memberof GhostC2Server
     */
    'hostname'?: string;
    /**
     * Optional size of Ghost database
     * @type {string}
     * @memberof GhostC2Server
     */
    'storage'?: string;
}
/**
 * 
 * @export
 * @interface GhostC2ServerCreate
 */
export interface GhostC2ServerCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof GhostC2ServerCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof GhostC2ServerCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof GhostC2ServerCreate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof GhostC2ServerCreate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Hostname of the C2 server - must be unique in a scenario
     * @type {string}
     * @memberof GhostC2ServerCreate
     */
    'hostname': string;
    /**
     * Optional size of Ghost database
     * @type {string}
     * @memberof GhostC2ServerCreate
     */
    'storage'?: string;
}
/**
 * 
 * @export
 * @interface GhostC2ServerOverride
 */
export interface GhostC2ServerOverride {
    /**
     * User provided metadata
     * @type {object}
     * @memberof GhostC2ServerOverride
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof GhostC2ServerOverride
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Hostname of the C2 server - must be unique in a scenario
     * @type {string}
     * @memberof GhostC2ServerOverride
     */
    'hostname'?: string;
    /**
     * Optional size of Ghost database
     * @type {string}
     * @memberof GhostC2ServerOverride
     */
    'storage'?: string;
}
/**
 * 
 * @export
 * @interface GhostC2ServerUpdate
 */
export interface GhostC2ServerUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof GhostC2ServerUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof GhostC2ServerUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof GhostC2ServerUpdate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof GhostC2ServerUpdate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Hostname of the C2 server - must be unique in a scenario
     * @type {string}
     * @memberof GhostC2ServerUpdate
     */
    'hostname'?: string;
    /**
     * Optional size of Ghost database
     * @type {string}
     * @memberof GhostC2ServerUpdate
     */
    'storage'?: string;
}
/**
 * 
 * @export
 * @interface GhostC2ServersList200Response
 */
export interface GhostC2ServersList200Response {
    /**
     * 
     * @type {number}
     * @memberof GhostC2ServersList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof GhostC2ServersList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof GhostC2ServersList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof GhostC2ServersList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<GhostC2Server>}
     * @memberof GhostC2ServersList200Response
     */
    'data'?: Array<GhostC2Server>;
}
/**
 * 
 * @export
 * @interface GhostClient
 */
export interface GhostClient {
    /**
     * 
     * @type {string}
     * @memberof GhostClient
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof GhostClient
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof GhostClient
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof GhostClient
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof GhostClient
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof GhostClient
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof GhostClient
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof GhostClient
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Optional list of DNS nameserver IPs
     * @type {Array<string>}
     * @memberof GhostClient
     */
    'nameservers'?: Array<string>;
    /**
     * Optional GhostC2Server, if not specified runtime control of the client is not possible
     * @type {string}
     * @memberof GhostClient
     */
    'c2Server'?: string | null;
    /**
     * IP address of this client on the network - one of rangeIP or rangeAutoIP is required
     * @type {string}
     * @memberof GhostClient
     */
    'rangeIP'?: string | null;
    /**
     * IP address of this client on the network - one of rangeIP or rangeAutoIP is required
     * @type {string}
     * @memberof GhostClient
     */
    'rangeAutoIP'?: string | null;
    /**
     * Optional traffic profile to execute on startup
     * @type {string}
     * @memberof GhostClient
     */
    'profile'?: string | null;
}
/**
 * 
 * @export
 * @interface GhostClientCreate
 */
export interface GhostClientCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof GhostClientCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof GhostClientCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof GhostClientCreate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof GhostClientCreate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Optional list of DNS nameserver IPs
     * @type {Array<string>}
     * @memberof GhostClientCreate
     */
    'nameservers'?: Array<string>;
    /**
     * Optional GhostC2Server, if not specified runtime control of the client is not possible
     * @type {string}
     * @memberof GhostClientCreate
     */
    'c2Server'?: string | null;
    /**
     * IP address of this client on the network - one of rangeIP or rangeAutoIP is required
     * @type {string}
     * @memberof GhostClientCreate
     */
    'rangeIP'?: string | null;
    /**
     * IP address of this client on the network - one of rangeIP or rangeAutoIP is required
     * @type {string}
     * @memberof GhostClientCreate
     */
    'rangeAutoIP'?: string | null;
    /**
     * Optional traffic profile to execute on startup
     * @type {string}
     * @memberof GhostClientCreate
     */
    'profile'?: string | null;
}
/**
 * 
 * @export
 * @interface GhostClientOverride
 */
export interface GhostClientOverride {
    /**
     * User provided metadata
     * @type {object}
     * @memberof GhostClientOverride
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof GhostClientOverride
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Optional list of DNS nameserver IPs
     * @type {Array<string>}
     * @memberof GhostClientOverride
     */
    'nameservers'?: Array<string>;
}
/**
 * 
 * @export
 * @interface GhostClientUpdate
 */
export interface GhostClientUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof GhostClientUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof GhostClientUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof GhostClientUpdate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof GhostClientUpdate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Optional list of DNS nameserver IPs
     * @type {Array<string>}
     * @memberof GhostClientUpdate
     */
    'nameservers'?: Array<string>;
    /**
     * Optional GhostC2Server, if not specified runtime control of the client is not possible
     * @type {string}
     * @memberof GhostClientUpdate
     */
    'c2Server'?: string | null;
    /**
     * IP address of this client on the network - one of rangeIP or rangeAutoIP is required
     * @type {string}
     * @memberof GhostClientUpdate
     */
    'rangeIP'?: string | null;
    /**
     * IP address of this client on the network - one of rangeIP or rangeAutoIP is required
     * @type {string}
     * @memberof GhostClientUpdate
     */
    'rangeAutoIP'?: string | null;
    /**
     * Optional traffic profile to execute on startup
     * @type {string}
     * @memberof GhostClientUpdate
     */
    'profile'?: string | null;
}
/**
 * 
 * @export
 * @interface GhostClientsList200Response
 */
export interface GhostClientsList200Response {
    /**
     * 
     * @type {number}
     * @memberof GhostClientsList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof GhostClientsList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof GhostClientsList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof GhostClientsList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<GhostClient>}
     * @memberof GhostClientsList200Response
     */
    'data'?: Array<GhostClient>;
}
/**
 * 
 * @export
 * @interface GhostCommandConfig
 */
export interface GhostCommandConfig {
    /**
     * Probability between 0-100 that the given command will be executed
     * @type {number}
     * @memberof GhostCommandConfig
     */
    'executionProbability'?: number;
    /**
     * Amount of jitter percentage after a random command is selected/executed
     * @type {number}
     * @memberof GhostCommandConfig
     */
    'delayJitter'?: number;
}
/**
 * 
 * @export
 * @interface GhostCommandEvent
 */
export interface GhostCommandEvent {
    /**
     * Optional delay in milliseconds before executing the event
     * @type {number}
     * @memberof GhostCommandEvent
     */
    'delayBefore'?: number;
    /**
     * Optional delay in milliseconds after executing the event
     * @type {number}
     * @memberof GhostCommandEvent
     */
    'delayAfter'?: number;
    /**
     * One or more commands to execute in sequence
     * @type {Array<string>}
     * @memberof GhostCommandEvent
     */
    'shellCommands'?: Array<string>;
    /**
     * If true, a randomly selected command will be executed each loop; otherwise, all commands will be executed sequentially each loop
     * @type {boolean}
     * @memberof GhostCommandEvent
     */
    'random'?: boolean;
}
/**
 * 
 * @export
 * @interface GhostCurlCommand
 */
export interface GhostCurlCommand {
    /**
     * Optional delay in milliseconds before executing the event
     * @type {number}
     * @memberof GhostCurlCommand
     */
    'delayBefore'?: number;
    /**
     * Optional delay in milliseconds after executing the event
     * @type {number}
     * @memberof GhostCurlCommand
     */
    'delayAfter'?: number;
    /**
     * curl command arguments to execute (do not include `curl`)
     * @type {string}
     * @memberof GhostCurlCommand
     */
    'command'?: string;
}
/**
 * 
 * @export
 * @interface GhostCurlConfig
 */
export interface GhostCurlConfig {
    /**
     * Determines how often the same site is visited in a row
     * @type {number}
     * @memberof GhostCurlConfig
     */
    'stickiness'?: number;
    /**
     * Minimum number of requests to make on the same site
     * @type {number}
     * @memberof GhostCurlConfig
     */
    'stickinessDepthMin'?: number;
    /**
     * Maximum number of requests to make on the same site
     * @type {number}
     * @memberof GhostCurlConfig
     */
    'stickinessDepthMax'?: number;
}
/**
 * 
 * @export
 * @interface GhostDNSEvent
 */
export interface GhostDNSEvent {
    /**
     * Optional delay in milliseconds before executing the event
     * @type {number}
     * @memberof GhostDNSEvent
     */
    'delayBefore'?: number;
    /**
     * Optional delay in milliseconds after executing the event
     * @type {number}
     * @memberof GhostDNSEvent
     */
    'delayAfter'?: number;
    /**
     * Hostname to resolve
     * @type {string}
     * @memberof GhostDNSEvent
     */
    'hostname': string;
    /**
     * Optional specific nameserver to query
     * @type {string}
     * @memberof GhostDNSEvent
     */
    'nameserver'?: string;
    /**
     * Optional record type (default A)
     * @type {string}
     * @memberof GhostDNSEvent
     */
    'recordType'?: string;
}
/**
 * 
 * @export
 * @interface GhostICMPEvent
 */
export interface GhostICMPEvent {
    /**
     * Optional delay in milliseconds before executing the event
     * @type {number}
     * @memberof GhostICMPEvent
     */
    'delayBefore'?: number;
    /**
     * Optional delay in milliseconds after executing the event
     * @type {number}
     * @memberof GhostICMPEvent
     */
    'delayAfter'?: number;
    /**
     * Host to ping
     * @type {string}
     * @memberof GhostICMPEvent
     */
    'host': string;
    /**
     * Number of ICMP requests to send
     * @type {number}
     * @memberof GhostICMPEvent
     */
    'count'?: number;
    /**
     * Interval in seconds between requests
     * @type {number}
     * @memberof GhostICMPEvent
     */
    'interval'?: number;
    /**
     * Size of the ICMP request packet
     * @type {number}
     * @memberof GhostICMPEvent
     */
    'size'?: number;
}
/**
 * 
 * @export
 * @interface GhostMachine
 */
export interface GhostMachine {
    /**
     * The machine ID registered with the C2 server
     * @type {string}
     * @memberof GhostMachine
     */
    'uuid'?: string;
    /**
     * Ghost machine status condition
     * @type {string}
     * @memberof GhostMachine
     */
    'status'?: GhostMachineStatusEnum;
    /**
     * Last known status of the ghost machine
     * @type {string}
     * @memberof GhostMachine
     */
    'statusUp'?: GhostMachineStatusUpEnum;
    /**
     * A human readable status message of the ghost machine
     * @type {string}
     * @memberof GhostMachine
     */
    'message'?: string;
    /**
     * Ghost machine timeline status
     * @type {string}
     * @memberof GhostMachine
     */
    'timelineStatus'?: GhostMachineTimelineStatusEnum;
    /**
     * Date when the ghost machine first reported a status to the C2 server
     * @type {string}
     * @memberof GhostMachine
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof GhostMachine
     */
    'dateEdited'?: string;
    /**
     * Date when the ghost machine last reported a status to the C2 server
     * @type {string}
     * @memberof GhostMachine
     */
    'dateLastReported'?: string | null;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof GhostMachine
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof GhostMachine
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof GhostMachine
     */
    'metadata'?: object;
    /**
     * The Ghost C2 Server controlling this machine
     * @type {string}
     * @memberof GhostMachine
     */
    'c2Server'?: string;
    /**
     * The Ghost Traffic Profile published to this machine
     * @type {string}
     * @memberof GhostMachine
     */
    'profile'?: string;
    /**
     * If true, the current Ghost Traffic Profile is executing
     * @type {boolean}
     * @memberof GhostMachine
     */
    'running'?: boolean;
}

export const GhostMachineStatusEnum = {
    Unknown: 'Unknown',
    Ready: 'Ready',
    NotReady: 'NotReady',
    Creating: 'Creating',
    Error: 'Error',
    Deleting: 'Deleting',
    Stopped: 'Stopped',
    Active: 'Active',
    Deleted: 'Deleted'
} as const;

export type GhostMachineStatusEnum = typeof GhostMachineStatusEnum[keyof typeof GhostMachineStatusEnum];
export const GhostMachineStatusUpEnum = {
    Unknown: 'Unknown',
    Up: 'Up',
    UpWithErrors: 'UpWithErrors',
    Down: 'Down',
    DownWithErrors: 'DownWithErrors'
} as const;

export type GhostMachineStatusUpEnum = typeof GhostMachineStatusUpEnum[keyof typeof GhostMachineStatusUpEnum];
export const GhostMachineTimelineStatusEnum = {
    Unknown: 'unknown',
    Pending: 'pending',
    Accepted: 'accepted',
    Stopped: 'stopped'
} as const;

export type GhostMachineTimelineStatusEnum = typeof GhostMachineTimelineStatusEnum[keyof typeof GhostMachineTimelineStatusEnum];

/**
 * 
 * @export
 * @interface GhostOutlookEventCreate
 */
export interface GhostOutlookEventCreate {
    /**
     * Optional delay in milliseconds before executing the event
     * @type {number}
     * @memberof GhostOutlookEventCreate
     */
    'delayBefore'?: number;
    /**
     * Optional delay in milliseconds after executing the event
     * @type {number}
     * @memberof GhostOutlookEventCreate
     */
    'delayAfter'?: number;
    /**
     * 
     * @type {string}
     * @memberof GhostOutlookEventCreate
     */
    'type': GhostOutlookEventCreateTypeEnum;
    /**
     * A `from` email address. Note that if Outlook is not configured to use this email address, email may not be sent
     * @type {string}
     * @memberof GhostOutlookEventCreate
     */
    'from': string;
    /**
     * Zero or more `to` email addresses. A single value of `random` can also be given to select a random address.
     * @type {Array<string>}
     * @memberof GhostOutlookEventCreate
     */
    'to': Array<string>;
    /**
     * Zero or more `cc` email addresses. A single value of `random` can also be given to select a random address.
     * @type {Array<string>}
     * @memberof GhostOutlookEventCreate
     */
    'cc': Array<string>;
    /**
     * Zero or more `bcc` email addresses. A single value of `random` can also be given to select a random address.
     * @type {Array<string>}
     * @memberof GhostOutlookEventCreate
     */
    'bcc': Array<string>;
    /**
     * The subject of the email being sent. A value of `random` can also be given to assign a random subject.
     * @type {string}
     * @memberof GhostOutlookEventCreate
     */
    'subject': string;
    /**
     * The body of the email being sent. A value of `random` can also be given to assign a random body.
     * @type {string}
     * @memberof GhostOutlookEventCreate
     */
    'body': string;
    /**
     * The type of the body being sent.
     * @type {string}
     * @memberof GhostOutlookEventCreate
     */
    'bodyType': GhostOutlookEventCreateBodyTypeEnum;
}

export const GhostOutlookEventCreateTypeEnum = {
    Create: 'create',
    Reply: 'reply'
} as const;

export type GhostOutlookEventCreateTypeEnum = typeof GhostOutlookEventCreateTypeEnum[keyof typeof GhostOutlookEventCreateTypeEnum];
export const GhostOutlookEventCreateBodyTypeEnum = {
    PlainText: 'PlainText',
    Html: 'HTML',
    Rtf: 'RTF'
} as const;

export type GhostOutlookEventCreateBodyTypeEnum = typeof GhostOutlookEventCreateBodyTypeEnum[keyof typeof GhostOutlookEventCreateBodyTypeEnum];

/**
 * 
 * @export
 * @interface GhostOutlookEventReply
 */
export interface GhostOutlookEventReply {
    /**
     * Optional delay in milliseconds before executing the event
     * @type {number}
     * @memberof GhostOutlookEventReply
     */
    'delayBefore'?: number;
    /**
     * Optional delay in milliseconds after executing the event
     * @type {number}
     * @memberof GhostOutlookEventReply
     */
    'delayAfter'?: number;
    /**
     * 
     * @type {string}
     * @memberof GhostOutlookEventReply
     */
    'type': GhostOutlookEventReplyTypeEnum;
    /**
     * A `from` email address. Note that if Outlook is not configured to use this email address, email may not be sent
     * @type {string}
     * @memberof GhostOutlookEventReply
     */
    'from': string;
    /**
     * Zero or more `to` email addresses. A single value of `all` can also be given to reply to all addresses on the original thread.
     * @type {Array<string>}
     * @memberof GhostOutlookEventReply
     */
    'to': Array<string>;
    /**
     * Zero or more `cc` email addresses. A single value of `all` can also be given to reply to all addresses on the original thread.
     * @type {Array<string>}
     * @memberof GhostOutlookEventReply
     */
    'cc': Array<string>;
    /**
     * Zero or more `bcc` email addresses. A single value of `all` can also be given to reply to all addresses on the original thread.
     * @type {Array<string>}
     * @memberof GhostOutlookEventReply
     */
    'bcc': Array<string>;
    /**
     * The subject of the email being sent. A value of `parent` can be given to assign a subject in the format \"RE: (original subject)\".
     * @type {string}
     * @memberof GhostOutlookEventReply
     */
    'subject': string;
    /**
     * The body of the email being sent. A value of `random+parent` can also be given to assign a random reply.
     * @type {string}
     * @memberof GhostOutlookEventReply
     */
    'body': string;
    /**
     * The type of the body being sent. A value of `parent` can be used to reply with the original message type
     * @type {string}
     * @memberof GhostOutlookEventReply
     */
    'bodyType': GhostOutlookEventReplyBodyTypeEnum;
}

export const GhostOutlookEventReplyTypeEnum = {
    Create: 'create',
    Reply: 'reply'
} as const;

export type GhostOutlookEventReplyTypeEnum = typeof GhostOutlookEventReplyTypeEnum[keyof typeof GhostOutlookEventReplyTypeEnum];
export const GhostOutlookEventReplyBodyTypeEnum = {
    Parent: 'parent',
    PlainText: 'PlainText',
    Html: 'HTML',
    Rtf: 'RTF'
} as const;

export type GhostOutlookEventReplyBodyTypeEnum = typeof GhostOutlookEventReplyBodyTypeEnum[keyof typeof GhostOutlookEventReplyBodyTypeEnum];

/**
 * 
 * @export
 * @interface GhostSFTPCommand
 */
export interface GhostSFTPCommand {
    /**
     * Hostname/IP to connect to
     * @type {string}
     * @memberof GhostSFTPCommand
     */
    'hostname': string;
    /**
     * Username of a valid SFTP user
     * @type {string}
     * @memberof GhostSFTPCommand
     */
    'username': string;
    /**
     * Password of a valid SFTP user
     * @type {string}
     * @memberof GhostSFTPCommand
     */
    'password': string;
    /**
     * One or more SFTP commands to execute after authenticating. Supported commands include: get, put, cd, rm, ls, mkdir. See https://cmu-sei.github.io/GHOSTS/core/handlers/sftp/ for more information.
     * @type {Array<string>}
     * @memberof GhostSFTPCommand
     */
    'commands': Array<string>;
}
/**
 * 
 * @export
 * @interface GhostSFTPConfig
 */
export interface GhostSFTPConfig {
    /**
     * Minimum number of milliseconds between commands
     * @type {number}
     * @memberof GhostSFTPConfig
     */
    'timeBetweenCommandsMin'?: number;
    /**
     * Maximum number of milliseconds between commands
     * @type {number}
     * @memberof GhostSFTPConfig
     */
    'timeBetweenCommandsMax'?: number;
    /**
     * Amount of jitter percentage after a random command is selected/executed
     * @type {number}
     * @memberof GhostSFTPConfig
     */
    'delayJitter'?: number;
}
/**
 * 
 * @export
 * @interface GhostSFTPEvent
 */
export interface GhostSFTPEvent {
    /**
     * Optional delay in milliseconds before executing the event
     * @type {number}
     * @memberof GhostSFTPEvent
     */
    'delayBefore'?: number;
    /**
     * Optional delay in milliseconds after executing the event
     * @type {number}
     * @memberof GhostSFTPEvent
     */
    'delayAfter'?: number;
    /**
     * One or more SFTP commands
     * @type {Array<GhostSFTPCommand>}
     * @memberof GhostSFTPEvent
     */
    'sftp'?: Array<GhostSFTPCommand>;
}
/**
 * 
 * @export
 * @interface GhostTraffic
 */
export interface GhostTraffic {
    /**
     * 
     * @type {string}
     * @memberof GhostTraffic
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof GhostTraffic
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof GhostTraffic
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof GhostTraffic
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof GhostTraffic
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof GhostTraffic
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof GhostTraffic
     */
    'metadata'?: object;
    /**
     * Optional JSON Schema for template parameters. Use the extension \'x-replace\' to set a JSON Pointer to a field to replace relative to the \'type\' field (ex. \"/events/0/site\")
     * @type {object}
     * @memberof GhostTraffic
     */
    'schema'?: object | null;
    /**
     * 
     * @type {GhostTrafficType}
     * @memberof GhostTraffic
     */
    'type': GhostTrafficType;
}
/**
 * 
 * @export
 * @interface GhostTrafficBrowser
 */
export interface GhostTrafficBrowser {
    /**
     * 
     * @type {string}
     * @memberof GhostTrafficBrowser
     */
    'handler': GhostTrafficBrowserHandlerEnum;
    /**
     * Start time of the traffic
     * @type {string}
     * @memberof GhostTrafficBrowser
     */
    'timeStart': string;
    /**
     * End time of the traffic
     * @type {string}
     * @memberof GhostTrafficBrowser
     */
    'timeEnd': string;
    /**
     * If true, the traffic patterns repeat until the end time is reached; otherwise, the sequence of events executes only once
     * @type {boolean}
     * @memberof GhostTrafficBrowser
     */
    'loop': boolean;
    /**
     * 
     * @type {GhostBrowserConfig}
     * @memberof GhostTrafficBrowser
     */
    'config'?: GhostBrowserConfig;
    /**
     * Browser to use
     * @type {string}
     * @memberof GhostTrafficBrowser
     */
    'browserType': GhostTrafficBrowserBrowserTypeEnum;
    /**
     * Sequence of events to execute
     * @type {Array<GhostTrafficBrowserEventsInner>}
     * @memberof GhostTrafficBrowser
     */
    'events': Array<GhostTrafficBrowserEventsInner>;
}

export const GhostTrafficBrowserHandlerEnum = {
    Browser: 'browser',
    Curl: 'curl',
    Command: 'command',
    Dns: 'dns',
    Icmp: 'icmp',
    Sftp: 'sftp',
    Outlook: 'outlook'
} as const;

export type GhostTrafficBrowserHandlerEnum = typeof GhostTrafficBrowserHandlerEnum[keyof typeof GhostTrafficBrowserHandlerEnum];
export const GhostTrafficBrowserBrowserTypeEnum = {
    Chrome: 'chrome',
    Firefox: 'firefox'
} as const;

export type GhostTrafficBrowserBrowserTypeEnum = typeof GhostTrafficBrowserBrowserTypeEnum[keyof typeof GhostTrafficBrowserBrowserTypeEnum];

/**
 * @type GhostTrafficBrowserEventsInner
 * @export
 */
export type GhostTrafficBrowserEventsInner = GhostBrowserEventBrowse | GhostBrowserEventClick | GhostBrowserEventCrawl | GhostBrowserEventExecuteScript | GhostBrowserEventRandom | GhostBrowserEventTypeKeys;

/**
 * 
 * @export
 * @interface GhostTrafficCommand
 */
export interface GhostTrafficCommand {
    /**
     * 
     * @type {string}
     * @memberof GhostTrafficCommand
     */
    'handler': GhostTrafficCommandHandlerEnum;
    /**
     * Start time of the traffic
     * @type {string}
     * @memberof GhostTrafficCommand
     */
    'timeStart': string;
    /**
     * End time of the traffic
     * @type {string}
     * @memberof GhostTrafficCommand
     */
    'timeEnd': string;
    /**
     * If true, the traffic patterns repeat until the end time is reached; otherwise, the sequence of events executes only once
     * @type {boolean}
     * @memberof GhostTrafficCommand
     */
    'loop': boolean;
    /**
     * 
     * @type {GhostCommandConfig}
     * @memberof GhostTrafficCommand
     */
    'config'?: GhostCommandConfig;
    /**
     * Sequence of commands to execute
     * @type {Array<GhostCommandEvent>}
     * @memberof GhostTrafficCommand
     */
    'events': Array<GhostCommandEvent>;
}

export const GhostTrafficCommandHandlerEnum = {
    Browser: 'browser',
    Curl: 'curl',
    Command: 'command',
    Dns: 'dns',
    Icmp: 'icmp',
    Sftp: 'sftp',
    Outlook: 'outlook'
} as const;

export type GhostTrafficCommandHandlerEnum = typeof GhostTrafficCommandHandlerEnum[keyof typeof GhostTrafficCommandHandlerEnum];

/**
 * 
 * @export
 * @interface GhostTrafficCreate
 */
export interface GhostTrafficCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof GhostTrafficCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof GhostTrafficCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof GhostTrafficCreate
     */
    'metadata'?: object;
    /**
     * Optional JSON Schema for template parameters. Use the extension \'x-replace\' to set a JSON Pointer to a field to replace relative to the \'type\' field (ex. \"/events/0/site\")
     * @type {object}
     * @memberof GhostTrafficCreate
     */
    'schema'?: object | null;
    /**
     * 
     * @type {GhostTrafficType}
     * @memberof GhostTrafficCreate
     */
    'type': GhostTrafficType;
}
/**
 * 
 * @export
 * @interface GhostTrafficCurl
 */
export interface GhostTrafficCurl {
    /**
     * 
     * @type {string}
     * @memberof GhostTrafficCurl
     */
    'handler': GhostTrafficCurlHandlerEnum;
    /**
     * Start time of the traffic
     * @type {string}
     * @memberof GhostTrafficCurl
     */
    'timeStart': string;
    /**
     * End time of the traffic
     * @type {string}
     * @memberof GhostTrafficCurl
     */
    'timeEnd': string;
    /**
     * If true, the traffic patterns repeat until the end time is reached; otherwise, the sequence of events executes only once
     * @type {boolean}
     * @memberof GhostTrafficCurl
     */
    'loop': boolean;
    /**
     * 
     * @type {GhostCurlConfig}
     * @memberof GhostTrafficCurl
     */
    'config'?: GhostCurlConfig;
    /**
     * Sequence of curl commands to execute
     * @type {Array<GhostCurlCommand>}
     * @memberof GhostTrafficCurl
     */
    'commands': Array<GhostCurlCommand>;
}

export const GhostTrafficCurlHandlerEnum = {
    Browser: 'browser',
    Curl: 'curl',
    Command: 'command',
    Dns: 'dns',
    Icmp: 'icmp',
    Sftp: 'sftp',
    Outlook: 'outlook'
} as const;

export type GhostTrafficCurlHandlerEnum = typeof GhostTrafficCurlHandlerEnum[keyof typeof GhostTrafficCurlHandlerEnum];

/**
 * A simplified wrapper around the GhostTrafficCommand type that executes the dig command line tool
 * @export
 * @interface GhostTrafficDNS
 */
export interface GhostTrafficDNS {
    /**
     * 
     * @type {string}
     * @memberof GhostTrafficDNS
     */
    'handler': GhostTrafficDNSHandlerEnum;
    /**
     * Start time of the traffic
     * @type {string}
     * @memberof GhostTrafficDNS
     */
    'timeStart': string;
    /**
     * End time of the traffic
     * @type {string}
     * @memberof GhostTrafficDNS
     */
    'timeEnd': string;
    /**
     * If true, the traffic patterns repeat until the end time is reached; otherwise, the sequence of events executes only once
     * @type {boolean}
     * @memberof GhostTrafficDNS
     */
    'loop': boolean;
    /**
     * Sequence of DNS queries to execute
     * @type {Array<GhostDNSEvent>}
     * @memberof GhostTrafficDNS
     */
    'events': Array<GhostDNSEvent>;
}

export const GhostTrafficDNSHandlerEnum = {
    Browser: 'browser',
    Curl: 'curl',
    Command: 'command',
    Dns: 'dns',
    Icmp: 'icmp',
    Sftp: 'sftp',
    Outlook: 'outlook'
} as const;

export type GhostTrafficDNSHandlerEnum = typeof GhostTrafficDNSHandlerEnum[keyof typeof GhostTrafficDNSHandlerEnum];

/**
 * 
 * @export
 * @interface GhostTrafficDetails
 */
export interface GhostTrafficDetails {
    /**
     * User provided parameters for a specific Ghost Traffic Profile
     * @type {object}
     * @memberof GhostTrafficDetails
     */
    'parameters'?: object | null;
    /**
     * ID of the Ghost Traffic
     * @type {string}
     * @memberof GhostTrafficDetails
     */
    'ghostTraffic': string;
}
/**
 * A simplified wrapper around the GhostTrafficCommand type that executes the ping command line tool
 * @export
 * @interface GhostTrafficICMP
 */
export interface GhostTrafficICMP {
    /**
     * 
     * @type {string}
     * @memberof GhostTrafficICMP
     */
    'handler': GhostTrafficICMPHandlerEnum;
    /**
     * Start time of the traffic
     * @type {string}
     * @memberof GhostTrafficICMP
     */
    'timeStart': string;
    /**
     * End time of the traffic
     * @type {string}
     * @memberof GhostTrafficICMP
     */
    'timeEnd': string;
    /**
     * If true, the traffic patterns repeat until the end time is reached; otherwise, the sequence of events executes only once
     * @type {boolean}
     * @memberof GhostTrafficICMP
     */
    'loop': boolean;
    /**
     * Sequence of ICMP queries to execute
     * @type {Array<GhostICMPEvent>}
     * @memberof GhostTrafficICMP
     */
    'events': Array<GhostICMPEvent>;
}

export const GhostTrafficICMPHandlerEnum = {
    Browser: 'browser',
    Curl: 'curl',
    Command: 'command',
    Dns: 'dns',
    Icmp: 'icmp',
    Sftp: 'sftp',
    Outlook: 'outlook'
} as const;

export type GhostTrafficICMPHandlerEnum = typeof GhostTrafficICMPHandlerEnum[keyof typeof GhostTrafficICMPHandlerEnum];

/**
 * 
 * @export
 * @interface GhostTrafficList200Response
 */
export interface GhostTrafficList200Response {
    /**
     * 
     * @type {number}
     * @memberof GhostTrafficList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof GhostTrafficList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof GhostTrafficList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof GhostTrafficList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<GhostTraffic>}
     * @memberof GhostTrafficList200Response
     */
    'data'?: Array<GhostTraffic>;
}
/**
 * Controls a Microsoft Outlook desktop application. NOTE: This traffic type only functions on Windows host-based Ghost clients with all requirements met. See https://cmu-sei.github.io/GHOSTS/core/client/#windows-installation for more information.
 * @export
 * @interface GhostTrafficOutlook
 */
export interface GhostTrafficOutlook {
    /**
     * 
     * @type {string}
     * @memberof GhostTrafficOutlook
     */
    'handler': GhostTrafficOutlookHandlerEnum;
    /**
     * Start time of the traffic
     * @type {string}
     * @memberof GhostTrafficOutlook
     */
    'timeStart': string;
    /**
     * End time of the traffic
     * @type {string}
     * @memberof GhostTrafficOutlook
     */
    'timeEnd': string;
    /**
     * If true, the traffic patterns repeat until the end time is reached; otherwise, the sequence of events executes only once
     * @type {boolean}
     * @memberof GhostTrafficOutlook
     */
    'loop': boolean;
    /**
     * Sequence of Outlook events to execute
     * @type {Array<GhostTrafficOutlookEventsInner>}
     * @memberof GhostTrafficOutlook
     */
    'events': Array<GhostTrafficOutlookEventsInner>;
}

export const GhostTrafficOutlookHandlerEnum = {
    Browser: 'browser',
    Curl: 'curl',
    Command: 'command',
    Dns: 'dns',
    Icmp: 'icmp',
    Sftp: 'sftp',
    Outlook: 'outlook'
} as const;

export type GhostTrafficOutlookHandlerEnum = typeof GhostTrafficOutlookHandlerEnum[keyof typeof GhostTrafficOutlookHandlerEnum];

/**
 * @type GhostTrafficOutlookEventsInner
 * @export
 */
export type GhostTrafficOutlookEventsInner = GhostOutlookEventCreate | GhostOutlookEventReply;

/**
 * 
 * @export
 * @interface GhostTrafficProfile
 */
export interface GhostTrafficProfile {
    /**
     * 
     * @type {string}
     * @memberof GhostTrafficProfile
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof GhostTrafficProfile
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof GhostTrafficProfile
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof GhostTrafficProfile
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof GhostTrafficProfile
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof GhostTrafficProfile
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof GhostTrafficProfile
     */
    'metadata'?: object;
    /**
     * Array of Ghost Traffic Details
     * @type {Array<GhostTrafficDetails>}
     * @memberof GhostTrafficProfile
     */
    'trafficDetails'?: Array<GhostTrafficDetails>;
}
/**
 * 
 * @export
 * @interface GhostTrafficProfileCreate
 */
export interface GhostTrafficProfileCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof GhostTrafficProfileCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof GhostTrafficProfileCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof GhostTrafficProfileCreate
     */
    'metadata'?: object;
    /**
     * Array of Ghost Traffic Details
     * @type {Array<GhostTrafficDetails>}
     * @memberof GhostTrafficProfileCreate
     */
    'trafficDetails': Array<GhostTrafficDetails>;
}
/**
 * 
 * @export
 * @interface GhostTrafficProfileList200Response
 */
export interface GhostTrafficProfileList200Response {
    /**
     * 
     * @type {number}
     * @memberof GhostTrafficProfileList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof GhostTrafficProfileList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof GhostTrafficProfileList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof GhostTrafficProfileList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<GhostTrafficProfile>}
     * @memberof GhostTrafficProfileList200Response
     */
    'data'?: Array<GhostTrafficProfile>;
}
/**
 * 
 * @export
 * @interface GhostTrafficProfileOverride
 */
export interface GhostTrafficProfileOverride {
    /**
     * User provided metadata
     * @type {object}
     * @memberof GhostTrafficProfileOverride
     */
    'metadata'?: object;
}
/**
 * 
 * @export
 * @interface GhostTrafficProfileUpdate
 */
export interface GhostTrafficProfileUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof GhostTrafficProfileUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof GhostTrafficProfileUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof GhostTrafficProfileUpdate
     */
    'metadata'?: object;
    /**
     * Array of Ghost Traffic Details
     * @type {Array<GhostTrafficDetails>}
     * @memberof GhostTrafficProfileUpdate
     */
    'trafficDetails'?: Array<GhostTrafficDetails>;
}
/**
 * 
 * @export
 * @interface GhostTrafficSFTP
 */
export interface GhostTrafficSFTP {
    /**
     * 
     * @type {string}
     * @memberof GhostTrafficSFTP
     */
    'handler': GhostTrafficSFTPHandlerEnum;
    /**
     * Start time of the traffic
     * @type {string}
     * @memberof GhostTrafficSFTP
     */
    'timeStart': string;
    /**
     * End time of the traffic
     * @type {string}
     * @memberof GhostTrafficSFTP
     */
    'timeEnd': string;
    /**
     * If true, the traffic patterns repeat until the end time is reached; otherwise, the sequence of events executes only once
     * @type {boolean}
     * @memberof GhostTrafficSFTP
     */
    'loop': boolean;
    /**
     * 
     * @type {GhostSFTPConfig}
     * @memberof GhostTrafficSFTP
     */
    'config'?: GhostSFTPConfig;
    /**
     * Sequence of SFTP events to execute
     * @type {Array<GhostSFTPEvent>}
     * @memberof GhostTrafficSFTP
     */
    'events': Array<GhostSFTPEvent>;
}

export const GhostTrafficSFTPHandlerEnum = {
    Browser: 'browser',
    Curl: 'curl',
    Command: 'command',
    Dns: 'dns',
    Icmp: 'icmp',
    Sftp: 'sftp',
    Outlook: 'outlook'
} as const;

export type GhostTrafficSFTPHandlerEnum = typeof GhostTrafficSFTPHandlerEnum[keyof typeof GhostTrafficSFTPHandlerEnum];

/**
 * @type GhostTrafficType
 * Type of ghost traffic
 * @export
 */
export type GhostTrafficType = GhostTrafficBrowser | GhostTrafficCommand | GhostTrafficCurl | GhostTrafficDNS | GhostTrafficICMP | GhostTrafficOutlook | GhostTrafficSFTP;

/**
 * 
 * @export
 * @interface GhostTrafficUpdate
 */
export interface GhostTrafficUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof GhostTrafficUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof GhostTrafficUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof GhostTrafficUpdate
     */
    'metadata'?: object;
    /**
     * Optional JSON Schema for template parameters. Use the extension \'x-replace\' to set a JSON Pointer to a field to replace relative to the \'type\' field (ex. \"/events/0/site\")
     * @type {object}
     * @memberof GhostTrafficUpdate
     */
    'schema'?: object | null;
    /**
     * 
     * @type {GhostTrafficType}
     * @memberof GhostTrafficUpdate
     */
    'type': GhostTrafficType;
}
/**
 * 
 * @export
 * @interface GuacamoleConnectionDetails
 */
export interface GuacamoleConnectionDetails {
    /**
     * Identifier of the data source used to authenticate the current user
     * @type {string}
     * @memberof GuacamoleConnectionDetails
     */
    'dataSource'?: string;
    /**
     * Type of the connection. Currently one of \"c\" (connection), \"g\" (connection group), \"a\" (active connection)
     * @type {string}
     * @memberof GuacamoleConnectionDetails
     */
    'connectionType'?: string;
    /**
     * Unique connection identifier
     * @type {string}
     * @memberof GuacamoleConnectionDetails
     */
    'connectionId'?: string;
    /**
     * URL hash containing the encoded dataSource, connectionType, and connectionId
     * @type {string}
     * @memberof GuacamoleConnectionDetails
     */
    'urlHash'?: string;
}
/**
 * 
 * @export
 * @interface GuacamoleConnectionParameters
 */
export interface GuacamoleConnectionParameters {
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'hostKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'backspace'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'caCert'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'clientCert'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'clientKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'clipboardEncoding'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'colorDepth'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'colorScheme'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'command'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'console'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'consoleAudio'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'container'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'createDrivePath'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'drivePath'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'createRecordingPath'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'createTypescriptPath'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'cursor'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'destPort'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'disableAudio'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'disableAuth'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'disableBitmapCaching'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'disableGlyphCaching'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'disableOffscreenCaching'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'domain'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'dpi'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'enableAudio'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'enableAudioInput'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'enableDesktopComposition'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'enableDrive'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'enableFontSmoothing'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'enableFullWindowDrag'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'enableMenuAnimations'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'enablePrinting'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'enableSftp'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'enableTheming'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'enableWallpaper'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'execCommand'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'fontSize'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'gatewayPort'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'height'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'hostname'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'ignoreCert'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'namespace'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'passphrase'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'passwordRegex'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'pod'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'port'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'preconnectionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'privateKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'readOnly'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'recordingExcludeMouse'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'recordingExcludeOutput'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'recordingIncludeKeys'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'resizeMethod'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'security'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'serverAliveInterval'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'serverLayout'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'sftpPort'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'sftpServerAliveInterval'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'swapRedBlue'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'terminalType'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'typescriptName'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'typescriptPayh'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'useSsl'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuacamoleConnectionParameters
     */
    'width'?: string;
}
/**
 * 
 * @export
 * @interface GuacamoleUserApi
 */
export interface GuacamoleUserApi {
    /**
     * Username
     * @type {string}
     * @memberof GuacamoleUserApi
     */
    'username'?: string;
    /**
     * Password
     * @type {string}
     * @memberof GuacamoleUserApi
     */
    'password'?: string;
    /**
     * Scenario
     * @type {string}
     * @memberof GuacamoleUserApi
     */
    'scenarioUUID'?: string;
}
/**
 * 
 * @export
 * @interface Hardware
 */
export interface Hardware {
    /**
     * Min Number of CPU cores Image needs to run.
     * @type {number}
     * @memberof Hardware
     */
    'minimumCpuCores': number;
    /**
     * Min Memory the Image needs to run.
     * @type {string}
     * @memberof Hardware
     */
    'minimumMemory': string;
    /**
     * Min Storage Image needs to run.
     * @type {string}
     * @memberof Hardware
     */
    'minimumStorage': string;
}
/**
 * Modify In-Range Range Console
 * @export
 * @interface InRangeRangeConsoleUpdate
 */
export interface InRangeRangeConsoleUpdate {
    /**
     * Group array
     * @type {Array<string>}
     * @memberof InRangeRangeConsoleUpdate
     */
    'groups'?: Array<string>;
}
/**
 * Optional input device type, defaults to usb
 * @export
 * @enum {string}
 */

export const InputDeviceType = {
    Usb: 'usb',
    Virtio: 'virtio',
    None: 'none'
} as const;

export type InputDeviceType = typeof InputDeviceType[keyof typeof InputDeviceType];


/**
 * 
 * @export
 * @interface InternetGateway
 */
export interface InternetGateway {
    /**
     * 
     * @type {string}
     * @memberof InternetGateway
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof InternetGateway
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof InternetGateway
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof InternetGateway
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof InternetGateway
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof InternetGateway
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof InternetGateway
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof InternetGateway
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Labels used to select a ClusterRangeNetwork. Keys must be valid qualified names no longer than 63 characters matching the regex /([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]/, with an optional RFC1123 DNS subdomain prefix no longer than 253 characters matching the regex /^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$/ followed by a \'/\'. Values must be match the regex /^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$/ and be no longer than 63 characters.
     * @type {{ [key: string]: string; }}
     * @memberof InternetGateway
     */
    'labels'?: { [key: string]: string; };
    /**
     * IP address of the internet gateway on the network
     * @type {string}
     * @memberof InternetGateway
     */
    'rangeIP'?: string;
}
/**
 * 
 * @export
 * @interface InternetGatewayCreate
 */
export interface InternetGatewayCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof InternetGatewayCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof InternetGatewayCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof InternetGatewayCreate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof InternetGatewayCreate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Labels used to select a ClusterRangeNetwork. Keys must be valid qualified names no longer than 63 characters matching the regex /([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]/, with an optional RFC1123 DNS subdomain prefix no longer than 253 characters matching the regex /^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$/ followed by a \'/\'. Values must be match the regex /^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$/ and be no longer than 63 characters.
     * @type {{ [key: string]: string; }}
     * @memberof InternetGatewayCreate
     */
    'labels': { [key: string]: string; };
    /**
     * IP address of the internet gateway on the network
     * @type {string}
     * @memberof InternetGatewayCreate
     */
    'rangeIP': string;
}
/**
 * 
 * @export
 * @interface InternetGatewayOverride
 */
export interface InternetGatewayOverride {
    /**
     * User provided metadata
     * @type {object}
     * @memberof InternetGatewayOverride
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof InternetGatewayOverride
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
}
/**
 * 
 * @export
 * @interface InternetGatewayUpdate
 */
export interface InternetGatewayUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof InternetGatewayUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof InternetGatewayUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof InternetGatewayUpdate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof InternetGatewayUpdate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Labels used to select a ClusterRangeNetwork. Keys must be valid qualified names no longer than 63 characters matching the regex /([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]/, with an optional RFC1123 DNS subdomain prefix no longer than 253 characters matching the regex /^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$/ followed by a \'/\'. Values must be match the regex /^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$/ and be no longer than 63 characters.
     * @type {{ [key: string]: string; }}
     * @memberof InternetGatewayUpdate
     */
    'labels'?: { [key: string]: string; };
    /**
     * IP address of the internet gateway on the network
     * @type {string}
     * @memberof InternetGatewayUpdate
     */
    'rangeIP'?: string;
}
/**
 * 
 * @export
 * @interface InternetGatewaysList200Response
 */
export interface InternetGatewaysList200Response {
    /**
     * 
     * @type {number}
     * @memberof InternetGatewaysList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof InternetGatewaysList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof InternetGatewaysList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof InternetGatewaysList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<InternetGateway>}
     * @memberof InternetGatewaysList200Response
     */
    'data'?: Array<InternetGateway>;
}
/**
 * 
 * @export
 * @interface KeyRequest
 */
export interface KeyRequest {
    /**
     * The key algorithm for the newly generated private key, if non-default value provided then the key size must be provided as well
     * @type {string}
     * @memberof KeyRequest
     */
    'algo': KeyRequestAlgoEnum;
    /**
     * The key size for the newly generated private key - For rsa: Accepts exact sizes [2048, 4096, 8192] - For ecdsa: Accepts exact sizes [256, 384, 521] - For ed25519: Accepts exact size [256]
     * @type {number}
     * @memberof KeyRequest
     */
    'size': number;
}

export const KeyRequestAlgoEnum = {
    Rsa: 'rsa',
    Ecdsa: 'ecdsa',
    Ed25519: 'ed25519'
} as const;

export type KeyRequestAlgoEnum = typeof KeyRequestAlgoEnum[keyof typeof KeyRequestAlgoEnum];

/**
 * 
 * @export
 * @interface KeycloakListAllKeycloakGroups200Response
 */
export interface KeycloakListAllKeycloakGroups200Response {
    /**
     * 
     * @type {number}
     * @memberof KeycloakListAllKeycloakGroups200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof KeycloakListAllKeycloakGroups200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof KeycloakListAllKeycloakGroups200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof KeycloakListAllKeycloakGroups200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<object>}
     * @memberof KeycloakListAllKeycloakGroups200Response
     */
    'data'?: Array<object>;
}
/**
 * 
 * @export
 * @interface KeycloakListAllKeycloakUsers200Response
 */
export interface KeycloakListAllKeycloakUsers200Response {
    /**
     * 
     * @type {number}
     * @memberof KeycloakListAllKeycloakUsers200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof KeycloakListAllKeycloakUsers200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof KeycloakListAllKeycloakUsers200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof KeycloakListAllKeycloakUsers200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<object>}
     * @memberof KeycloakListAllKeycloakUsers200Response
     */
    'data'?: Array<object>;
}
/**
 * 
 * @export
 * @interface MTOPermissions
 */
export interface MTOPermissions {
    /**
     * MTO path (node Ids) for users to access this scenario
     * @type {Array<string>}
     * @memberof MTOPermissions
     */
    'path': Array<string>;
    /**
     * Group to add the MTO users to
     * @type {string}
     * @memberof MTOPermissions
     */
    'group': MTOPermissionsGroupEnum;
}

export const MTOPermissionsGroupEnum = {
    BlueCell: 'blueCell',
    RedCell: 'redCell',
    WhiteCell: 'whiteCell',
    ScenarioAdmin: 'scenarioAdmin'
} as const;

export type MTOPermissionsGroupEnum = typeof MTOPermissionsGroupEnum[keyof typeof MTOPermissionsGroupEnum];

/**
 * 
 * @export
 * @interface MachineTaint
 */
export interface MachineTaint {
    /**
     * The taint key to be applied to a node.
     * @type {string}
     * @memberof MachineTaint
     */
    'key': string;
    /**
     * The taint value corresponding to the taint key.
     * @type {string}
     * @memberof MachineTaint
     */
    'value'?: string;
    /**
     * The effect of the taint on pods that do not tolerate the taint.
     * @type {string}
     * @memberof MachineTaint
     */
    'effect': MachineTaintEffectEnum;
}

export const MachineTaintEffectEnum = {
    NoSchedule: 'NoSchedule',
    PreferNoSchedule: 'PreferNoSchedule',
    NoExecute: 'NoExecute'
} as const;

export type MachineTaintEffectEnum = typeof MachineTaintEffectEnum[keyof typeof MachineTaintEffectEnum];

/**
 * 
 * @export
 * @interface Meta
 */
export interface Meta {
    /**
     * Common Platform Enumeration - post provisioning actions
     * @type {string}
     * @memberof Meta
     */
    'cpe'?: string;
    /**
     * Changes the icon displayed in the UI
     * @type {string}
     * @memberof Meta
     */
    'iconType'?: MetaIconTypeEnum;
    /**
     * Indicates this VM image supports cloud-init
     * @type {boolean}
     * @memberof Meta
     */
    'supportsCloudInit'?: boolean;
}

export const MetaIconTypeEnum = {
    FileServer: 'FileServer',
    Firewall: 'Firewall',
    Internet: 'Internet',
    Laptop: 'Laptop',
    MailServer: 'MailServer',
    Mobile: 'Mobile',
    Plc: 'PLC',
    Printer: 'Printer',
    Router: 'Router',
    Server: 'Server',
    Switch: 'Switch',
    WebProxy: 'WebProxy',
    WebServer: 'WebServer',
    WirelessAccessPoint: 'WirelessAccessPoint',
    Workstation: 'Workstation'
} as const;

export type MetaIconTypeEnum = typeof MetaIconTypeEnum[keyof typeof MetaIconTypeEnum];

/**
 * 
 * @export
 * @interface MirrorPort
 */
export interface MirrorPort {
    /**
     * Zero-based index of the associated VM or container interface to mirror
     * @type {number}
     * @memberof MirrorPort
     */
    'interfaceIndex': number;
    /**
     * ID of the container specification to mirror to the associated network interface
     * @type {string}
     * @memberof MirrorPort
     */
    'containerSpecification'?: string | null;
    /**
     * ID of the VM specification to mirror to the associated network interface
     * @type {string}
     * @memberof MirrorPort
     */
    'vmSpecification'?: string | null;
}
/**
 * 
 * @export
 * @interface MtoTreeNode
 */
export interface MtoTreeNode {
    /**
     * 
     * @type {string}
     * @memberof MtoTreeNode
     */
    'name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MtoTreeNode
     */
    'path'?: Array<string>;
    /**
     * 
     * @type {Array<MtoTreeNode>}
     * @memberof MtoTreeNode
     */
    'children'?: Array<MtoTreeNode>;
}
/**
 * 
 * @export
 * @interface NetworkDevice
 */
export interface NetworkDevice {
    /**
     * 
     * @type {string}
     * @memberof NetworkDevice
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof NetworkDevice
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof NetworkDevice
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof NetworkDevice
     */
    'description'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof NetworkDevice
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof NetworkDevice
     */
    'metadata'?: object;
    /**
     * Unique and memorable device identifier representing a hardware network device. Can be attached to a scenario via a Range Host Network.
     * @type {string}
     * @memberof NetworkDevice
     */
    'deviceId'?: string;
    /**
     * Kubernetes node name
     * @type {string}
     * @memberof NetworkDevice
     */
    'nodeName'?: string;
    /**
     * Interface name
     * @type {string}
     * @memberof NetworkDevice
     */
    'interfaceName'?: string;
}
/**
 * 
 * @export
 * @interface NetworkDeviceCreate
 */
export interface NetworkDeviceCreate {
    /**
     * User provided metadata
     * @type {object}
     * @memberof NetworkDeviceCreate
     */
    'metadata'?: object;
    /**
     * Unique and memorable device identifier representing a hardware network device. Can be attached to a scenario via a Range Host Network.
     * @type {string}
     * @memberof NetworkDeviceCreate
     */
    'deviceId': string;
    /**
     * Kubernetes node name
     * @type {string}
     * @memberof NetworkDeviceCreate
     */
    'nodeName': string;
    /**
     * Interface name
     * @type {string}
     * @memberof NetworkDeviceCreate
     */
    'interfaceName': string;
}
/**
 * 
 * @export
 * @interface NetworkDeviceUpdate
 */
export interface NetworkDeviceUpdate {
    /**
     * User provided metadata
     * @type {object}
     * @memberof NetworkDeviceUpdate
     */
    'metadata'?: object;
    /**
     * Unique and memorable device identifier representing a hardware network device. Can be attached to a scenario via a Range Host Network.
     * @type {string}
     * @memberof NetworkDeviceUpdate
     */
    'deviceId'?: string;
    /**
     * Kubernetes node name
     * @type {string}
     * @memberof NetworkDeviceUpdate
     */
    'nodeName'?: string;
    /**
     * Interface name
     * @type {string}
     * @memberof NetworkDeviceUpdate
     */
    'interfaceName'?: string;
}
/**
 * 
 * @export
 * @interface NetworkOverride
 */
export interface NetworkOverride {
    /**
     * 
     * @type {string}
     * @memberof NetworkOverride
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof NetworkOverride
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof NetworkOverride
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof NetworkOverride
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof NetworkOverride
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof NetworkOverride
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof NetworkOverride
     */
    'metadata'?: object;
    /**
     * State, Province, or Region
     * @type {string}
     * @memberof NetworkOverride
     */
    'subdivision'?: string;
    /**
     * City
     * @type {string}
     * @memberof NetworkOverride
     */
    'city'?: string;
    /**
     * Country
     * @type {string}
     * @memberof NetworkOverride
     */
    'country'?: string;
    /**
     * ASN
     * @type {number}
     * @memberof NetworkOverride
     */
    'asn'?: number;
    /**
     * Timezone
     * @type {string}
     * @memberof NetworkOverride
     */
    'timezone'?: string;
    /**
     * Country Code
     * @type {string}
     * @memberof NetworkOverride
     */
    'isoCountryCode'?: string;
    /**
     * Latitude
     * @type {string}
     * @memberof NetworkOverride
     */
    'latitude'?: string;
    /**
     * Longitude
     * @type {string}
     * @memberof NetworkOverride
     */
    'longitude'?: string;
    /**
     * Network CIDR Address
     * @type {string}
     * @memberof NetworkOverride
     */
    'cidr'?: string;
}
/**
 * 
 * @export
 * @interface NetworkOverrideCreate
 */
export interface NetworkOverrideCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof NetworkOverrideCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof NetworkOverrideCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof NetworkOverrideCreate
     */
    'metadata'?: object;
    /**
     * State, Province, or Region
     * @type {string}
     * @memberof NetworkOverrideCreate
     */
    'subdivision': string;
    /**
     * City
     * @type {string}
     * @memberof NetworkOverrideCreate
     */
    'city': string;
    /**
     * Country
     * @type {string}
     * @memberof NetworkOverrideCreate
     */
    'country': string;
    /**
     * ASN
     * @type {number}
     * @memberof NetworkOverrideCreate
     */
    'asn': number;
    /**
     * Timezone
     * @type {string}
     * @memberof NetworkOverrideCreate
     */
    'timezone': string;
    /**
     * Country Code
     * @type {string}
     * @memberof NetworkOverrideCreate
     */
    'isoCountryCode': string;
    /**
     * Latitude
     * @type {string}
     * @memberof NetworkOverrideCreate
     */
    'latitude': string;
    /**
     * Longitude
     * @type {string}
     * @memberof NetworkOverrideCreate
     */
    'longitude': string;
    /**
     * Network CIDR Address
     * @type {string}
     * @memberof NetworkOverrideCreate
     */
    'cidr': string;
}
/**
 * 
 * @export
 * @interface NetworkOverrideList200Response
 */
export interface NetworkOverrideList200Response {
    /**
     * 
     * @type {number}
     * @memberof NetworkOverrideList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof NetworkOverrideList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof NetworkOverrideList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof NetworkOverrideList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<NetworkOverride>}
     * @memberof NetworkOverrideList200Response
     */
    'data'?: Array<NetworkOverride>;
}
/**
 * 
 * @export
 * @interface NetworkOverrideUpdate
 */
export interface NetworkOverrideUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof NetworkOverrideUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof NetworkOverrideUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof NetworkOverrideUpdate
     */
    'metadata'?: object;
    /**
     * State, Province, or Region
     * @type {string}
     * @memberof NetworkOverrideUpdate
     */
    'subdivision'?: string;
    /**
     * City
     * @type {string}
     * @memberof NetworkOverrideUpdate
     */
    'city'?: string;
    /**
     * Country
     * @type {string}
     * @memberof NetworkOverrideUpdate
     */
    'country'?: string;
    /**
     * ASN
     * @type {number}
     * @memberof NetworkOverrideUpdate
     */
    'asn'?: number;
    /**
     * Timezone
     * @type {string}
     * @memberof NetworkOverrideUpdate
     */
    'timezone'?: string;
    /**
     * Country Code
     * @type {string}
     * @memberof NetworkOverrideUpdate
     */
    'isoCountryCode'?: string;
    /**
     * Latitude
     * @type {string}
     * @memberof NetworkOverrideUpdate
     */
    'latitude'?: string;
    /**
     * Longitude
     * @type {string}
     * @memberof NetworkOverrideUpdate
     */
    'longitude'?: string;
    /**
     * Network CIDR Address
     * @type {string}
     * @memberof NetworkOverrideUpdate
     */
    'cidr'?: string;
}
/**
 * 
 * @export
 * @interface Node
 */
export interface Node {
    /**
     * Kubernetes node name
     * @type {string}
     * @memberof Node
     */
    'name'?: string;
    /**
     * Node network interfaces
     * @type {Array<NodeInterface>}
     * @memberof Node
     */
    'interfaces'?: Array<NodeInterface>;
}
/**
 * 
 * @export
 * @interface NodeInterface
 */
export interface NodeInterface {
    /**
     * Interface name
     * @type {string}
     * @memberof NodeInterface
     */
    'name'?: string;
    /**
     * Interfaces with device IDs can be attached to a scenario via Range Host Networks
     * @type {string}
     * @memberof NodeInterface
     */
    'deviceId'?: string;
    /**
     * When true, the host-device no longer exists in the default network namespace.
     * @type {boolean}
     * @memberof NodeInterface
     */
    'inUse'?: boolean;
}
/**
 * 
 * @export
 * @interface NodesList1200Response
 */
export interface NodesList1200Response {
    /**
     * 
     * @type {number}
     * @memberof NodesList1200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof NodesList1200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof NodesList1200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof NodesList1200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<NetworkDevice>}
     * @memberof NodesList1200Response
     */
    'data'?: Array<NetworkDevice>;
}
/**
 * 
 * @export
 * @interface NodesList200Response
 */
export interface NodesList200Response {
    /**
     * 
     * @type {number}
     * @memberof NodesList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof NodesList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof NodesList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof NodesList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<RangeNode>}
     * @memberof NodesList200Response
     */
    'data'?: Array<RangeNode>;
}
/**
 * 
 * @export
 * @interface Package
 */
export interface Package {
    /**
     * 
     * @type {string}
     * @memberof Package
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof Package
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof Package
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof Package
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof Package
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof Package
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof Package
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof Package
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * List of container specification IDs
     * @type {Array<string>}
     * @memberof Package
     */
    'containerSpecifications'?: Array<string>;
    /**
     * List of ghost agent IDs
     * @type {Array<string>}
     * @memberof Package
     */
    'ghostAgents'?: Array<string>;
    /**
     * List of ghost C2 server IDs
     * @type {Array<string>}
     * @memberof Package
     */
    'ghostC2Servers'?: Array<string>;
    /**
     * List of ghost client IDs
     * @type {Array<string>}
     * @memberof Package
     */
    'ghostClients'?: Array<string>;
    /**
     * List of ghost traffic profile IDs
     * @type {Array<string>}
     * @memberof Package
     */
    'ghostTrafficProfiles'?: Array<string>;
    /**
     * List of internet gateway IDs
     * @type {Array<string>}
     * @memberof Package
     */
    'internetGateways'?: Array<string>;
    /**
     * List of range BGP IDs
     * @type {Array<string>}
     * @memberof Package
     */
    'rangeBGPs'?: Array<string>;
    /**
     * List of range BGP link IDs
     * @type {Array<string>}
     * @memberof Package
     */
    'rangeBGPLinks'?: Array<string>;
    /**
     * List of range cert IDs
     * @type {Array<string>}
     * @memberof Package
     */
    'rangeCerts'?: Array<string>;
    /**
     * List of range pki IDs
     * @type {Array<string>}
     * @memberof Package
     */
    'rangePkis'?: Array<string>;
    /**
     * List of range console IDs
     * @type {Array<string>}
     * @memberof Package
     */
    'rangeConsoles'?: Array<string>;
    /**
     * List of range DNS server IDs
     * @type {Array<string>}
     * @memberof Package
     */
    'rangeDNSServers'?: Array<string>;
    /**
     * List of range DNS zone IDs
     * @type {Array<string>}
     * @memberof Package
     */
    'rangeDNSZones'?: Array<string>;
    /**
     * List of range DNS record IDs
     * @type {Array<string>}
     * @memberof Package
     */
    'rangeDNSRecords'?: Array<string>;
    /**
     * List of range auto IP IDs
     * @type {Array<string>}
     * @memberof Package
     */
    'rangeAutoIPs'?: Array<string>;
    /**
     * List of range IP IDs
     * @type {Array<string>}
     * @memberof Package
     */
    'rangeIPs'?: Array<string>;
    /**
     * List of range auto L3 network IDs
     * @type {Array<string>}
     * @memberof Package
     */
    'rangeAutoL3Networks'?: Array<string>;
    /**
     * List of range L3 network IDs
     * @type {Array<string>}
     * @memberof Package
     */
    'rangeL3Networks'?: Array<string>;
    /**
     * List of range network IDs
     * @type {Array<string>}
     * @memberof Package
     */
    'rangeNetworks'?: Array<string>;
    /**
     * List of range host network IDs
     * @type {Array<string>}
     * @memberof Package
     */
    'rangeHostNetworks'?: Array<string>;
    /**
     * List of range router IDs
     * @type {Array<string>}
     * @memberof Package
     */
    'rangeRouters'?: Array<string>;
    /**
     * List of range tor net IDs
     * @type {Array<string>}
     * @memberof Package
     */
    'rangeTorNets'?: Array<string>;
    /**
     * List of range volume IDs
     * @type {Array<string>}
     * @memberof Package
     */
    'rangeVolumes'?: Array<string>;
    /**
     * List of AnsiblePlaybook IDs
     * @type {Array<string>}
     * @memberof Package
     */
    'ansiblePlaybooks'?: Array<string>;
    /**
     * List of VM specification IDs
     * @type {Array<string>}
     * @memberof Package
     */
    'vmSpecifications'?: Array<string>;
    /**
     * List of telemetry agent IDs
     * @type {Array<string>}
     * @memberof Package
     */
    'telemetryAgents'?: Array<string>;
    /**
     * Traffic Tracker ID
     * @type {string}
     * @memberof Package
     */
    'trafficTracker'?: string;
}
/**
 * 
 * @export
 * @interface PackageCreate
 */
export interface PackageCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof PackageCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof PackageCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof PackageCreate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof PackageCreate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * List of container specification IDs
     * @type {Array<string>}
     * @memberof PackageCreate
     */
    'containerSpecifications'?: Array<string>;
    /**
     * List of ghost agent IDs
     * @type {Array<string>}
     * @memberof PackageCreate
     */
    'ghostAgents'?: Array<string>;
    /**
     * List of ghost C2 server IDs
     * @type {Array<string>}
     * @memberof PackageCreate
     */
    'ghostC2Servers'?: Array<string>;
    /**
     * List of ghost client IDs
     * @type {Array<string>}
     * @memberof PackageCreate
     */
    'ghostClients'?: Array<string>;
    /**
     * List of ghost traffic profile IDs
     * @type {Array<string>}
     * @memberof PackageCreate
     */
    'ghostTrafficProfiles'?: Array<string>;
    /**
     * List of internet gateway IDs
     * @type {Array<string>}
     * @memberof PackageCreate
     */
    'internetGateways'?: Array<string>;
    /**
     * List of range BGP IDs
     * @type {Array<string>}
     * @memberof PackageCreate
     */
    'rangeBGPs'?: Array<string>;
    /**
     * List of range BGP link IDs
     * @type {Array<string>}
     * @memberof PackageCreate
     */
    'rangeBGPLinks'?: Array<string>;
    /**
     * List of range cert IDs
     * @type {Array<string>}
     * @memberof PackageCreate
     */
    'rangeCerts'?: Array<string>;
    /**
     * List of range pki IDs
     * @type {Array<string>}
     * @memberof PackageCreate
     */
    'rangePkis'?: Array<string>;
    /**
     * List of range console IDs
     * @type {Array<string>}
     * @memberof PackageCreate
     */
    'rangeConsoles'?: Array<string>;
    /**
     * List of range DNS server IDs
     * @type {Array<string>}
     * @memberof PackageCreate
     */
    'rangeDNSServers'?: Array<string>;
    /**
     * List of range DNS zone IDs
     * @type {Array<string>}
     * @memberof PackageCreate
     */
    'rangeDNSZones'?: Array<string>;
    /**
     * List of range DNS record IDs
     * @type {Array<string>}
     * @memberof PackageCreate
     */
    'rangeDNSRecords'?: Array<string>;
    /**
     * List of range auto IP IDs
     * @type {Array<string>}
     * @memberof PackageCreate
     */
    'rangeAutoIPs'?: Array<string>;
    /**
     * List of range IP IDs
     * @type {Array<string>}
     * @memberof PackageCreate
     */
    'rangeIPs'?: Array<string>;
    /**
     * List of range auto L3 network IDs
     * @type {Array<string>}
     * @memberof PackageCreate
     */
    'rangeAutoL3Networks'?: Array<string>;
    /**
     * List of range L3 network IDs
     * @type {Array<string>}
     * @memberof PackageCreate
     */
    'rangeL3Networks'?: Array<string>;
    /**
     * List of range network IDs
     * @type {Array<string>}
     * @memberof PackageCreate
     */
    'rangeNetworks'?: Array<string>;
    /**
     * List of range host network IDs
     * @type {Array<string>}
     * @memberof PackageCreate
     */
    'rangeHostNetworks'?: Array<string>;
    /**
     * List of range router IDs
     * @type {Array<string>}
     * @memberof PackageCreate
     */
    'rangeRouters'?: Array<string>;
    /**
     * List of range tor net IDs
     * @type {Array<string>}
     * @memberof PackageCreate
     */
    'rangeTorNets'?: Array<string>;
    /**
     * List of range volume IDs
     * @type {Array<string>}
     * @memberof PackageCreate
     */
    'rangeVolumes'?: Array<string>;
    /**
     * List of AnsiblePlaybook IDs
     * @type {Array<string>}
     * @memberof PackageCreate
     */
    'ansiblePlaybooks'?: Array<string>;
    /**
     * List of VM specification IDs
     * @type {Array<string>}
     * @memberof PackageCreate
     */
    'vmSpecifications'?: Array<string>;
    /**
     * List of telemetry agent IDs
     * @type {Array<string>}
     * @memberof PackageCreate
     */
    'telemetryAgents'?: Array<string>;
    /**
     * Traffic Tracker ID
     * @type {string}
     * @memberof PackageCreate
     */
    'trafficTracker'?: string;
}
/**
 * 
 * @export
 * @interface PackageUpdate
 */
export interface PackageUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof PackageUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof PackageUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof PackageUpdate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof PackageUpdate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * List of container specification IDs
     * @type {Array<string>}
     * @memberof PackageUpdate
     */
    'containerSpecifications'?: Array<string>;
    /**
     * List of ghost agent IDs
     * @type {Array<string>}
     * @memberof PackageUpdate
     */
    'ghostAgents'?: Array<string>;
    /**
     * List of ghost C2 server IDs
     * @type {Array<string>}
     * @memberof PackageUpdate
     */
    'ghostC2Servers'?: Array<string>;
    /**
     * List of ghost client IDs
     * @type {Array<string>}
     * @memberof PackageUpdate
     */
    'ghostClients'?: Array<string>;
    /**
     * List of ghost traffic profile IDs
     * @type {Array<string>}
     * @memberof PackageUpdate
     */
    'ghostTrafficProfiles'?: Array<string>;
    /**
     * List of internet gateway IDs
     * @type {Array<string>}
     * @memberof PackageUpdate
     */
    'internetGateways'?: Array<string>;
    /**
     * List of range BGP IDs
     * @type {Array<string>}
     * @memberof PackageUpdate
     */
    'rangeBGPs'?: Array<string>;
    /**
     * List of range BGP link IDs
     * @type {Array<string>}
     * @memberof PackageUpdate
     */
    'rangeBGPLinks'?: Array<string>;
    /**
     * List of range cert IDs
     * @type {Array<string>}
     * @memberof PackageUpdate
     */
    'rangeCerts'?: Array<string>;
    /**
     * List of range pki IDs
     * @type {Array<string>}
     * @memberof PackageUpdate
     */
    'rangePkis'?: Array<string>;
    /**
     * List of range console IDs
     * @type {Array<string>}
     * @memberof PackageUpdate
     */
    'rangeConsoles'?: Array<string>;
    /**
     * List of range DNS server IDs
     * @type {Array<string>}
     * @memberof PackageUpdate
     */
    'rangeDNSServers'?: Array<string>;
    /**
     * List of range DNS zone IDs
     * @type {Array<string>}
     * @memberof PackageUpdate
     */
    'rangeDNSZones'?: Array<string>;
    /**
     * List of range DNS record IDs
     * @type {Array<string>}
     * @memberof PackageUpdate
     */
    'rangeDNSRecords'?: Array<string>;
    /**
     * List of range auto IP IDs
     * @type {Array<string>}
     * @memberof PackageUpdate
     */
    'rangeAutoIPs'?: Array<string>;
    /**
     * List of range IP IDs
     * @type {Array<string>}
     * @memberof PackageUpdate
     */
    'rangeIPs'?: Array<string>;
    /**
     * List of range auto L3 network IDs
     * @type {Array<string>}
     * @memberof PackageUpdate
     */
    'rangeAutoL3Networks'?: Array<string>;
    /**
     * List of range L3 network IDs
     * @type {Array<string>}
     * @memberof PackageUpdate
     */
    'rangeL3Networks'?: Array<string>;
    /**
     * List of range network IDs
     * @type {Array<string>}
     * @memberof PackageUpdate
     */
    'rangeNetworks'?: Array<string>;
    /**
     * List of range host network IDs
     * @type {Array<string>}
     * @memberof PackageUpdate
     */
    'rangeHostNetworks'?: Array<string>;
    /**
     * List of range router IDs
     * @type {Array<string>}
     * @memberof PackageUpdate
     */
    'rangeRouters'?: Array<string>;
    /**
     * List of range tor net IDs
     * @type {Array<string>}
     * @memberof PackageUpdate
     */
    'rangeTorNets'?: Array<string>;
    /**
     * List of range volume IDs
     * @type {Array<string>}
     * @memberof PackageUpdate
     */
    'rangeVolumes'?: Array<string>;
    /**
     * List of AnsiblePlaybook IDs
     * @type {Array<string>}
     * @memberof PackageUpdate
     */
    'ansiblePlaybooks'?: Array<string>;
    /**
     * List of VM specification IDs
     * @type {Array<string>}
     * @memberof PackageUpdate
     */
    'vmSpecifications'?: Array<string>;
    /**
     * List of telemetry agent IDs
     * @type {Array<string>}
     * @memberof PackageUpdate
     */
    'telemetryAgents'?: Array<string>;
    /**
     * Traffic Tracker ID
     * @type {string}
     * @memberof PackageUpdate
     */
    'trafficTracker'?: string;
}
/**
 * 
 * @export
 * @interface PackagesList200Response
 */
export interface PackagesList200Response {
    /**
     * 
     * @type {number}
     * @memberof PackagesList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof PackagesList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof PackagesList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof PackagesList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<Package>}
     * @memberof PackagesList200Response
     */
    'data'?: Array<Package>;
}
/**
 * 
 * @export
 * @interface PcteStandardNetspec
 */
export interface PcteStandardNetspec {
    /**
     * 
     * @type {string}
     * @memberof PcteStandardNetspec
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof PcteStandardNetspec
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof PcteStandardNetspec
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof PcteStandardNetspec
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof PcteStandardNetspec
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof PcteStandardNetspec
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof PcteStandardNetspec
     */
    'metadata'?: object;
    /**
     * PCTE Standard Netspec JSON object
     * @type {object}
     * @memberof PcteStandardNetspec
     */
    'netspec'?: object;
    /**
     * ID of the associated scenario
     * @type {string}
     * @memberof PcteStandardNetspec
     */
    'scenario'?: string;
    /**
     * ID of the associated package
     * @type {string}
     * @memberof PcteStandardNetspec
     */
    'package'?: string;
    /**
     * ID of the associated draft
     * @type {string}
     * @memberof PcteStandardNetspec
     */
    'draft'?: string;
}
/**
 * 
 * @export
 * @interface PcteStandardNetspecList200Response
 */
export interface PcteStandardNetspecList200Response {
    /**
     * 
     * @type {number}
     * @memberof PcteStandardNetspecList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof PcteStandardNetspecList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof PcteStandardNetspecList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof PcteStandardNetspecList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<PcteStandardNetspec>}
     * @memberof PcteStandardNetspecList200Response
     */
    'data'?: Array<PcteStandardNetspec>;
}
/**
 * 
 * @export
 * @interface ProjectApi
 */
export interface ProjectApi {
    /**
     * The id of the project
     * @type {number}
     * @memberof ProjectApi
     */
    'id'?: number;
    /**
     * The name of the project
     * @type {string}
     * @memberof ProjectApi
     */
    'name'?: string;
    /**
     * The author of the project.
     * @type {string}
     * @memberof ProjectApi
     */
    'author'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof ProjectApi
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof ProjectApi
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof ProjectApi
     */
    'description'?: string;
}
/**
 * Range
 * @export
 * @interface Range
 */
export interface Range {
    /**
     * The author of the Range
     * @type {string}
     * @memberof Range
     */
    'author'?: string;
    /**
     * Date when the object was created
     * @type {string}
     * @memberof Range
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited
     * @type {string}
     * @memberof Range
     */
    'dateEdited'?: string | null;
    /**
     * A user provided human readable name
     * @type {string}
     * @memberof Range
     */
    'name'?: string;
    /**
     * ID of the range specification, not required for unmanaged ranges - only one of kubeconfig and specification must be given
     * @type {string}
     * @memberof Range
     */
    'specification'?: string;
    /**
     * Optional kubeconfig for unmanaged ranges - only one of kubeconfig and specification must be given
     * @type {string}
     * @memberof Range
     */
    'kubeconfig'?: string;
    /**
     * A v4 UUID
     * @type {string}
     * @memberof Range
     */
    'uuid'?: string;
    /**
     * Indicates the status of the range. Ready, Creating, Deleting, Error, or Unknown
     * @type {string}
     * @memberof Range
     */
    'status'?: RangeStatusEnum;
    /**
     * Displays error message if an error has occurred while creating the range.
     * @type {string}
     * @memberof Range
     */
    'message'?: string;
    /**
     * Type of range specification
     * @type {string}
     * @memberof Range
     */
    'type'?: RangeTypeEnum;
    /**
     * Type of range to bootstrap - only used by unmanaged ranges
     * @type {string}
     * @memberof Range
     */
    'bootstrapType'?: RangeBootstrapTypeEnum;
    /**
     * Username of the user who deployed the scenario
     * @type {string}
     * @memberof Range
     */
    'deployedBy'?: string;
    /**
     * CMI5 content partition key. Values must match the regex /^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$/ and be no longer than 63 characters.
     * @type {string}
     * @memberof Range
     */
    'cmi5Key'?: string | null;
    /**
     * When true, allows new CMI5 content to be deployed to this Range.
     * @type {boolean}
     * @memberof Range
     */
    'cmi5DeploymentAllowed'?: boolean;
}

export const RangeStatusEnum = {
    Unknown: 'Unknown',
    Ready: 'Ready',
    NotReady: 'NotReady',
    Creating: 'Creating',
    Error: 'Error',
    Deleting: 'Deleting',
    Stopped: 'Stopped'
} as const;

export type RangeStatusEnum = typeof RangeStatusEnum[keyof typeof RangeStatusEnum];
export const RangeTypeEnum = {
    Aws: 'AWS',
    Vsphere: 'Vsphere',
    Unmanaged: 'Unmanaged'
} as const;

export type RangeTypeEnum = typeof RangeTypeEnum[keyof typeof RangeTypeEnum];
export const RangeBootstrapTypeEnum = {
    Aws: 'aws',
    Vsphere: 'vsphere',
    Onprem: 'onprem'
} as const;

export type RangeBootstrapTypeEnum = typeof RangeBootstrapTypeEnum[keyof typeof RangeBootstrapTypeEnum];

/**
 * 
 * @export
 * @interface RangeAutoIP
 */
export interface RangeAutoIP {
    /**
     * 
     * @type {string}
     * @memberof RangeAutoIP
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof RangeAutoIP
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof RangeAutoIP
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeAutoIP
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeAutoIP
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof RangeAutoIP
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeAutoIP
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeAutoIP
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * The IP address
     * @type {string}
     * @memberof RangeAutoIP
     */
    'address'?: string | null;
    /**
     * Latitude
     * @type {string}
     * @memberof RangeAutoIP
     */
    'latitude'?: string | null;
    /**
     * Longitude
     * @type {string}
     * @memberof RangeAutoIP
     */
    'longitude'?: string | null;
    /**
     * The ISO 3166 country code
     * @type {string}
     * @memberof RangeAutoIP
     */
    'countryCode'?: string | null;
}
/**
 * 
 * @export
 * @interface RangeAutoIPsList200Response
 */
export interface RangeAutoIPsList200Response {
    /**
     * 
     * @type {number}
     * @memberof RangeAutoIPsList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeAutoIPsList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeAutoIPsList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeAutoIPsList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<RangeAutoIP>}
     * @memberof RangeAutoIPsList200Response
     */
    'data'?: Array<RangeAutoIP>;
}
/**
 * 
 * @export
 * @interface RangeAutoIpCreate
 */
export interface RangeAutoIpCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeAutoIpCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeAutoIpCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeAutoIpCreate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeAutoIpCreate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * The IP address
     * @type {string}
     * @memberof RangeAutoIpCreate
     */
    'address'?: string | null;
    /**
     * Latitude
     * @type {string}
     * @memberof RangeAutoIpCreate
     */
    'latitude'?: string | null;
    /**
     * Longitude
     * @type {string}
     * @memberof RangeAutoIpCreate
     */
    'longitude'?: string | null;
    /**
     * The ISO 3166 country code
     * @type {string}
     * @memberof RangeAutoIpCreate
     */
    'countryCode'?: string | null;
}
/**
 * 
 * @export
 * @interface RangeAutoIpOverride
 */
export interface RangeAutoIpOverride {
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeAutoIpOverride
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeAutoIpOverride
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * The IP address
     * @type {string}
     * @memberof RangeAutoIpOverride
     */
    'address'?: string | null;
    /**
     * Latitude
     * @type {string}
     * @memberof RangeAutoIpOverride
     */
    'latitude'?: string | null;
    /**
     * Longitude
     * @type {string}
     * @memberof RangeAutoIpOverride
     */
    'longitude'?: string | null;
    /**
     * The ISO 3166 country code
     * @type {string}
     * @memberof RangeAutoIpOverride
     */
    'countryCode'?: string | null;
}
/**
 * 
 * @export
 * @interface RangeAutoIpUpdate
 */
export interface RangeAutoIpUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeAutoIpUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeAutoIpUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeAutoIpUpdate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeAutoIpUpdate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * The IP address
     * @type {string}
     * @memberof RangeAutoIpUpdate
     */
    'address'?: string | null;
    /**
     * Latitude
     * @type {string}
     * @memberof RangeAutoIpUpdate
     */
    'latitude'?: string | null;
    /**
     * Longitude
     * @type {string}
     * @memberof RangeAutoIpUpdate
     */
    'longitude'?: string | null;
    /**
     * The ISO 3166 country code
     * @type {string}
     * @memberof RangeAutoIpUpdate
     */
    'countryCode'?: string | null;
}
/**
 * 
 * @export
 * @interface RangeAutoL3Network
 */
export interface RangeAutoL3Network {
    /**
     * 
     * @type {string}
     * @memberof RangeAutoL3Network
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof RangeAutoL3Network
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof RangeAutoL3Network
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeAutoL3Network
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeAutoL3Network
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof RangeAutoL3Network
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeAutoL3Network
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeAutoL3Network
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Network CIDR Address
     * @type {string}
     * @memberof RangeAutoL3Network
     */
    'cidr'?: string;
    /**
     * Latitude
     * @type {string}
     * @memberof RangeAutoL3Network
     */
    'latitude'?: string;
    /**
     * Longitude
     * @type {string}
     * @memberof RangeAutoL3Network
     */
    'longitude'?: string;
    /**
     * Network Default Gateway
     * @type {string}
     * @memberof RangeAutoL3Network
     */
    'defaultGateway'?: string | null;
}
/**
 * 
 * @export
 * @interface RangeAutoL3NetworkCreate
 */
export interface RangeAutoL3NetworkCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeAutoL3NetworkCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeAutoL3NetworkCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeAutoL3NetworkCreate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeAutoL3NetworkCreate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Network CIDR Address
     * @type {string}
     * @memberof RangeAutoL3NetworkCreate
     */
    'cidr': string;
    /**
     * Latitude
     * @type {string}
     * @memberof RangeAutoL3NetworkCreate
     */
    'latitude': string;
    /**
     * Longitude
     * @type {string}
     * @memberof RangeAutoL3NetworkCreate
     */
    'longitude': string;
    /**
     * Network Default Gateway
     * @type {string}
     * @memberof RangeAutoL3NetworkCreate
     */
    'defaultGateway'?: string | null;
}
/**
 * 
 * @export
 * @interface RangeAutoL3NetworkOverride
 */
export interface RangeAutoL3NetworkOverride {
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeAutoL3NetworkOverride
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeAutoL3NetworkOverride
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Network CIDR Address
     * @type {string}
     * @memberof RangeAutoL3NetworkOverride
     */
    'cidr'?: string;
    /**
     * Latitude
     * @type {string}
     * @memberof RangeAutoL3NetworkOverride
     */
    'latitude'?: string;
    /**
     * Longitude
     * @type {string}
     * @memberof RangeAutoL3NetworkOverride
     */
    'longitude'?: string;
    /**
     * Network Default Gateway
     * @type {string}
     * @memberof RangeAutoL3NetworkOverride
     */
    'defaultGateway'?: string | null;
}
/**
 * 
 * @export
 * @interface RangeAutoL3NetworkUpdate
 */
export interface RangeAutoL3NetworkUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeAutoL3NetworkUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeAutoL3NetworkUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeAutoL3NetworkUpdate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeAutoL3NetworkUpdate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Network CIDR Address
     * @type {string}
     * @memberof RangeAutoL3NetworkUpdate
     */
    'cidr'?: string;
    /**
     * Latitude
     * @type {string}
     * @memberof RangeAutoL3NetworkUpdate
     */
    'latitude'?: string;
    /**
     * Longitude
     * @type {string}
     * @memberof RangeAutoL3NetworkUpdate
     */
    'longitude'?: string;
    /**
     * Network Default Gateway
     * @type {string}
     * @memberof RangeAutoL3NetworkUpdate
     */
    'defaultGateway'?: string | null;
}
/**
 * 
 * @export
 * @interface RangeAutoL3NetworksList200Response
 */
export interface RangeAutoL3NetworksList200Response {
    /**
     * 
     * @type {number}
     * @memberof RangeAutoL3NetworksList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeAutoL3NetworksList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeAutoL3NetworksList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeAutoL3NetworksList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<RangeAutoL3Network>}
     * @memberof RangeAutoL3NetworksList200Response
     */
    'data'?: Array<RangeAutoL3Network>;
}
/**
 * 
 * @export
 * @interface RangeAwsSpecificationList200Response
 */
export interface RangeAwsSpecificationList200Response {
    /**
     * 
     * @type {number}
     * @memberof RangeAwsSpecificationList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeAwsSpecificationList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeAwsSpecificationList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeAwsSpecificationList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<RangeSpecificationAws>}
     * @memberof RangeAwsSpecificationList200Response
     */
    'data'?: Array<RangeSpecificationAws>;
}
/**
 * 
 * @export
 * @interface RangeBGP
 */
export interface RangeBGP {
    /**
     * 
     * @type {string}
     * @memberof RangeBGP
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof RangeBGP
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof RangeBGP
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeBGP
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeBGP
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof RangeBGP
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeBGP
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeBGP
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * The Autonomous System Number for this BGP Network
     * @type {number}
     * @memberof RangeBGP
     */
    'asn'?: number;
    /**
     * Range routers that belong to this ASN
     * @type {Array<string>}
     * @memberof RangeBGP
     */
    'rangeRouters'?: Array<string>;
}
/**
 * 
 * @export
 * @interface RangeBGPLink
 */
export interface RangeBGPLink {
    /**
     * 
     * @type {string}
     * @memberof RangeBGPLink
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof RangeBGPLink
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof RangeBGPLink
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeBGPLink
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeBGPLink
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof RangeBGPLink
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeBGPLink
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeBGPLink
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * ASN of node 1
     * @type {number}
     * @memberof RangeBGPLink
     */
    'node1ASN'?: number;
    /**
     * ASN of node 2
     * @type {number}
     * @memberof RangeBGPLink
     */
    'node2ASN'?: number;
    /**
     * One of the endpoints of the BGP link
     * @type {string}
     * @memberof RangeBGPLink
     */
    'node1'?: string;
    /**
     * One of the endpoints of the BGP link
     * @type {string}
     * @memberof RangeBGPLink
     */
    'node2'?: string;
}
/**
 * 
 * @export
 * @interface RangeBgPsList200Response
 */
export interface RangeBgPsList200Response {
    /**
     * 
     * @type {number}
     * @memberof RangeBgPsList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeBgPsList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeBgPsList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeBgPsList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<RangeBGP>}
     * @memberof RangeBgPsList200Response
     */
    'data'?: Array<RangeBGP>;
}
/**
 * 
 * @export
 * @interface RangeBgpCreate
 */
export interface RangeBgpCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeBgpCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeBgpCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeBgpCreate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeBgpCreate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * The Autonomous System Number for this BGP Network
     * @type {number}
     * @memberof RangeBgpCreate
     */
    'asn': number;
    /**
     * Range routers that belong to this ASN
     * @type {Array<string>}
     * @memberof RangeBgpCreate
     */
    'rangeRouters': Array<string>;
}
/**
 * 
 * @export
 * @interface RangeBgpLinkCreate
 */
export interface RangeBgpLinkCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeBgpLinkCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeBgpLinkCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeBgpLinkCreate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeBgpLinkCreate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * ASN of node 1
     * @type {number}
     * @memberof RangeBgpLinkCreate
     */
    'node1ASN': number;
    /**
     * ASN of node 2
     * @type {number}
     * @memberof RangeBgpLinkCreate
     */
    'node2ASN': number;
    /**
     * One of the endpoints of the BGP link
     * @type {string}
     * @memberof RangeBgpLinkCreate
     */
    'node1': string;
    /**
     * One of the endpoints of the BGP link
     * @type {string}
     * @memberof RangeBgpLinkCreate
     */
    'node2': string;
}
/**
 * 
 * @export
 * @interface RangeBgpLinkOverride
 */
export interface RangeBgpLinkOverride {
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeBgpLinkOverride
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeBgpLinkOverride
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * ASN of node 1
     * @type {number}
     * @memberof RangeBgpLinkOverride
     */
    'node1ASN'?: number;
    /**
     * ASN of node 2
     * @type {number}
     * @memberof RangeBgpLinkOverride
     */
    'node2ASN'?: number;
}
/**
 * 
 * @export
 * @interface RangeBgpLinkUpdate
 */
export interface RangeBgpLinkUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeBgpLinkUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeBgpLinkUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeBgpLinkUpdate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeBgpLinkUpdate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * ASN of node 1
     * @type {number}
     * @memberof RangeBgpLinkUpdate
     */
    'node1ASN'?: number;
    /**
     * ASN of node 2
     * @type {number}
     * @memberof RangeBgpLinkUpdate
     */
    'node2ASN'?: number;
    /**
     * One of the endpoints of the BGP link
     * @type {string}
     * @memberof RangeBgpLinkUpdate
     */
    'node1'?: string;
    /**
     * One of the endpoints of the BGP link
     * @type {string}
     * @memberof RangeBgpLinkUpdate
     */
    'node2'?: string;
}
/**
 * 
 * @export
 * @interface RangeBgpLinksList200Response
 */
export interface RangeBgpLinksList200Response {
    /**
     * 
     * @type {number}
     * @memberof RangeBgpLinksList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeBgpLinksList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeBgpLinksList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeBgpLinksList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<RangeBGPLink>}
     * @memberof RangeBgpLinksList200Response
     */
    'data'?: Array<RangeBGPLink>;
}
/**
 * 
 * @export
 * @interface RangeBgpOverride
 */
export interface RangeBgpOverride {
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeBgpOverride
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeBgpOverride
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * The Autonomous System Number for this BGP Network
     * @type {number}
     * @memberof RangeBgpOverride
     */
    'asn'?: number;
}
/**
 * 
 * @export
 * @interface RangeBgpUpdate
 */
export interface RangeBgpUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeBgpUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeBgpUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeBgpUpdate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeBgpUpdate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * The Autonomous System Number for this BGP Network
     * @type {number}
     * @memberof RangeBgpUpdate
     */
    'asn'?: number;
    /**
     * Range routers that belong to this ASN
     * @type {Array<string>}
     * @memberof RangeBgpUpdate
     */
    'rangeRouters'?: Array<string>;
}
/**
 * Range Billing
 * @export
 * @interface RangeBilling
 */
export interface RangeBilling {
    /**
     * Billing Cost
     * @type {Array<TimePeriodTotal>}
     * @memberof RangeBilling
     */
    'billingAmounts'?: Array<TimePeriodTotal>;
}
/**
 * 
 * @export
 * @interface RangeCert
 */
export interface RangeCert {
    /**
     * 
     * @type {string}
     * @memberof RangeCert
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof RangeCert
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof RangeCert
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeCert
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeCert
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof RangeCert
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeCert
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeCert
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * the common name (CN) for the certificate subject in the requested CSR
     * @type {string}
     * @memberof RangeCert
     */
    'cn'?: string;
    /**
     * 
     * @type {KeyRequest}
     * @memberof RangeCert
     */
    'key'?: KeyRequest | null;
    /**
     * the list of subject alternative names for the requested CSR
     * @type {Array<string>}
     * @memberof RangeCert
     */
    'hosts'?: Array<string>;
    /**
     * the certificate subject for the requested CSR
     * @type {Array<CertificateSubject>}
     * @memberof RangeCert
     */
    'certSubjects'?: Array<CertificateSubject>;
    /**
     * the signing profile for the signer
     * @type {string}
     * @memberof RangeCert
     */
    'profile'?: string;
    /**
     * The UUID of the PKI server to request the certificate from
     * @type {string}
     * @memberof RangeCert
     */
    'rangePki'?: string;
}
/**
 * 
 * @export
 * @interface RangeCertCreate
 */
export interface RangeCertCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeCertCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeCertCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeCertCreate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeCertCreate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * the common name (CN) for the certificate subject in the requested CSR
     * @type {string}
     * @memberof RangeCertCreate
     */
    'cn'?: string;
    /**
     * 
     * @type {KeyRequest}
     * @memberof RangeCertCreate
     */
    'key'?: KeyRequest | null;
    /**
     * the list of subject alternative names for the requested CSR
     * @type {Array<string>}
     * @memberof RangeCertCreate
     */
    'hosts': Array<string>;
    /**
     * the certificate subject for the requested CSR
     * @type {Array<CertificateSubject>}
     * @memberof RangeCertCreate
     */
    'certSubjects': Array<CertificateSubject>;
    /**
     * the signing profile for the signer
     * @type {string}
     * @memberof RangeCertCreate
     */
    'profile'?: string;
    /**
     * The UUID of the PKI server to request the certificate from
     * @type {string}
     * @memberof RangeCertCreate
     */
    'rangePki': string;
}
/**
 * 
 * @export
 * @interface RangeCertOverride
 */
export interface RangeCertOverride {
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeCertOverride
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeCertOverride
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * the common name (CN) for the certificate subject in the requested CSR
     * @type {string}
     * @memberof RangeCertOverride
     */
    'cn'?: string;
    /**
     * 
     * @type {KeyRequest}
     * @memberof RangeCertOverride
     */
    'key'?: KeyRequest | null;
    /**
     * the list of subject alternative names for the requested CSR
     * @type {Array<string>}
     * @memberof RangeCertOverride
     */
    'hosts'?: Array<string>;
    /**
     * the certificate subject for the requested CSR
     * @type {Array<CertificateSubject>}
     * @memberof RangeCertOverride
     */
    'certSubjects'?: Array<CertificateSubject>;
    /**
     * the signing profile for the signer
     * @type {string}
     * @memberof RangeCertOverride
     */
    'profile'?: string;
}
/**
 * 
 * @export
 * @interface RangeCertUpdate
 */
export interface RangeCertUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeCertUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeCertUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeCertUpdate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeCertUpdate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * the common name (CN) for the certificate subject in the requested CSR
     * @type {string}
     * @memberof RangeCertUpdate
     */
    'cn'?: string;
    /**
     * 
     * @type {KeyRequest}
     * @memberof RangeCertUpdate
     */
    'key'?: KeyRequest | null;
    /**
     * the list of subject alternative names for the requested CSR
     * @type {Array<string>}
     * @memberof RangeCertUpdate
     */
    'hosts'?: Array<string>;
    /**
     * the certificate subject for the requested CSR
     * @type {Array<CertificateSubject>}
     * @memberof RangeCertUpdate
     */
    'certSubjects'?: Array<CertificateSubject>;
    /**
     * the signing profile for the signer
     * @type {string}
     * @memberof RangeCertUpdate
     */
    'profile'?: string;
    /**
     * The UUID of the PKI server to request the certificate from
     * @type {string}
     * @memberof RangeCertUpdate
     */
    'rangePki'?: string;
}
/**
 * 
 * @export
 * @interface RangeCertificatesList200Response
 */
export interface RangeCertificatesList200Response {
    /**
     * 
     * @type {number}
     * @memberof RangeCertificatesList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeCertificatesList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeCertificatesList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeCertificatesList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<RangeCert>}
     * @memberof RangeCertificatesList200Response
     */
    'data'?: Array<RangeCert>;
}
/**
 * Range Console
 * @export
 * @interface RangeConsole
 */
export interface RangeConsole {
    /**
     * 
     * @type {string}
     * @memberof RangeConsole
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof RangeConsole
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof RangeConsole
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeConsole
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeConsole
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof RangeConsole
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeConsole
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeConsole
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Console protocol
     * @type {string}
     * @memberof RangeConsole
     */
    'protocol'?: RangeConsoleProtocolEnum;
    /**
     * 
     * @type {GuacamoleConnectionParameters}
     * @memberof RangeConsole
     */
    'parameters'?: GuacamoleConnectionParameters | null;
    /**
     * VM specification to access - only one of vmSpecification or containerSpecification can be specified
     * @type {string}
     * @memberof RangeConsole
     */
    'vmSpecification'?: string | null;
    /**
     * Container specification to access - only one of vmSpecification or containerSpecification can be specified
     * @type {string}
     * @memberof RangeConsole
     */
    'containerSpecification'?: string | null;
}

export const RangeConsoleProtocolEnum = {
    Rdp: 'rdp',
    Vnc: 'vnc',
    Ssh: 'ssh',
    Telnet: 'telnet',
    Hypervisor: 'hypervisor',
    Kubernetes: 'kubernetes'
} as const;

export type RangeConsoleProtocolEnum = typeof RangeConsoleProtocolEnum[keyof typeof RangeConsoleProtocolEnum];

/**
 * RangeConsoleAccount
 * @export
 * @interface RangeConsoleAccount
 */
export interface RangeConsoleAccount {
    /**
     * A guacamole username for basic authentication
     * @type {string}
     * @memberof RangeConsoleAccount
     */
    'username': string;
    /**
     * A guacamole password for basic authentication
     * @type {string}
     * @memberof RangeConsoleAccount
     */
    'password'?: string;
}
/**
 * RangeConsoleAccount
 * @export
 * @interface RangeConsoleAccountCreate
 */
export interface RangeConsoleAccountCreate {
    /**
     * A guacamole username for basic authentication
     * @type {string}
     * @memberof RangeConsoleAccountCreate
     */
    'username': string;
}
/**
 * Range Console
 * @export
 * @interface RangeConsoleCreate
 */
export interface RangeConsoleCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeConsoleCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeConsoleCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeConsoleCreate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeConsoleCreate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Console protocol
     * @type {string}
     * @memberof RangeConsoleCreate
     */
    'protocol': RangeConsoleCreateProtocolEnum;
    /**
     * 
     * @type {GuacamoleConnectionParameters}
     * @memberof RangeConsoleCreate
     */
    'parameters'?: GuacamoleConnectionParameters | null;
    /**
     * VM specification to access - only one of vmSpecification or containerSpecification can be specified
     * @type {string}
     * @memberof RangeConsoleCreate
     */
    'vmSpecification'?: string | null;
    /**
     * Container specification to access - only one of vmSpecification or containerSpecification can be specified
     * @type {string}
     * @memberof RangeConsoleCreate
     */
    'containerSpecification'?: string | null;
}

export const RangeConsoleCreateProtocolEnum = {
    Rdp: 'rdp',
    Vnc: 'vnc',
    Ssh: 'ssh',
    Telnet: 'telnet',
    Hypervisor: 'hypervisor',
    Kubernetes: 'kubernetes'
} as const;

export type RangeConsoleCreateProtocolEnum = typeof RangeConsoleCreateProtocolEnum[keyof typeof RangeConsoleCreateProtocolEnum];

/**
 * 
 * @export
 * @interface RangeConsoleOverride
 */
export interface RangeConsoleOverride {
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeConsoleOverride
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeConsoleOverride
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Console protocol
     * @type {string}
     * @memberof RangeConsoleOverride
     */
    'protocol'?: RangeConsoleOverrideProtocolEnum;
    /**
     * 
     * @type {GuacamoleConnectionParameters}
     * @memberof RangeConsoleOverride
     */
    'parameters'?: GuacamoleConnectionParameters | null;
}

export const RangeConsoleOverrideProtocolEnum = {
    Rdp: 'rdp',
    Vnc: 'vnc',
    Ssh: 'ssh',
    Telnet: 'telnet',
    Hypervisor: 'hypervisor',
    Kubernetes: 'kubernetes'
} as const;

export type RangeConsoleOverrideProtocolEnum = typeof RangeConsoleOverrideProtocolEnum[keyof typeof RangeConsoleOverrideProtocolEnum];

/**
 * Range Console
 * @export
 * @interface RangeConsoleUpdate
 */
export interface RangeConsoleUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeConsoleUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeConsoleUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeConsoleUpdate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeConsoleUpdate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Console protocol
     * @type {string}
     * @memberof RangeConsoleUpdate
     */
    'protocol'?: RangeConsoleUpdateProtocolEnum;
    /**
     * 
     * @type {GuacamoleConnectionParameters}
     * @memberof RangeConsoleUpdate
     */
    'parameters'?: GuacamoleConnectionParameters | null;
    /**
     * VM specification to access - only one of vmSpecification or containerSpecification can be specified
     * @type {string}
     * @memberof RangeConsoleUpdate
     */
    'vmSpecification'?: string | null;
    /**
     * Container specification to access - only one of vmSpecification or containerSpecification can be specified
     * @type {string}
     * @memberof RangeConsoleUpdate
     */
    'containerSpecification'?: string | null;
}

export const RangeConsoleUpdateProtocolEnum = {
    Rdp: 'rdp',
    Vnc: 'vnc',
    Ssh: 'ssh',
    Telnet: 'telnet',
    Hypervisor: 'hypervisor',
    Kubernetes: 'kubernetes'
} as const;

export type RangeConsoleUpdateProtocolEnum = typeof RangeConsoleUpdateProtocolEnum[keyof typeof RangeConsoleUpdateProtocolEnum];

/**
 * 
 * @export
 * @interface RangeConsolesList200Response
 */
export interface RangeConsolesList200Response {
    /**
     * 
     * @type {number}
     * @memberof RangeConsolesList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeConsolesList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeConsolesList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeConsolesList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<RangeConsole>}
     * @memberof RangeConsolesList200Response
     */
    'data'?: Array<RangeConsole>;
}
/**
 * RangeOS Range Container
 * @export
 * @interface RangeContainer
 */
export interface RangeContainer {
    /**
     * 
     * @type {string}
     * @memberof RangeContainer
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof RangeContainer
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof RangeContainer
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeContainer
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeContainer
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof RangeContainer
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeContainer
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeContainer
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * The name of an existing chart.
     * @type {string}
     * @memberof RangeContainer
     */
    'chart'?: string;
    /**
     * Version of the chart.
     * @type {string}
     * @memberof RangeContainer
     */
    'chartVersion'?: string;
    /**
     * Values to use with the chart. Must validate against the chart version schema.
     * @type {object}
     * @memberof RangeContainer
     */
    'values'?: object;
    /**
     * Optional templated parameters to use with the chart. Go text templates are supported in values, and non-deterministic functions (ex. randAlpha) can be used. This can be used to inject random data at runtime or provide simple overridable chart values, for example.
     * @type {{ [key: string]: string; }}
     * @memberof RangeContainer
     */
    'parameters'?: { [key: string]: string; } | null;
    /**
     * Advanced networking mode allows network interfaces to be assigned to specific pods in the associated chart.
     * @type {boolean}
     * @memberof RangeContainer
     */
    'advancedNetworking'?: boolean;
    /**
     * Whether the control network NIC is enabled. At least 1 interface is required if false
     * @type {boolean}
     * @memberof RangeContainer
     */
    'controlNetNicEnabled'?: boolean;
    /**
     * The chart object
     * @type {object}
     * @memberof RangeContainer
     */
    'chartIcon'?: object;
    /**
     * UUID of an optional associated Range Cert
     * @type {{ [key: string]: string; }}
     * @memberof RangeContainer
     */
    'rangeCerts'?: { [key: string]: string; };
    /**
     * UUID of an optional associated Range DNS Record
     * @type {{ [key: string]: string; }}
     * @memberof RangeContainer
     */
    'rangeDNSRecords'?: { [key: string]: string; };
    /**
     * List of interfaces attached to the containers
     * @type {Array<RangeContainerInterface>}
     * @memberof RangeContainer
     */
    'interfaces'?: Array<RangeContainerInterface>;
    /**
     * UUID of an optional associated Range Volume
     * @type {{ [key: string]: string; }}
     * @memberof RangeContainer
     */
    'rangeVolumes'?: { [key: string]: string; };
    /**
     * Indicates whether the range container is ready or not
     * @type {boolean}
     * @memberof RangeContainer
     */
    'ready'?: boolean;
    /**
     * Deployed range container status
     * @type {string}
     * @memberof RangeContainer
     */
    'status'?: RangeContainerStatusEnum;
    /**
     * Error message if range container has Error Status
     * @type {string}
     * @memberof RangeContainer
     */
    'message'?: string;
    /**
     * Indicates whether the associated deployment is running or not
     * @type {boolean}
     * @memberof RangeContainer
     */
    'running'?: boolean;
    /**
     * UUID of the related container specification
     * @type {string}
     * @memberof RangeContainer
     */
    'containerSpecification'?: string;
}

export const RangeContainerStatusEnum = {
    Unknown: 'Unknown',
    Ready: 'Ready',
    NotReady: 'NotReady',
    Creating: 'Creating',
    Error: 'Error',
    Deleting: 'Deleting',
    Stopped: 'Stopped'
} as const;

export type RangeContainerStatusEnum = typeof RangeContainerStatusEnum[keyof typeof RangeContainerStatusEnum];

/**
 * 
 * @export
 * @interface RangeContainerInterface
 */
export interface RangeContainerInterface {
    /**
     * Optional ID of a range network
     * @type {string}
     * @memberof RangeContainerInterface
     */
    'rangeNetwork'?: string | null;
    /**
     * Optional ID of a range host network
     * @type {string}
     * @memberof RangeContainerInterface
     */
    'rangeHostNetwork'?: string | null;
    /**
     * Optional ID of a range IP
     * @type {string}
     * @memberof RangeContainerInterface
     */
    'rangeIP'?: string | null;
    /**
     * Optional ID of a range auto IP
     * @type {string}
     * @memberof RangeContainerInterface
     */
    'rangeAutoIP'?: string | null;
    /**
     * Optional MAC address, if not provided one will be randomly generated
     * @type {string}
     * @memberof RangeContainerInterface
     */
    'macAddress'?: string | null;
    /**
     * Optional list of network ports to mirror to this interface
     * @type {Array<DeployedMirrorPort>}
     * @memberof RangeContainerInterface
     */
    'mirrorPorts'?: Array<DeployedMirrorPort>;
    /**
     * Optional unique identifier, only used with advanced networking
     * @type {object}
     * @memberof RangeContainerInterface
     */
    'id'?: object;
    /**
     * Optional interface name
     * @type {object}
     * @memberof RangeContainerInterface
     */
    'interfaceName'?: object;
    /**
     * 
     * @type {string}
     * @memberof RangeContainerInterface
     */
    'rangeIPName'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof RangeContainerInterface
     */
    'defaultGateway'?: boolean;
}
/**
 * 
 * @export
 * @interface RangeContainersList200Response
 */
export interface RangeContainersList200Response {
    /**
     * 
     * @type {number}
     * @memberof RangeContainersList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeContainersList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeContainersList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeContainersList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<RangeContainer>}
     * @memberof RangeContainersList200Response
     */
    'data'?: Array<RangeContainer>;
}
/**
 * Range
 * @export
 * @interface RangeCreate
 */
export interface RangeCreate {
    /**
     * A user provided human readable name
     * @type {string}
     * @memberof RangeCreate
     */
    'name': string;
    /**
     * ID of the range specification, not required for unmanaged ranges - only one of kubeconfig and specification must be given
     * @type {string}
     * @memberof RangeCreate
     */
    'specification'?: string;
    /**
     * Optional kubeconfig for unmanaged ranges - only one of kubeconfig and specification must be given
     * @type {string}
     * @memberof RangeCreate
     */
    'kubeconfig'?: string;
    /**
     * If true, the range will not be bootstrapped
     * @type {boolean}
     * @memberof RangeCreate
     */
    'suspendBootstrap'?: boolean;
    /**
     * Type of range to bootstrap - only used by unmanaged ranges
     * @type {string}
     * @memberof RangeCreate
     */
    'bootstrapType'?: RangeCreateBootstrapTypeEnum;
    /**
     * CMI5 content partition key. Values must match the regex /^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$/ and be no longer than 63 characters.
     * @type {string}
     * @memberof RangeCreate
     */
    'cmi5Key'?: string | null;
    /**
     * When true, allows new CMI5 content to be deployed to this Range.
     * @type {boolean}
     * @memberof RangeCreate
     */
    'cmi5DeploymentAllowed'?: boolean;
}

export const RangeCreateBootstrapTypeEnum = {
    Aws: 'aws',
    Vsphere: 'vsphere',
    Onprem: 'onprem'
} as const;

export type RangeCreateBootstrapTypeEnum = typeof RangeCreateBootstrapTypeEnum[keyof typeof RangeCreateBootstrapTypeEnum];

/**
 * 
 * @export
 * @interface RangeDNSRecord
 */
export interface RangeDNSRecord {
    /**
     * 
     * @type {string}
     * @memberof RangeDNSRecord
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof RangeDNSRecord
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof RangeDNSRecord
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeDNSRecord
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeDNSRecord
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof RangeDNSRecord
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeDNSRecord
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeDNSRecord
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Class of the record
     * @type {string}
     * @memberof RangeDNSRecord
     */
    'recordClass'?: string;
    /**
     * The time to live of the record
     * @type {number}
     * @memberof RangeDNSRecord
     */
    'ttl'?: number;
    /**
     * The type of record
     * @type {string}
     * @memberof RangeDNSRecord
     */
    'type'?: string;
    /**
     * The data for the record
     * @type {string}
     * @memberof RangeDNSRecord
     */
    'data'?: string;
    /**
     * ID of the associated range DNS zone
     * @type {string}
     * @memberof RangeDNSRecord
     */
    'rangeDNSZone'?: string;
}
/**
 * 
 * @export
 * @interface RangeDNSServer
 */
export interface RangeDNSServer {
    /**
     * 
     * @type {string}
     * @memberof RangeDNSServer
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof RangeDNSServer
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof RangeDNSServer
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeDNSServer
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeDNSServer
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof RangeDNSServer
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeDNSServer
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeDNSServer
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * 
     * @type {string}
     * @memberof RangeDNSServer
     */
    'type'?: RangeDNSServerTypeEnum;
    /**
     * Array of tags that zones can match against
     * @type {Array<string>}
     * @memberof RangeDNSServer
     */
    'tags'?: Array<string>;
    /**
     * Mapping of IP name to range IP IDs
     * @type {{ [key: string]: string; }}
     * @memberof RangeDNSServer
     */
    'rangeIPs'?: { [key: string]: string; };
    /**
     * Mapping of IP name to range auto IP IDs
     * @type {{ [key: string]: string; }}
     * @memberof RangeDNSServer
     */
    'rangeAutoIPs'?: { [key: string]: string; };
}

export const RangeDNSServerTypeEnum = {
    Authoritative: 'authoritative',
    Root: 'root',
    Recursive: 'recursive'
} as const;

export type RangeDNSServerTypeEnum = typeof RangeDNSServerTypeEnum[keyof typeof RangeDNSServerTypeEnum];

/**
 * 
 * @export
 * @interface RangeDNSZone
 */
export interface RangeDNSZone {
    /**
     * 
     * @type {string}
     * @memberof RangeDNSZone
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof RangeDNSZone
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof RangeDNSZone
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeDNSZone
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeDNSZone
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof RangeDNSZone
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeDNSZone
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeDNSZone
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Time to Live for records in the zone
     * @type {number}
     * @memberof RangeDNSZone
     */
    'ttl'?: number;
    /**
     * Primary Master Nameserver for the zone
     * @type {string}
     * @memberof RangeDNSZone
     */
    'masterNs'?: string;
    /**
     * Email address of administrator for the zone
     * @type {string}
     * @memberof RangeDNSZone
     */
    'email'?: string;
    /**
     * Serial number for the zone
     * @type {number}
     * @memberof RangeDNSZone
     */
    'serial'?: number;
    /**
     * Number of seconds after which secondary nameservers should query the master to detect zone changes
     * @type {number}
     * @memberof RangeDNSZone
     */
    'refresh'?: number;
    /**
     * Number of seconds after which secondary nameservers should retry request if master doesn\'t respond
     * @type {number}
     * @memberof RangeDNSZone
     */
    'retry'?: number;
    /**
     * Number of seconds after which secondary nameservers should stop answering request for the zone if master doesn\'t respond
     * @type {number}
     * @memberof RangeDNSZone
     */
    'expire'?: number;
    /**
     * Minimum TTL for resolvers
     * @type {number}
     * @memberof RangeDNSZone
     */
    'minimumTTL'?: number;
    /**
     * DNS servers matching one or more of the given tags will use this zone
     * @type {Array<string>}
     * @memberof RangeDNSZone
     */
    'tagSelectors'?: Array<string>;
}
/**
 * 
 * @export
 * @interface RangeDnsRecordCreate
 */
export interface RangeDnsRecordCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeDnsRecordCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeDnsRecordCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeDnsRecordCreate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeDnsRecordCreate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Class of the record
     * @type {string}
     * @memberof RangeDnsRecordCreate
     */
    'recordClass': string;
    /**
     * The time to live of the record
     * @type {number}
     * @memberof RangeDnsRecordCreate
     */
    'ttl': number;
    /**
     * The type of record
     * @type {string}
     * @memberof RangeDnsRecordCreate
     */
    'type': string;
    /**
     * The data for the record
     * @type {string}
     * @memberof RangeDnsRecordCreate
     */
    'data': string;
    /**
     * ID of the associated range DNS zone
     * @type {string}
     * @memberof RangeDnsRecordCreate
     */
    'rangeDNSZone': string;
}
/**
 * 
 * @export
 * @interface RangeDnsRecordOverride
 */
export interface RangeDnsRecordOverride {
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeDnsRecordOverride
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeDnsRecordOverride
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Class of the record
     * @type {string}
     * @memberof RangeDnsRecordOverride
     */
    'recordClass'?: string;
    /**
     * The time to live of the record
     * @type {number}
     * @memberof RangeDnsRecordOverride
     */
    'ttl'?: number;
    /**
     * The type of record
     * @type {string}
     * @memberof RangeDnsRecordOverride
     */
    'type'?: string;
    /**
     * The data for the record
     * @type {string}
     * @memberof RangeDnsRecordOverride
     */
    'data'?: string;
}
/**
 * 
 * @export
 * @interface RangeDnsRecordUpdate
 */
export interface RangeDnsRecordUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeDnsRecordUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeDnsRecordUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeDnsRecordUpdate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeDnsRecordUpdate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Class of the record
     * @type {string}
     * @memberof RangeDnsRecordUpdate
     */
    'recordClass'?: string;
    /**
     * The time to live of the record
     * @type {number}
     * @memberof RangeDnsRecordUpdate
     */
    'ttl'?: number;
    /**
     * The type of record
     * @type {string}
     * @memberof RangeDnsRecordUpdate
     */
    'type'?: string;
    /**
     * The data for the record
     * @type {string}
     * @memberof RangeDnsRecordUpdate
     */
    'data'?: string;
    /**
     * ID of the associated range DNS zone
     * @type {string}
     * @memberof RangeDnsRecordUpdate
     */
    'rangeDNSZone'?: string;
}
/**
 * 
 * @export
 * @interface RangeDnsRecordsList200Response
 */
export interface RangeDnsRecordsList200Response {
    /**
     * 
     * @type {number}
     * @memberof RangeDnsRecordsList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeDnsRecordsList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeDnsRecordsList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeDnsRecordsList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<RangeDNSRecord>}
     * @memberof RangeDnsRecordsList200Response
     */
    'data'?: Array<RangeDNSRecord>;
}
/**
 * 
 * @export
 * @interface RangeDnsServerCreate
 */
export interface RangeDnsServerCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeDnsServerCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeDnsServerCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeDnsServerCreate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeDnsServerCreate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * 
     * @type {string}
     * @memberof RangeDnsServerCreate
     */
    'type'?: RangeDnsServerCreateTypeEnum;
    /**
     * Array of tags that zones can match against
     * @type {Array<string>}
     * @memberof RangeDnsServerCreate
     */
    'tags': Array<string>;
    /**
     * Mapping of IP name to range IP IDs
     * @type {{ [key: string]: string; }}
     * @memberof RangeDnsServerCreate
     */
    'rangeIPs'?: { [key: string]: string; };
    /**
     * Mapping of IP name to range auto IP IDs
     * @type {{ [key: string]: string; }}
     * @memberof RangeDnsServerCreate
     */
    'rangeAutoIPs'?: { [key: string]: string; };
}

export const RangeDnsServerCreateTypeEnum = {
    Authoritative: 'authoritative',
    Root: 'root',
    Recursive: 'recursive'
} as const;

export type RangeDnsServerCreateTypeEnum = typeof RangeDnsServerCreateTypeEnum[keyof typeof RangeDnsServerCreateTypeEnum];

/**
 * 
 * @export
 * @interface RangeDnsServerOverride
 */
export interface RangeDnsServerOverride {
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeDnsServerOverride
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeDnsServerOverride
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * 
     * @type {string}
     * @memberof RangeDnsServerOverride
     */
    'type'?: RangeDnsServerOverrideTypeEnum;
    /**
     * Array of tags that zones can match against
     * @type {Array<string>}
     * @memberof RangeDnsServerOverride
     */
    'tags'?: Array<string>;
}

export const RangeDnsServerOverrideTypeEnum = {
    Authoritative: 'authoritative',
    Root: 'root',
    Recursive: 'recursive'
} as const;

export type RangeDnsServerOverrideTypeEnum = typeof RangeDnsServerOverrideTypeEnum[keyof typeof RangeDnsServerOverrideTypeEnum];

/**
 * 
 * @export
 * @interface RangeDnsServerUpdate
 */
export interface RangeDnsServerUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeDnsServerUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeDnsServerUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeDnsServerUpdate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeDnsServerUpdate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * 
     * @type {string}
     * @memberof RangeDnsServerUpdate
     */
    'type'?: RangeDnsServerUpdateTypeEnum;
    /**
     * Array of tags that zones can match against
     * @type {Array<string>}
     * @memberof RangeDnsServerUpdate
     */
    'tags'?: Array<string>;
    /**
     * Mapping of IP name to range IP IDs
     * @type {{ [key: string]: string; }}
     * @memberof RangeDnsServerUpdate
     */
    'rangeIPs'?: { [key: string]: string; };
    /**
     * Mapping of IP name to range auto IP IDs
     * @type {{ [key: string]: string; }}
     * @memberof RangeDnsServerUpdate
     */
    'rangeAutoIPs'?: { [key: string]: string; };
}

export const RangeDnsServerUpdateTypeEnum = {
    Authoritative: 'authoritative',
    Root: 'root',
    Recursive: 'recursive'
} as const;

export type RangeDnsServerUpdateTypeEnum = typeof RangeDnsServerUpdateTypeEnum[keyof typeof RangeDnsServerUpdateTypeEnum];

/**
 * 
 * @export
 * @interface RangeDnsServersList200Response
 */
export interface RangeDnsServersList200Response {
    /**
     * 
     * @type {number}
     * @memberof RangeDnsServersList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeDnsServersList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeDnsServersList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeDnsServersList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<RangeDNSServer>}
     * @memberof RangeDnsServersList200Response
     */
    'data'?: Array<RangeDNSServer>;
}
/**
 * 
 * @export
 * @interface RangeDnsServersListTagSelectors200Response
 */
export interface RangeDnsServersListTagSelectors200Response {
    /**
     * 
     * @type {number}
     * @memberof RangeDnsServersListTagSelectors200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeDnsServersListTagSelectors200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeDnsServersListTagSelectors200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeDnsServersListTagSelectors200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof RangeDnsServersListTagSelectors200Response
     */
    'data'?: Array<string>;
}
/**
 * 
 * @export
 * @interface RangeDnsZoneCreate
 */
export interface RangeDnsZoneCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeDnsZoneCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeDnsZoneCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeDnsZoneCreate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeDnsZoneCreate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Time to Live for records in the zone
     * @type {number}
     * @memberof RangeDnsZoneCreate
     */
    'ttl': number;
    /**
     * Primary Master Nameserver for the zone
     * @type {string}
     * @memberof RangeDnsZoneCreate
     */
    'masterNs': string;
    /**
     * Email address of administrator for the zone
     * @type {string}
     * @memberof RangeDnsZoneCreate
     */
    'email': string;
    /**
     * Serial number for the zone
     * @type {number}
     * @memberof RangeDnsZoneCreate
     */
    'serial': number;
    /**
     * Number of seconds after which secondary nameservers should query the master to detect zone changes
     * @type {number}
     * @memberof RangeDnsZoneCreate
     */
    'refresh': number;
    /**
     * Number of seconds after which secondary nameservers should retry request if master doesn\'t respond
     * @type {number}
     * @memberof RangeDnsZoneCreate
     */
    'retry': number;
    /**
     * Number of seconds after which secondary nameservers should stop answering request for the zone if master doesn\'t respond
     * @type {number}
     * @memberof RangeDnsZoneCreate
     */
    'expire': number;
    /**
     * Minimum TTL for resolvers
     * @type {number}
     * @memberof RangeDnsZoneCreate
     */
    'minimumTTL': number;
    /**
     * DNS servers matching one or more of the given tags will use this zone
     * @type {Array<string>}
     * @memberof RangeDnsZoneCreate
     */
    'tagSelectors': Array<string>;
}
/**
 * 
 * @export
 * @interface RangeDnsZoneOverride
 */
export interface RangeDnsZoneOverride {
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeDnsZoneOverride
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeDnsZoneOverride
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Time to Live for records in the zone
     * @type {number}
     * @memberof RangeDnsZoneOverride
     */
    'ttl'?: number;
    /**
     * Primary Master Nameserver for the zone
     * @type {string}
     * @memberof RangeDnsZoneOverride
     */
    'masterNs'?: string;
    /**
     * Email address of administrator for the zone
     * @type {string}
     * @memberof RangeDnsZoneOverride
     */
    'email'?: string;
    /**
     * Serial number for the zone
     * @type {number}
     * @memberof RangeDnsZoneOverride
     */
    'serial'?: number;
    /**
     * Number of seconds after which secondary nameservers should query the master to detect zone changes
     * @type {number}
     * @memberof RangeDnsZoneOverride
     */
    'refresh'?: number;
    /**
     * Number of seconds after which secondary nameservers should retry request if master doesn\'t respond
     * @type {number}
     * @memberof RangeDnsZoneOverride
     */
    'retry'?: number;
    /**
     * Number of seconds after which secondary nameservers should stop answering request for the zone if master doesn\'t respond
     * @type {number}
     * @memberof RangeDnsZoneOverride
     */
    'expire'?: number;
    /**
     * Minimum TTL for resolvers
     * @type {number}
     * @memberof RangeDnsZoneOverride
     */
    'minimumTTL'?: number;
    /**
     * DNS servers matching one or more of the given tags will use this zone
     * @type {Array<string>}
     * @memberof RangeDnsZoneOverride
     */
    'tagSelectors'?: Array<string>;
}
/**
 * 
 * @export
 * @interface RangeDnsZoneUpdate
 */
export interface RangeDnsZoneUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeDnsZoneUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeDnsZoneUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeDnsZoneUpdate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeDnsZoneUpdate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Time to Live for records in the zone
     * @type {number}
     * @memberof RangeDnsZoneUpdate
     */
    'ttl'?: number;
    /**
     * Primary Master Nameserver for the zone
     * @type {string}
     * @memberof RangeDnsZoneUpdate
     */
    'masterNs'?: string;
    /**
     * Email address of administrator for the zone
     * @type {string}
     * @memberof RangeDnsZoneUpdate
     */
    'email'?: string;
    /**
     * Serial number for the zone
     * @type {number}
     * @memberof RangeDnsZoneUpdate
     */
    'serial'?: number;
    /**
     * Number of seconds after which secondary nameservers should query the master to detect zone changes
     * @type {number}
     * @memberof RangeDnsZoneUpdate
     */
    'refresh'?: number;
    /**
     * Number of seconds after which secondary nameservers should retry request if master doesn\'t respond
     * @type {number}
     * @memberof RangeDnsZoneUpdate
     */
    'retry'?: number;
    /**
     * Number of seconds after which secondary nameservers should stop answering request for the zone if master doesn\'t respond
     * @type {number}
     * @memberof RangeDnsZoneUpdate
     */
    'expire'?: number;
    /**
     * Minimum TTL for resolvers
     * @type {number}
     * @memberof RangeDnsZoneUpdate
     */
    'minimumTTL'?: number;
    /**
     * DNS servers matching one or more of the given tags will use this zone
     * @type {Array<string>}
     * @memberof RangeDnsZoneUpdate
     */
    'tagSelectors'?: Array<string>;
}
/**
 * 
 * @export
 * @interface RangeDnsZonesList200Response
 */
export interface RangeDnsZonesList200Response {
    /**
     * 
     * @type {number}
     * @memberof RangeDnsZonesList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeDnsZonesList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeDnsZonesList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeDnsZonesList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<RangeDNSZone>}
     * @memberof RangeDnsZonesList200Response
     */
    'data'?: Array<RangeDNSZone>;
}
/**
 * 
 * @export
 * @interface RangeHostNetwork
 */
export interface RangeHostNetwork {
    /**
     * 
     * @type {string}
     * @memberof RangeHostNetwork
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof RangeHostNetwork
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof RangeHostNetwork
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeHostNetwork
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeHostNetwork
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof RangeHostNetwork
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeHostNetwork
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeHostNetwork
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Unique and memorable device identifier representing a hardware network device that is directly connected to this network
     * @type {string}
     * @memberof RangeHostNetwork
     */
    'deviceId'?: string;
}
/**
 * 
 * @export
 * @interface RangeHostNetworkCreate
 */
export interface RangeHostNetworkCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeHostNetworkCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeHostNetworkCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeHostNetworkCreate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeHostNetworkCreate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Unique and memorable device identifier representing a hardware network device that is directly connected to this network
     * @type {string}
     * @memberof RangeHostNetworkCreate
     */
    'deviceId': string;
}
/**
 * 
 * @export
 * @interface RangeHostNetworkUpdate
 */
export interface RangeHostNetworkUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeHostNetworkUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeHostNetworkUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeHostNetworkUpdate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeHostNetworkUpdate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Unique and memorable device identifier representing a hardware network device that is directly connected to this network
     * @type {string}
     * @memberof RangeHostNetworkUpdate
     */
    'deviceId'?: string;
}
/**
 * 
 * @export
 * @interface RangeHostNetworksList200Response
 */
export interface RangeHostNetworksList200Response {
    /**
     * 
     * @type {number}
     * @memberof RangeHostNetworksList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeHostNetworksList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeHostNetworksList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeHostNetworksList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<RangeHostNetwork>}
     * @memberof RangeHostNetworksList200Response
     */
    'data'?: Array<RangeHostNetwork>;
}
/**
 * 
 * @export
 * @interface RangeIP
 */
export interface RangeIP {
    /**
     * 
     * @type {string}
     * @memberof RangeIP
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof RangeIP
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof RangeIP
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeIP
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeIP
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof RangeIP
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeIP
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeIP
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * IP address
     * @type {string}
     * @memberof RangeIP
     */
    'address'?: string | null;
    /**
     * Country Code
     * @type {string}
     * @memberof RangeIP
     */
    'countryCode'?: string | null;
    /**
     * Latitude
     * @type {string}
     * @memberof RangeIP
     */
    'latitude'?: string | null;
    /**
     * Longitude
     * @type {string}
     * @memberof RangeIP
     */
    'longitude'?: string | null;
    /**
     * Set the IP out to public internet, any value means true
     * @type {boolean}
     * @memberof RangeIP
     */
    'controlNet'?: boolean;
    /**
     * Optional list of DNS servers
     * @type {Array<string>}
     * @memberof RangeIP
     */
    'dnsServers'?: Array<string>;
    /**
     * ID of a range L3 network
     * @type {string}
     * @memberof RangeIP
     */
    'rangeL3Network'?: string;
}
/**
 * 
 * @export
 * @interface RangeIPsList200Response
 */
export interface RangeIPsList200Response {
    /**
     * 
     * @type {number}
     * @memberof RangeIPsList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeIPsList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeIPsList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeIPsList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<RangeIP>}
     * @memberof RangeIPsList200Response
     */
    'data'?: Array<RangeIP>;
}
/**
 * 
 * @export
 * @interface RangeIpCreate
 */
export interface RangeIpCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeIpCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeIpCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeIpCreate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeIpCreate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * IP address
     * @type {string}
     * @memberof RangeIpCreate
     */
    'address'?: string | null;
    /**
     * Country Code
     * @type {string}
     * @memberof RangeIpCreate
     */
    'countryCode'?: string | null;
    /**
     * Latitude
     * @type {string}
     * @memberof RangeIpCreate
     */
    'latitude'?: string | null;
    /**
     * Longitude
     * @type {string}
     * @memberof RangeIpCreate
     */
    'longitude'?: string | null;
    /**
     * Set the IP out to public internet, any value means true
     * @type {boolean}
     * @memberof RangeIpCreate
     */
    'controlNet': boolean;
    /**
     * Optional list of DNS servers
     * @type {Array<string>}
     * @memberof RangeIpCreate
     */
    'dnsServers'?: Array<string>;
    /**
     * ID of a range L3 network
     * @type {string}
     * @memberof RangeIpCreate
     */
    'rangeL3Network': string;
}
/**
 * 
 * @export
 * @interface RangeIpOverride
 */
export interface RangeIpOverride {
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeIpOverride
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeIpOverride
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * IP address
     * @type {string}
     * @memberof RangeIpOverride
     */
    'address'?: string | null;
    /**
     * Country Code
     * @type {string}
     * @memberof RangeIpOverride
     */
    'countryCode'?: string | null;
    /**
     * Latitude
     * @type {string}
     * @memberof RangeIpOverride
     */
    'latitude'?: string | null;
    /**
     * Longitude
     * @type {string}
     * @memberof RangeIpOverride
     */
    'longitude'?: string | null;
    /**
     * Set the IP out to public internet, any value means true
     * @type {boolean}
     * @memberof RangeIpOverride
     */
    'controlNet'?: boolean;
    /**
     * Optional list of DNS servers
     * @type {Array<string>}
     * @memberof RangeIpOverride
     */
    'dnsServers'?: Array<string>;
}
/**
 * 
 * @export
 * @interface RangeIpUpdate
 */
export interface RangeIpUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeIpUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeIpUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeIpUpdate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeIpUpdate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * IP address
     * @type {string}
     * @memberof RangeIpUpdate
     */
    'address'?: string | null;
    /**
     * Country Code
     * @type {string}
     * @memberof RangeIpUpdate
     */
    'countryCode'?: string | null;
    /**
     * Latitude
     * @type {string}
     * @memberof RangeIpUpdate
     */
    'latitude'?: string | null;
    /**
     * Longitude
     * @type {string}
     * @memberof RangeIpUpdate
     */
    'longitude'?: string | null;
    /**
     * Set the IP out to public internet, any value means true
     * @type {boolean}
     * @memberof RangeIpUpdate
     */
    'controlNet'?: boolean;
    /**
     * Optional list of DNS servers
     * @type {Array<string>}
     * @memberof RangeIpUpdate
     */
    'dnsServers'?: Array<string>;
    /**
     * ID of a range L3 network
     * @type {string}
     * @memberof RangeIpUpdate
     */
    'rangeL3Network'?: string;
}
/**
 * 
 * @export
 * @interface RangeL3Network
 */
export interface RangeL3Network {
    /**
     * 
     * @type {string}
     * @memberof RangeL3Network
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof RangeL3Network
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof RangeL3Network
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeL3Network
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeL3Network
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof RangeL3Network
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeL3Network
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeL3Network
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Network CIDR Address
     * @type {string}
     * @memberof RangeL3Network
     */
    'cidr'?: string;
    /**
     * Latitude
     * @type {string}
     * @memberof RangeL3Network
     */
    'latitude'?: string;
    /**
     * Longitude
     * @type {string}
     * @memberof RangeL3Network
     */
    'longitude'?: string;
    /**
     * Network Default Gateway
     * @type {string}
     * @memberof RangeL3Network
     */
    'defaultGateway'?: string | null;
    /**
     * 
     * @type {DHCPConfig}
     * @memberof RangeL3Network
     */
    'dhcpConfig'?: DHCPConfig | null;
    /**
     * Optional ID of a range network
     * @type {string}
     * @memberof RangeL3Network
     */
    'rangeNetwork'?: string | null;
}
/**
 * 
 * @export
 * @interface RangeL3NetworkCreate
 */
export interface RangeL3NetworkCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeL3NetworkCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeL3NetworkCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeL3NetworkCreate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeL3NetworkCreate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Network CIDR Address
     * @type {string}
     * @memberof RangeL3NetworkCreate
     */
    'cidr': string;
    /**
     * Latitude
     * @type {string}
     * @memberof RangeL3NetworkCreate
     */
    'latitude'?: string;
    /**
     * Longitude
     * @type {string}
     * @memberof RangeL3NetworkCreate
     */
    'longitude'?: string;
    /**
     * Network Default Gateway
     * @type {string}
     * @memberof RangeL3NetworkCreate
     */
    'defaultGateway'?: string | null;
    /**
     * 
     * @type {DHCPConfig}
     * @memberof RangeL3NetworkCreate
     */
    'dhcpConfig'?: DHCPConfig | null;
    /**
     * Optional ID of a range network
     * @type {string}
     * @memberof RangeL3NetworkCreate
     */
    'rangeNetwork'?: string | null;
}
/**
 * 
 * @export
 * @interface RangeL3NetworkOverride
 */
export interface RangeL3NetworkOverride {
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeL3NetworkOverride
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeL3NetworkOverride
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Network CIDR Address
     * @type {string}
     * @memberof RangeL3NetworkOverride
     */
    'cidr'?: string;
    /**
     * Latitude
     * @type {string}
     * @memberof RangeL3NetworkOverride
     */
    'latitude'?: string;
    /**
     * Longitude
     * @type {string}
     * @memberof RangeL3NetworkOverride
     */
    'longitude'?: string;
    /**
     * Network Default Gateway
     * @type {string}
     * @memberof RangeL3NetworkOverride
     */
    'defaultGateway'?: string | null;
    /**
     * 
     * @type {DHCPConfig}
     * @memberof RangeL3NetworkOverride
     */
    'dhcpConfig'?: DHCPConfig | null;
}
/**
 * 
 * @export
 * @interface RangeL3NetworkUpdate
 */
export interface RangeL3NetworkUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeL3NetworkUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeL3NetworkUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeL3NetworkUpdate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeL3NetworkUpdate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Network CIDR Address
     * @type {string}
     * @memberof RangeL3NetworkUpdate
     */
    'cidr'?: string;
    /**
     * Latitude
     * @type {string}
     * @memberof RangeL3NetworkUpdate
     */
    'latitude'?: string;
    /**
     * Longitude
     * @type {string}
     * @memberof RangeL3NetworkUpdate
     */
    'longitude'?: string;
    /**
     * Network Default Gateway
     * @type {string}
     * @memberof RangeL3NetworkUpdate
     */
    'defaultGateway'?: string | null;
    /**
     * 
     * @type {DHCPConfig}
     * @memberof RangeL3NetworkUpdate
     */
    'dhcpConfig'?: DHCPConfig | null;
    /**
     * Optional ID of a range network
     * @type {string}
     * @memberof RangeL3NetworkUpdate
     */
    'rangeNetwork'?: string | null;
}
/**
 * 
 * @export
 * @interface RangeL3NetworksList200Response
 */
export interface RangeL3NetworksList200Response {
    /**
     * 
     * @type {number}
     * @memberof RangeL3NetworksList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeL3NetworksList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeL3NetworksList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeL3NetworksList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<RangeL3Network>}
     * @memberof RangeL3NetworksList200Response
     */
    'data'?: Array<RangeL3Network>;
}
/**
 * 
 * @export
 * @interface RangeList200Response
 */
export interface RangeList200Response {
    /**
     * 
     * @type {number}
     * @memberof RangeList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<Range>}
     * @memberof RangeList200Response
     */
    'data'?: Array<Range>;
}
/**
 * 
 * @export
 * @interface RangeNetwork
 */
export interface RangeNetwork {
    /**
     * 
     * @type {string}
     * @memberof RangeNetwork
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof RangeNetwork
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof RangeNetwork
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeNetwork
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeNetwork
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof RangeNetwork
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeNetwork
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeNetwork
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Optional Cluster Range Network. If specified, this Range Network will be linked to a cluster-wide network that can be shared between scenarios.
     * @type {string}
     * @memberof RangeNetwork
     */
    'clusterRangeNetwork'?: string | null;
}
/**
 * 
 * @export
 * @interface RangeNetworkCreate
 */
export interface RangeNetworkCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeNetworkCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeNetworkCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeNetworkCreate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeNetworkCreate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Optional Cluster Range Network. If specified, this Range Network will be linked to a cluster-wide network that can be shared between scenarios.
     * @type {string}
     * @memberof RangeNetworkCreate
     */
    'clusterRangeNetwork'?: string | null;
}
/**
 * 
 * @export
 * @interface RangeNetworkOverride
 */
export interface RangeNetworkOverride {
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeNetworkOverride
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeNetworkOverride
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
}
/**
 * 
 * @export
 * @interface RangeNetworkUpdate
 */
export interface RangeNetworkUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeNetworkUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeNetworkUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeNetworkUpdate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeNetworkUpdate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Optional Cluster Range Network. If specified, this Range Network will be linked to a cluster-wide network that can be shared between scenarios.
     * @type {string}
     * @memberof RangeNetworkUpdate
     */
    'clusterRangeNetwork'?: string | null;
}
/**
 * 
 * @export
 * @interface RangeNetworksList200Response
 */
export interface RangeNetworksList200Response {
    /**
     * 
     * @type {number}
     * @memberof RangeNetworksList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeNetworksList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeNetworksList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeNetworksList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<RangeNetwork>}
     * @memberof RangeNetworksList200Response
     */
    'data'?: Array<RangeNetwork>;
}
/**
 * 
 * @export
 * @interface RangeNode
 */
export interface RangeNode {
    /**
     * Range ID
     * @type {string}
     * @memberof RangeNode
     */
    'rangeId'?: string;
    /**
     * Range nodes
     * @type {Array<Node>}
     * @memberof RangeNode
     */
    'nodes'?: Array<Node>;
}
/**
 * 
 * @export
 * @interface RangePkIsList200Response
 */
export interface RangePkIsList200Response {
    /**
     * 
     * @type {number}
     * @memberof RangePkIsList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangePkIsList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangePkIsList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangePkIsList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<RangePki>}
     * @memberof RangePkIsList200Response
     */
    'data'?: Array<RangePki>;
}
/**
 * 
 * @export
 * @interface RangePki
 */
export interface RangePki {
    /**
     * 
     * @type {string}
     * @memberof RangePki
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof RangePki
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof RangePki
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangePki
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangePki
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof RangePki
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangePki
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangePki
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * 
     * @type {RangePkiCertificateProfile}
     * @memberof RangePki
     */
    'certificates'?: RangePkiCertificateProfile;
    /**
     * 
     * @type {RangePkiIntermediateProfile}
     * @memberof RangePki
     */
    'intermediate'?: RangePkiIntermediateProfile;
    /**
     * 
     * @type {Array<string>}
     * @memberof RangePki
     */
    'hosts'?: Array<string>;
    /**
     * 
     * @type {Array<RangePkiCertificateSubject>}
     * @memberof RangePki
     */
    'names'?: Array<RangePkiCertificateSubject>;
    /**
     * 
     * @type {KeyRequest}
     * @memberof RangePki
     */
    'key'?: KeyRequest | null;
    /**
     * 
     * @type {string}
     * @memberof RangePki
     */
    'cN'?: string | null;
    /**
     * 
     * @type {RangePkiKeyPair}
     * @memberof RangePki
     */
    'keyPairData'?: RangePkiKeyPair | null;
    /**
     * The signing profile for the signer for bundling
     * @type {string}
     * @memberof RangePki
     */
    'bundleProfile'?: string;
    /**
     * The name of the Pki to sign the current CSR
     * @type {string}
     * @memberof RangePki
     */
    'parentCAHost'?: string | null;
}
/**
 * 
 * @export
 * @interface RangePkiCertificateProfile
 */
export interface RangePkiCertificateProfile {
    /**
     * 
     * @type {Array<string>}
     * @memberof RangePkiCertificateProfile
     */
    'usages'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RangePkiCertificateProfile
     */
    'expiry'?: string;
}
/**
 * 
 * @export
 * @interface RangePkiCertificateSubject
 */
export interface RangePkiCertificateSubject {
    /**
     * 
     * @type {string}
     * @memberof RangePkiCertificateSubject
     */
    'c'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangePkiCertificateSubject
     */
    'sT'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangePkiCertificateSubject
     */
    'l'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangePkiCertificateSubject
     */
    'o'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangePkiCertificateSubject
     */
    'oU'?: string;
}
/**
 * 
 * @export
 * @interface RangePkiCreate
 */
export interface RangePkiCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangePkiCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangePkiCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangePkiCreate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangePkiCreate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * 
     * @type {RangePkiCertificateProfile}
     * @memberof RangePkiCreate
     */
    'certificates': RangePkiCertificateProfile;
    /**
     * 
     * @type {RangePkiIntermediateProfile}
     * @memberof RangePkiCreate
     */
    'intermediate': RangePkiIntermediateProfile;
    /**
     * 
     * @type {Array<string>}
     * @memberof RangePkiCreate
     */
    'hosts': Array<string>;
    /**
     * 
     * @type {Array<RangePkiCertificateSubject>}
     * @memberof RangePkiCreate
     */
    'names': Array<RangePkiCertificateSubject>;
    /**
     * 
     * @type {KeyRequest}
     * @memberof RangePkiCreate
     */
    'key'?: KeyRequest | null;
    /**
     * 
     * @type {string}
     * @memberof RangePkiCreate
     */
    'cN'?: string | null;
    /**
     * 
     * @type {RangePkiKeyPair}
     * @memberof RangePkiCreate
     */
    'keyPairData'?: RangePkiKeyPair | null;
    /**
     * The signing profile for the signer for bundling
     * @type {string}
     * @memberof RangePkiCreate
     */
    'bundleProfile'?: string;
    /**
     * The name of the Pki to sign the current CSR
     * @type {string}
     * @memberof RangePkiCreate
     */
    'parentCAHost'?: string | null;
}
/**
 * 
 * @export
 * @interface RangePkiIntermediateProfile
 */
export interface RangePkiIntermediateProfile {
    /**
     * 
     * @type {string}
     * @memberof RangePkiIntermediateProfile
     */
    'expiry'?: string;
}
/**
 * 
 * @export
 * @interface RangePkiKeyPair
 */
export interface RangePkiKeyPair {
    /**
     * 
     * @type {string}
     * @memberof RangePkiKeyPair
     */
    'publicKey': string;
    /**
     * 
     * @type {string}
     * @memberof RangePkiKeyPair
     */
    'privateKey': string;
}
/**
 * 
 * @export
 * @interface RangePkiOverride
 */
export interface RangePkiOverride {
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangePkiOverride
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangePkiOverride
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * 
     * @type {RangePkiCertificateProfile}
     * @memberof RangePkiOverride
     */
    'certificates'?: RangePkiCertificateProfile;
    /**
     * 
     * @type {RangePkiIntermediateProfile}
     * @memberof RangePkiOverride
     */
    'intermediate'?: RangePkiIntermediateProfile;
    /**
     * 
     * @type {Array<string>}
     * @memberof RangePkiOverride
     */
    'hosts'?: Array<string>;
    /**
     * 
     * @type {Array<RangePkiCertificateSubject>}
     * @memberof RangePkiOverride
     */
    'names'?: Array<RangePkiCertificateSubject>;
    /**
     * 
     * @type {KeyRequest}
     * @memberof RangePkiOverride
     */
    'key'?: KeyRequest | null;
    /**
     * 
     * @type {string}
     * @memberof RangePkiOverride
     */
    'cN'?: string | null;
    /**
     * 
     * @type {RangePkiKeyPair}
     * @memberof RangePkiOverride
     */
    'keyPairData'?: RangePkiKeyPair | null;
    /**
     * The signing profile for the signer for bundling
     * @type {string}
     * @memberof RangePkiOverride
     */
    'bundleProfile'?: string;
}
/**
 * 
 * @export
 * @interface RangePkiUpdate
 */
export interface RangePkiUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangePkiUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangePkiUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangePkiUpdate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangePkiUpdate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * 
     * @type {RangePkiCertificateProfile}
     * @memberof RangePkiUpdate
     */
    'certificates'?: RangePkiCertificateProfile;
    /**
     * 
     * @type {RangePkiIntermediateProfile}
     * @memberof RangePkiUpdate
     */
    'intermediate'?: RangePkiIntermediateProfile;
    /**
     * 
     * @type {Array<string>}
     * @memberof RangePkiUpdate
     */
    'hosts'?: Array<string>;
    /**
     * 
     * @type {Array<RangePkiCertificateSubject>}
     * @memberof RangePkiUpdate
     */
    'names'?: Array<RangePkiCertificateSubject>;
    /**
     * 
     * @type {KeyRequest}
     * @memberof RangePkiUpdate
     */
    'key'?: KeyRequest | null;
    /**
     * 
     * @type {string}
     * @memberof RangePkiUpdate
     */
    'cN'?: string | null;
    /**
     * 
     * @type {RangePkiKeyPair}
     * @memberof RangePkiUpdate
     */
    'keyPairData'?: RangePkiKeyPair | null;
    /**
     * The signing profile for the signer for bundling
     * @type {string}
     * @memberof RangePkiUpdate
     */
    'bundleProfile'?: string;
    /**
     * The name of the Pki to sign the current CSR
     * @type {string}
     * @memberof RangePkiUpdate
     */
    'parentCAHost'?: string | null;
}
/**
 * 
 * @export
 * @interface RangeRangeBillingRequest
 */
export interface RangeRangeBillingRequest {
    /**
     * 
     * @type {string}
     * @memberof RangeRangeBillingRequest
     */
    'regionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangeRangeBillingRequest
     */
    'startDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof RangeRangeBillingRequest
     */
    'endDate'?: string;
}
/**
 * RangeResource
 * @export
 * @interface RangeResource
 */
export interface RangeResource {
    /**
     * Kind of resource
     * @type {string}
     * @memberof RangeResource
     */
    'kind'?: string;
    /**
     * Name of resource
     * @type {string}
     * @memberof RangeResource
     */
    'name'?: string;
    /**
     * Indicates the status of the range. Ready, Creating, Deleting, Error, or Unknown
     * @type {string}
     * @memberof RangeResource
     */
    'status'?: RangeResourceStatusEnum;
    /**
     * Displays error message if an error has occurred while creating the range.
     * @type {string}
     * @memberof RangeResource
     */
    'message'?: string;
}

export const RangeResourceStatusEnum = {
    Unknown: 'Unknown',
    Ready: 'Ready',
    NotReady: 'NotReady',
    Creating: 'Creating',
    Error: 'Error',
    Deleting: 'Deleting',
    Stopped: 'Stopped'
} as const;

export type RangeResourceStatusEnum = typeof RangeResourceStatusEnum[keyof typeof RangeResourceStatusEnum];

/**
 * 
 * @export
 * @interface RangeResourcesList200Response
 */
export interface RangeResourcesList200Response {
    /**
     * 
     * @type {number}
     * @memberof RangeResourcesList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeResourcesList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeResourcesList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeResourcesList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<RangeResource>}
     * @memberof RangeResourcesList200Response
     */
    'data'?: Array<RangeResource>;
}
/**
 * 
 * @export
 * @interface RangeRouter
 */
export interface RangeRouter {
    /**
     * 
     * @type {string}
     * @memberof RangeRouter
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof RangeRouter
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof RangeRouter
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeRouter
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeRouter
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof RangeRouter
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeRouter
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeRouter
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Hostname of the router instance
     * @type {string}
     * @memberof RangeRouter
     */
    'hostname'?: string;
    /**
     * Country Code
     * @type {string}
     * @memberof RangeRouter
     */
    'countryCode'?: string | null;
    /**
     * Latitude
     * @type {string}
     * @memberof RangeRouter
     */
    'latitude'?: string | null;
    /**
     * Longitude
     * @type {string}
     * @memberof RangeRouter
     */
    'longitude'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof RangeRouter
     */
    'protocols'?: Array<RangeRouterProtocolsEnum>;
    /**
     * Network interfaces
     * @type {Array<RangeRouterInterface>}
     * @memberof RangeRouter
     */
    'interfaces'?: Array<RangeRouterInterface>;
}

export const RangeRouterProtocolsEnum = {
    Ospf: 'ospf',
    Rip: 'rip',
    Bgp: 'bgp'
} as const;

export type RangeRouterProtocolsEnum = typeof RangeRouterProtocolsEnum[keyof typeof RangeRouterProtocolsEnum];

/**
 * 
 * @export
 * @interface RangeRouterCreate
 */
export interface RangeRouterCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeRouterCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeRouterCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeRouterCreate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeRouterCreate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Hostname of the router instance
     * @type {string}
     * @memberof RangeRouterCreate
     */
    'hostname': string;
    /**
     * Country Code
     * @type {string}
     * @memberof RangeRouterCreate
     */
    'countryCode'?: string | null;
    /**
     * Latitude
     * @type {string}
     * @memberof RangeRouterCreate
     */
    'latitude'?: string | null;
    /**
     * Longitude
     * @type {string}
     * @memberof RangeRouterCreate
     */
    'longitude'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof RangeRouterCreate
     */
    'protocols': Array<RangeRouterCreateProtocolsEnum>;
    /**
     * Network interfaces
     * @type {Array<RangeRouterInterfaceCreate>}
     * @memberof RangeRouterCreate
     */
    'interfaces': Array<RangeRouterInterfaceCreate>;
}

export const RangeRouterCreateProtocolsEnum = {
    Ospf: 'ospf',
    Rip: 'rip',
    Bgp: 'bgp'
} as const;

export type RangeRouterCreateProtocolsEnum = typeof RangeRouterCreateProtocolsEnum[keyof typeof RangeRouterCreateProtocolsEnum];

/**
 * 
 * @export
 * @interface RangeRouterInterface
 */
export interface RangeRouterInterface {
    /**
     * 
     * @type {RangeRouterInterfaceType}
     * @memberof RangeRouterInterface
     */
    'interfaceType'?: RangeRouterInterfaceType | null;
    /**
     * IP addresses assigned to the interface
     * @type {Array<string>}
     * @memberof RangeRouterInterface
     */
    'rangeIPs'?: Array<string>;
    /**
     * Optional ID of a range network
     * @type {string}
     * @memberof RangeRouterInterface
     */
    'rangeNetwork'?: string | null;
}


/**
 * 
 * @export
 * @interface RangeRouterInterfaceCreate
 */
export interface RangeRouterInterfaceCreate {
    /**
     * 
     * @type {RangeRouterInterfaceType}
     * @memberof RangeRouterInterfaceCreate
     */
    'interfaceType'?: RangeRouterInterfaceType | null;
    /**
     * IP addresses assigned to the interface
     * @type {Array<string>}
     * @memberof RangeRouterInterfaceCreate
     */
    'rangeIPs'?: Array<string>;
    /**
     * Optional ID of a range network
     * @type {string}
     * @memberof RangeRouterInterfaceCreate
     */
    'rangeNetwork'?: string | null;
}


/**
 * Optional interface type
 * @export
 * @enum {string}
 */

export const RangeRouterInterfaceType = {
    Bgp: 'bgp',
    External: 'external',
    Service: 'service'
} as const;

export type RangeRouterInterfaceType = typeof RangeRouterInterfaceType[keyof typeof RangeRouterInterfaceType];


/**
 * 
 * @export
 * @interface RangeRouterInterfaceUpdate
 */
export interface RangeRouterInterfaceUpdate {
    /**
     * 
     * @type {RangeRouterInterfaceType}
     * @memberof RangeRouterInterfaceUpdate
     */
    'interfaceType'?: RangeRouterInterfaceType | null;
    /**
     * IP addresses assigned to the interface
     * @type {Array<string>}
     * @memberof RangeRouterInterfaceUpdate
     */
    'rangeIPs'?: Array<string>;
    /**
     * Optional ID of a range network
     * @type {string}
     * @memberof RangeRouterInterfaceUpdate
     */
    'rangeNetwork'?: string | null;
}


/**
 * 
 * @export
 * @interface RangeRouterOverride
 */
export interface RangeRouterOverride {
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeRouterOverride
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeRouterOverride
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Hostname of the router instance
     * @type {string}
     * @memberof RangeRouterOverride
     */
    'hostname'?: string;
    /**
     * Country Code
     * @type {string}
     * @memberof RangeRouterOverride
     */
    'countryCode'?: string | null;
    /**
     * Latitude
     * @type {string}
     * @memberof RangeRouterOverride
     */
    'latitude'?: string | null;
    /**
     * Longitude
     * @type {string}
     * @memberof RangeRouterOverride
     */
    'longitude'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof RangeRouterOverride
     */
    'protocols'?: Array<RangeRouterOverrideProtocolsEnum>;
}

export const RangeRouterOverrideProtocolsEnum = {
    Ospf: 'ospf',
    Rip: 'rip',
    Bgp: 'bgp'
} as const;

export type RangeRouterOverrideProtocolsEnum = typeof RangeRouterOverrideProtocolsEnum[keyof typeof RangeRouterOverrideProtocolsEnum];

/**
 * 
 * @export
 * @interface RangeRouterUpdate
 */
export interface RangeRouterUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeRouterUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeRouterUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeRouterUpdate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeRouterUpdate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Hostname of the router instance
     * @type {string}
     * @memberof RangeRouterUpdate
     */
    'hostname'?: string;
    /**
     * Country Code
     * @type {string}
     * @memberof RangeRouterUpdate
     */
    'countryCode'?: string | null;
    /**
     * Latitude
     * @type {string}
     * @memberof RangeRouterUpdate
     */
    'latitude'?: string | null;
    /**
     * Longitude
     * @type {string}
     * @memberof RangeRouterUpdate
     */
    'longitude'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof RangeRouterUpdate
     */
    'protocols'?: Array<RangeRouterUpdateProtocolsEnum>;
    /**
     * Network interfaces
     * @type {Array<RangeRouterInterfaceUpdate>}
     * @memberof RangeRouterUpdate
     */
    'interfaces'?: Array<RangeRouterInterfaceUpdate>;
}

export const RangeRouterUpdateProtocolsEnum = {
    Ospf: 'ospf',
    Rip: 'rip',
    Bgp: 'bgp'
} as const;

export type RangeRouterUpdateProtocolsEnum = typeof RangeRouterUpdateProtocolsEnum[keyof typeof RangeRouterUpdateProtocolsEnum];

/**
 * 
 * @export
 * @interface RangeRoutersList200Response
 */
export interface RangeRoutersList200Response {
    /**
     * 
     * @type {number}
     * @memberof RangeRoutersList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeRoutersList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeRoutersList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeRoutersList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<RangeRouter>}
     * @memberof RangeRoutersList200Response
     */
    'data'?: Array<RangeRouter>;
}
/**
 * AWS Range Specification
 * @export
 * @interface RangeSpecificationAws
 */
export interface RangeSpecificationAws {
    /**
     * 
     * @type {string}
     * @memberof RangeSpecificationAws
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof RangeSpecificationAws
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof RangeSpecificationAws
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeSpecificationAws
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeSpecificationAws
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof RangeSpecificationAws
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeSpecificationAws
     */
    'metadata'?: object;
    /**
     * Environment credentials ID
     * @type {string}
     * @memberof RangeSpecificationAws
     */
    'environmentCredential'?: string;
    /**
     * Kubernetes version
     * @type {string}
     * @memberof RangeSpecificationAws
     */
    'kubernetesVersion'?: RangeSpecificationAwsKubernetesVersionEnum;
    /**
     * Container Network
     * @type {string}
     * @memberof RangeSpecificationAws
     */
    'cni'?: RangeSpecificationAwsCniEnum;
    /**
     * Optional kube API server arguments
     * @type {Array<string>}
     * @memberof RangeSpecificationAws
     */
    'kubeApiserverArg'?: Array<string>;
    /**
     * Optional kube controller manager arguments
     * @type {Array<string>}
     * @memberof RangeSpecificationAws
     */
    'kubeControllerManagerArg'?: Array<string>;
    /**
     * Optional kubelet arguments
     * @type {Array<string>}
     * @memberof RangeSpecificationAws
     */
    'kubeletArg'?: Array<string>;
    /**
     * Optional CIDR of the cluster pod network
     * @type {string}
     * @memberof RangeSpecificationAws
     */
    'clusterCidr'?: string | null;
    /**
     * Optional CIDR of the cluster service network
     * @type {string}
     * @memberof RangeSpecificationAws
     */
    'serviceCidr'?: string | null;
    /**
     * Optional default container registry used during cluster provisioning
     * @type {string}
     * @memberof RangeSpecificationAws
     */
    'systemDefaultRegistry'?: string | null;
    /**
     * 
     * @type {Registries}
     * @memberof RangeSpecificationAws
     */
    'registries'?: Registries | null;
    /**
     * Cluster machine pools
     * @type {Array<AwsMachinePool>}
     * @memberof RangeSpecificationAws
     */
    'machinePools'?: Array<AwsMachinePool>;
    /**
     * If true, disable cloud controller
     * @type {boolean}
     * @memberof RangeSpecificationAws
     */
    'disableCloudController'?: boolean;
}

export const RangeSpecificationAwsKubernetesVersionEnum = {
    V12615rke2r1: 'v1.26.15+rke2r1'
} as const;

export type RangeSpecificationAwsKubernetesVersionEnum = typeof RangeSpecificationAwsKubernetesVersionEnum[keyof typeof RangeSpecificationAwsKubernetesVersionEnum];
export const RangeSpecificationAwsCniEnum = {
    Canal: 'canal',
    Cilium: 'cilium',
    Calico: 'calico',
    Multuscanal: 'multus,canal',
    Multuscilium: 'multus,cilium',
    Multuscalico: 'multus,calico'
} as const;

export type RangeSpecificationAwsCniEnum = typeof RangeSpecificationAwsCniEnum[keyof typeof RangeSpecificationAwsCniEnum];

/**
 * AWS Range Specification
 * @export
 * @interface RangeSpecificationAwsCreate
 */
export interface RangeSpecificationAwsCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeSpecificationAwsCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeSpecificationAwsCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeSpecificationAwsCreate
     */
    'metadata'?: object;
    /**
     * Environment credentials ID
     * @type {string}
     * @memberof RangeSpecificationAwsCreate
     */
    'environmentCredential': string;
    /**
     * Kubernetes version
     * @type {string}
     * @memberof RangeSpecificationAwsCreate
     */
    'kubernetesVersion': RangeSpecificationAwsCreateKubernetesVersionEnum;
    /**
     * Container Network
     * @type {string}
     * @memberof RangeSpecificationAwsCreate
     */
    'cni'?: RangeSpecificationAwsCreateCniEnum;
    /**
     * Optional kube API server arguments
     * @type {Array<string>}
     * @memberof RangeSpecificationAwsCreate
     */
    'kubeApiserverArg'?: Array<string>;
    /**
     * Optional kube controller manager arguments
     * @type {Array<string>}
     * @memberof RangeSpecificationAwsCreate
     */
    'kubeControllerManagerArg'?: Array<string>;
    /**
     * Optional kubelet arguments
     * @type {Array<string>}
     * @memberof RangeSpecificationAwsCreate
     */
    'kubeletArg'?: Array<string>;
    /**
     * Optional CIDR of the cluster pod network
     * @type {string}
     * @memberof RangeSpecificationAwsCreate
     */
    'clusterCidr'?: string | null;
    /**
     * Optional CIDR of the cluster service network
     * @type {string}
     * @memberof RangeSpecificationAwsCreate
     */
    'serviceCidr'?: string | null;
    /**
     * Optional default container registry used during cluster provisioning
     * @type {string}
     * @memberof RangeSpecificationAwsCreate
     */
    'systemDefaultRegistry'?: string | null;
    /**
     * 
     * @type {Registries}
     * @memberof RangeSpecificationAwsCreate
     */
    'registries'?: Registries | null;
    /**
     * Cluster machine pools
     * @type {Array<AwsMachinePoolCreate>}
     * @memberof RangeSpecificationAwsCreate
     */
    'machinePools'?: Array<AwsMachinePoolCreate>;
    /**
     * If true, disable cloud controller
     * @type {boolean}
     * @memberof RangeSpecificationAwsCreate
     */
    'disableCloudController'?: boolean;
}

export const RangeSpecificationAwsCreateKubernetesVersionEnum = {
    V12615rke2r1: 'v1.26.15+rke2r1'
} as const;

export type RangeSpecificationAwsCreateKubernetesVersionEnum = typeof RangeSpecificationAwsCreateKubernetesVersionEnum[keyof typeof RangeSpecificationAwsCreateKubernetesVersionEnum];
export const RangeSpecificationAwsCreateCniEnum = {
    Canal: 'canal',
    Cilium: 'cilium',
    Calico: 'calico',
    Multuscanal: 'multus,canal',
    Multuscilium: 'multus,cilium',
    Multuscalico: 'multus,calico'
} as const;

export type RangeSpecificationAwsCreateCniEnum = typeof RangeSpecificationAwsCreateCniEnum[keyof typeof RangeSpecificationAwsCreateCniEnum];

/**
 * AWS Range Specification
 * @export
 * @interface RangeSpecificationAwsUpdate
 */
export interface RangeSpecificationAwsUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeSpecificationAwsUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeSpecificationAwsUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeSpecificationAwsUpdate
     */
    'metadata'?: object;
    /**
     * Environment credentials ID
     * @type {string}
     * @memberof RangeSpecificationAwsUpdate
     */
    'environmentCredential'?: string;
    /**
     * Kubernetes version
     * @type {string}
     * @memberof RangeSpecificationAwsUpdate
     */
    'kubernetesVersion'?: RangeSpecificationAwsUpdateKubernetesVersionEnum;
    /**
     * Container Network
     * @type {string}
     * @memberof RangeSpecificationAwsUpdate
     */
    'cni'?: RangeSpecificationAwsUpdateCniEnum;
    /**
     * Optional kube API server arguments
     * @type {Array<string>}
     * @memberof RangeSpecificationAwsUpdate
     */
    'kubeApiserverArg'?: Array<string>;
    /**
     * Optional kube controller manager arguments
     * @type {Array<string>}
     * @memberof RangeSpecificationAwsUpdate
     */
    'kubeControllerManagerArg'?: Array<string>;
    /**
     * Optional kubelet arguments
     * @type {Array<string>}
     * @memberof RangeSpecificationAwsUpdate
     */
    'kubeletArg'?: Array<string>;
    /**
     * Optional CIDR of the cluster pod network
     * @type {string}
     * @memberof RangeSpecificationAwsUpdate
     */
    'clusterCidr'?: string | null;
    /**
     * Optional CIDR of the cluster service network
     * @type {string}
     * @memberof RangeSpecificationAwsUpdate
     */
    'serviceCidr'?: string | null;
    /**
     * Optional default container registry used during cluster provisioning
     * @type {string}
     * @memberof RangeSpecificationAwsUpdate
     */
    'systemDefaultRegistry'?: string | null;
    /**
     * 
     * @type {Registries}
     * @memberof RangeSpecificationAwsUpdate
     */
    'registries'?: Registries | null;
    /**
     * Cluster machine pools
     * @type {Array<AwsMachinePoolUpdate>}
     * @memberof RangeSpecificationAwsUpdate
     */
    'machinePools'?: Array<AwsMachinePoolUpdate>;
    /**
     * If true, disable cloud controller
     * @type {boolean}
     * @memberof RangeSpecificationAwsUpdate
     */
    'disableCloudController'?: boolean;
}

export const RangeSpecificationAwsUpdateKubernetesVersionEnum = {
    V12615rke2r1: 'v1.26.15+rke2r1'
} as const;

export type RangeSpecificationAwsUpdateKubernetesVersionEnum = typeof RangeSpecificationAwsUpdateKubernetesVersionEnum[keyof typeof RangeSpecificationAwsUpdateKubernetesVersionEnum];
export const RangeSpecificationAwsUpdateCniEnum = {
    Canal: 'canal',
    Cilium: 'cilium',
    Calico: 'calico',
    Multuscanal: 'multus,canal',
    Multuscilium: 'multus,cilium',
    Multuscalico: 'multus,calico'
} as const;

export type RangeSpecificationAwsUpdateCniEnum = typeof RangeSpecificationAwsUpdateCniEnum[keyof typeof RangeSpecificationAwsUpdateCniEnum];

/**
 * Vsphere Range Specification
 * @export
 * @interface RangeSpecificationVsphere
 */
export interface RangeSpecificationVsphere {
    /**
     * 
     * @type {string}
     * @memberof RangeSpecificationVsphere
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof RangeSpecificationVsphere
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof RangeSpecificationVsphere
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeSpecificationVsphere
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeSpecificationVsphere
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof RangeSpecificationVsphere
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeSpecificationVsphere
     */
    'metadata'?: object;
    /**
     * Environment credentials ID
     * @type {string}
     * @memberof RangeSpecificationVsphere
     */
    'environmentCredential'?: string;
    /**
     * Kubernetes version
     * @type {string}
     * @memberof RangeSpecificationVsphere
     */
    'kubernetesVersion'?: RangeSpecificationVsphereKubernetesVersionEnum;
    /**
     * Container Network
     * @type {string}
     * @memberof RangeSpecificationVsphere
     */
    'cni'?: RangeSpecificationVsphereCniEnum;
    /**
     * Optional kube API server arguments
     * @type {Array<string>}
     * @memberof RangeSpecificationVsphere
     */
    'kubeApiserverArg'?: Array<string>;
    /**
     * Optional kube controller manager arguments
     * @type {Array<string>}
     * @memberof RangeSpecificationVsphere
     */
    'kubeControllerManagerArg'?: Array<string>;
    /**
     * Optional kubelet arguments
     * @type {Array<string>}
     * @memberof RangeSpecificationVsphere
     */
    'kubeletArg'?: Array<string>;
    /**
     * Optional CIDR of the cluster pod network
     * @type {string}
     * @memberof RangeSpecificationVsphere
     */
    'clusterCidr'?: string | null;
    /**
     * Optional CIDR of the cluster service network
     * @type {string}
     * @memberof RangeSpecificationVsphere
     */
    'serviceCidr'?: string | null;
    /**
     * Optional default container registry used during cluster provisioning
     * @type {string}
     * @memberof RangeSpecificationVsphere
     */
    'systemDefaultRegistry'?: string | null;
    /**
     * 
     * @type {Registries}
     * @memberof RangeSpecificationVsphere
     */
    'registries'?: Registries | null;
    /**
     * Cluster machine pools
     * @type {Array<VsphereMachinePool>}
     * @memberof RangeSpecificationVsphere
     */
    'machinePools'?: Array<VsphereMachinePool>;
}

export const RangeSpecificationVsphereKubernetesVersionEnum = {
    V12615rke2r1: 'v1.26.15+rke2r1'
} as const;

export type RangeSpecificationVsphereKubernetesVersionEnum = typeof RangeSpecificationVsphereKubernetesVersionEnum[keyof typeof RangeSpecificationVsphereKubernetesVersionEnum];
export const RangeSpecificationVsphereCniEnum = {
    Canal: 'canal',
    Cilium: 'cilium',
    Calico: 'calico',
    Multuscanal: 'multus,canal',
    Multuscilium: 'multus,cilium',
    Multuscalico: 'multus,calico'
} as const;

export type RangeSpecificationVsphereCniEnum = typeof RangeSpecificationVsphereCniEnum[keyof typeof RangeSpecificationVsphereCniEnum];

/**
 * Vsphere Range Specification
 * @export
 * @interface RangeSpecificationVsphereCreate
 */
export interface RangeSpecificationVsphereCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeSpecificationVsphereCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeSpecificationVsphereCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeSpecificationVsphereCreate
     */
    'metadata'?: object;
    /**
     * Environment credentials ID
     * @type {string}
     * @memberof RangeSpecificationVsphereCreate
     */
    'environmentCredential': string;
    /**
     * Kubernetes version
     * @type {string}
     * @memberof RangeSpecificationVsphereCreate
     */
    'kubernetesVersion': RangeSpecificationVsphereCreateKubernetesVersionEnum;
    /**
     * Container Network
     * @type {string}
     * @memberof RangeSpecificationVsphereCreate
     */
    'cni'?: RangeSpecificationVsphereCreateCniEnum;
    /**
     * Optional kube API server arguments
     * @type {Array<string>}
     * @memberof RangeSpecificationVsphereCreate
     */
    'kubeApiserverArg'?: Array<string>;
    /**
     * Optional kube controller manager arguments
     * @type {Array<string>}
     * @memberof RangeSpecificationVsphereCreate
     */
    'kubeControllerManagerArg'?: Array<string>;
    /**
     * Optional kubelet arguments
     * @type {Array<string>}
     * @memberof RangeSpecificationVsphereCreate
     */
    'kubeletArg'?: Array<string>;
    /**
     * Optional CIDR of the cluster pod network
     * @type {string}
     * @memberof RangeSpecificationVsphereCreate
     */
    'clusterCidr'?: string | null;
    /**
     * Optional CIDR of the cluster service network
     * @type {string}
     * @memberof RangeSpecificationVsphereCreate
     */
    'serviceCidr'?: string | null;
    /**
     * Optional default container registry used during cluster provisioning
     * @type {string}
     * @memberof RangeSpecificationVsphereCreate
     */
    'systemDefaultRegistry'?: string | null;
    /**
     * 
     * @type {Registries}
     * @memberof RangeSpecificationVsphereCreate
     */
    'registries'?: Registries | null;
    /**
     * Cluster machine pools
     * @type {Array<VsphereMachinePoolCreate>}
     * @memberof RangeSpecificationVsphereCreate
     */
    'machinePools'?: Array<VsphereMachinePoolCreate>;
}

export const RangeSpecificationVsphereCreateKubernetesVersionEnum = {
    V12615rke2r1: 'v1.26.15+rke2r1'
} as const;

export type RangeSpecificationVsphereCreateKubernetesVersionEnum = typeof RangeSpecificationVsphereCreateKubernetesVersionEnum[keyof typeof RangeSpecificationVsphereCreateKubernetesVersionEnum];
export const RangeSpecificationVsphereCreateCniEnum = {
    Canal: 'canal',
    Cilium: 'cilium',
    Calico: 'calico',
    Multuscanal: 'multus,canal',
    Multuscilium: 'multus,cilium',
    Multuscalico: 'multus,calico'
} as const;

export type RangeSpecificationVsphereCreateCniEnum = typeof RangeSpecificationVsphereCreateCniEnum[keyof typeof RangeSpecificationVsphereCreateCniEnum];

/**
 * Vsphere Range Specification
 * @export
 * @interface RangeSpecificationVsphereUpdate
 */
export interface RangeSpecificationVsphereUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeSpecificationVsphereUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeSpecificationVsphereUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeSpecificationVsphereUpdate
     */
    'metadata'?: object;
    /**
     * Environment credentials ID
     * @type {string}
     * @memberof RangeSpecificationVsphereUpdate
     */
    'environmentCredential'?: string;
    /**
     * Kubernetes version
     * @type {string}
     * @memberof RangeSpecificationVsphereUpdate
     */
    'kubernetesVersion'?: RangeSpecificationVsphereUpdateKubernetesVersionEnum;
    /**
     * Container Network
     * @type {string}
     * @memberof RangeSpecificationVsphereUpdate
     */
    'cni'?: RangeSpecificationVsphereUpdateCniEnum;
    /**
     * Optional kube API server arguments
     * @type {Array<string>}
     * @memberof RangeSpecificationVsphereUpdate
     */
    'kubeApiserverArg'?: Array<string>;
    /**
     * Optional kube controller manager arguments
     * @type {Array<string>}
     * @memberof RangeSpecificationVsphereUpdate
     */
    'kubeControllerManagerArg'?: Array<string>;
    /**
     * Optional kubelet arguments
     * @type {Array<string>}
     * @memberof RangeSpecificationVsphereUpdate
     */
    'kubeletArg'?: Array<string>;
    /**
     * Optional CIDR of the cluster pod network
     * @type {string}
     * @memberof RangeSpecificationVsphereUpdate
     */
    'clusterCidr'?: string | null;
    /**
     * Optional CIDR of the cluster service network
     * @type {string}
     * @memberof RangeSpecificationVsphereUpdate
     */
    'serviceCidr'?: string | null;
    /**
     * Optional default container registry used during cluster provisioning
     * @type {string}
     * @memberof RangeSpecificationVsphereUpdate
     */
    'systemDefaultRegistry'?: string | null;
    /**
     * 
     * @type {Registries}
     * @memberof RangeSpecificationVsphereUpdate
     */
    'registries'?: Registries | null;
    /**
     * Cluster machine pools
     * @type {Array<VsphereMachinePoolUpdate>}
     * @memberof RangeSpecificationVsphereUpdate
     */
    'machinePools'?: Array<VsphereMachinePoolUpdate>;
}

export const RangeSpecificationVsphereUpdateKubernetesVersionEnum = {
    V12615rke2r1: 'v1.26.15+rke2r1'
} as const;

export type RangeSpecificationVsphereUpdateKubernetesVersionEnum = typeof RangeSpecificationVsphereUpdateKubernetesVersionEnum[keyof typeof RangeSpecificationVsphereUpdateKubernetesVersionEnum];
export const RangeSpecificationVsphereUpdateCniEnum = {
    Canal: 'canal',
    Cilium: 'cilium',
    Calico: 'calico',
    Multuscanal: 'multus,canal',
    Multuscilium: 'multus,cilium',
    Multuscalico: 'multus,calico'
} as const;

export type RangeSpecificationVsphereUpdateCniEnum = typeof RangeSpecificationVsphereUpdateCniEnum[keyof typeof RangeSpecificationVsphereUpdateCniEnum];

/**
 * 
 * @export
 * @interface RangeTorNet
 */
export interface RangeTorNet {
    /**
     * 
     * @type {string}
     * @memberof RangeTorNet
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof RangeTorNet
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof RangeTorNet
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeTorNet
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeTorNet
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof RangeTorNet
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeTorNet
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeTorNet
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Tor version
     * @type {string}
     * @memberof RangeTorNet
     */
    'version'?: RangeTorNetVersionEnum;
    /**
     * Tor directory authorities
     * @type {Array<RangeTorNode>}
     * @memberof RangeTorNet
     */
    'directoryAuthorities'?: Array<RangeTorNode>;
    /**
     * Tor relays
     * @type {Array<RangeTorNode>}
     * @memberof RangeTorNet
     */
    'relays'?: Array<RangeTorNode>;
    /**
     * Tor exit nodes
     * @type {Array<RangeTorNode>}
     * @memberof RangeTorNet
     */
    'exitNodes'?: Array<RangeTorNode>;
}

export const RangeTorNetVersionEnum = {
    _04711: '0.4.7.11'
} as const;

export type RangeTorNetVersionEnum = typeof RangeTorNetVersionEnum[keyof typeof RangeTorNetVersionEnum];

/**
 * 
 * @export
 * @interface RangeTorNetCreate
 */
export interface RangeTorNetCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeTorNetCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeTorNetCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeTorNetCreate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeTorNetCreate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Tor version
     * @type {string}
     * @memberof RangeTorNetCreate
     */
    'version': RangeTorNetCreateVersionEnum;
    /**
     * Tor directory authorities
     * @type {Array<RangeTorNode>}
     * @memberof RangeTorNetCreate
     */
    'directoryAuthorities': Array<RangeTorNode>;
    /**
     * Tor relays
     * @type {Array<RangeTorNode>}
     * @memberof RangeTorNetCreate
     */
    'relays': Array<RangeTorNode>;
    /**
     * Tor exit nodes
     * @type {Array<RangeTorNode>}
     * @memberof RangeTorNetCreate
     */
    'exitNodes': Array<RangeTorNode>;
}

export const RangeTorNetCreateVersionEnum = {
    _04711: '0.4.7.11'
} as const;

export type RangeTorNetCreateVersionEnum = typeof RangeTorNetCreateVersionEnum[keyof typeof RangeTorNetCreateVersionEnum];

/**
 * 
 * @export
 * @interface RangeTorNetOverride
 */
export interface RangeTorNetOverride {
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeTorNetOverride
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeTorNetOverride
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Tor version
     * @type {string}
     * @memberof RangeTorNetOverride
     */
    'version'?: RangeTorNetOverrideVersionEnum;
}

export const RangeTorNetOverrideVersionEnum = {
    _04711: '0.4.7.11'
} as const;

export type RangeTorNetOverrideVersionEnum = typeof RangeTorNetOverrideVersionEnum[keyof typeof RangeTorNetOverrideVersionEnum];

/**
 * 
 * @export
 * @interface RangeTorNetUpdate
 */
export interface RangeTorNetUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeTorNetUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeTorNetUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeTorNetUpdate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeTorNetUpdate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Tor version
     * @type {string}
     * @memberof RangeTorNetUpdate
     */
    'version'?: RangeTorNetUpdateVersionEnum;
    /**
     * Tor directory authorities
     * @type {Array<RangeTorNode>}
     * @memberof RangeTorNetUpdate
     */
    'directoryAuthorities'?: Array<RangeTorNode>;
    /**
     * Tor relays
     * @type {Array<RangeTorNode>}
     * @memberof RangeTorNetUpdate
     */
    'relays'?: Array<RangeTorNode>;
    /**
     * Tor exit nodes
     * @type {Array<RangeTorNode>}
     * @memberof RangeTorNetUpdate
     */
    'exitNodes'?: Array<RangeTorNode>;
}

export const RangeTorNetUpdateVersionEnum = {
    _04711: '0.4.7.11'
} as const;

export type RangeTorNetUpdateVersionEnum = typeof RangeTorNetUpdateVersionEnum[keyof typeof RangeTorNetUpdateVersionEnum];

/**
 * 
 * @export
 * @interface RangeTorNetsList200Response
 */
export interface RangeTorNetsList200Response {
    /**
     * 
     * @type {number}
     * @memberof RangeTorNetsList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeTorNetsList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeTorNetsList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeTorNetsList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<RangeTorNet>}
     * @memberof RangeTorNetsList200Response
     */
    'data'?: Array<RangeTorNet>;
}
/**
 * 
 * @export
 * @interface RangeTorNode
 */
export interface RangeTorNode {
    /**
     * Name of the tor node
     * @type {string}
     * @memberof RangeTorNode
     */
    'name': string;
    /**
     * IP address of this node on the network
     * @type {string}
     * @memberof RangeTorNode
     */
    'rangeIP'?: string;
    /**
     * Optional IP address of a DNS server on the network
     * @type {string}
     * @memberof RangeTorNode
     */
    'dnsRangeIP'?: string | null;
}
/**
 * Range
 * @export
 * @interface RangeUpdate
 */
export interface RangeUpdate {
    /**
     * A user provided human readable name
     * @type {string}
     * @memberof RangeUpdate
     */
    'name'?: string;
    /**
     * ID of the range specification, not required for unmanaged ranges - only one of kubeconfig and specification must be given
     * @type {string}
     * @memberof RangeUpdate
     */
    'specification'?: string;
    /**
     * Optional kubeconfig for unmanaged ranges - only one of kubeconfig and specification must be given
     * @type {string}
     * @memberof RangeUpdate
     */
    'kubeconfig'?: string;
    /**
     * Type of range to bootstrap - only used by unmanaged ranges
     * @type {string}
     * @memberof RangeUpdate
     */
    'bootstrapType'?: RangeUpdateBootstrapTypeEnum;
    /**
     * CMI5 content partition key. Values must match the regex /^(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])?$/ and be no longer than 63 characters.
     * @type {string}
     * @memberof RangeUpdate
     */
    'cmi5Key'?: string | null;
    /**
     * When true, allows new CMI5 content to be deployed to this Range.
     * @type {boolean}
     * @memberof RangeUpdate
     */
    'cmi5DeploymentAllowed'?: boolean;
}

export const RangeUpdateBootstrapTypeEnum = {
    Aws: 'aws',
    Vsphere: 'vsphere',
    Onprem: 'onprem'
} as const;

export type RangeUpdateBootstrapTypeEnum = typeof RangeUpdateBootstrapTypeEnum[keyof typeof RangeUpdateBootstrapTypeEnum];

/**
 * 
 * @export
 * @interface RangeVM
 */
export interface RangeVM {
    /**
     * 
     * @type {string}
     * @memberof RangeVM
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof RangeVM
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof RangeVM
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeVM
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeVM
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof RangeVM
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeVM
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeVM
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Whether the control network NIC is enabled
     * @type {boolean}
     * @memberof RangeVM
     */
    'controlNetNicEnabled'?: boolean;
    /**
     * Ordered list of disks to attach to the VM
     * @type {Array<VMDisk>}
     * @memberof RangeVM
     */
    'disks'?: Array<VMDisk>;
    /**
     * 
     * @type {BootImage}
     * @memberof RangeVM
     */
    'bootImage'?: BootImage;
    /**
     * 
     * @type {CloudInit}
     * @memberof RangeVM
     */
    'cloudInit'?: CloudInit | null;
    /**
     * Number of CPU cores
     * @type {number}
     * @memberof RangeVM
     */
    'cpuCores'?: number;
    /**
     * Quantity of requested memory to be allocated
     * @type {string}
     * @memberof RangeVM
     */
    'memory'?: string;
    /**
     * Hostname of the VM
     * @type {string}
     * @memberof RangeVM
     */
    'hostname'?: string | null;
    /**
     * Range VM interfaces
     * @type {Array<RangeVMInterface>}
     * @memberof RangeVM
     */
    'interfaces'?: Array<RangeVMInterface>;
    /**
     * If true, Kubevirt will create a VM. If false, it will delete it/not create it.
     * @type {boolean}
     * @memberof RangeVM
     */
    'running'?: boolean;
    /**
     * Current status of the Kubevirt VM
     * @type {string}
     * @memberof RangeVM
     */
    'kubevirtVmStatus'?: RangeVMKubevirtVmStatusEnum;
    /**
     * Status message of the Kubevirt VM
     * @type {string}
     * @memberof RangeVM
     */
    'kubevirtVmMessage'?: string;
    /**
     * The RangeVM status
     * @type {string}
     * @memberof RangeVM
     */
    'status'?: RangeVMStatusEnum;
    /**
     * The RangeVM status message
     * @type {string}
     * @memberof RangeVM
     */
    'message'?: string;
}

export const RangeVMKubevirtVmStatusEnum = {
    Stopped: 'Stopped',
    Provisioning: 'Provisioning',
    Starting: 'Starting',
    Running: 'Running',
    Paused: 'Paused',
    Stopping: 'Stopping',
    Terminating: 'Terminating',
    CrashLoopBackoff: 'CrashLoopBackoff',
    Migrating: 'Migrating',
    Unknown: 'Unknown',
    ErrorUnschedulable: 'ErrorUnschedulable',
    ErrImagePull: 'ErrImagePull',
    ImagePullBackoff: 'ImagePullBackoff',
    ErrorPvcNotFound: 'ErrorPvcNotFound',
    DataVolumeError: 'DataVolumeError',
    WaitingForVolumeBinding: 'WaitingForVolumeBinding'
} as const;

export type RangeVMKubevirtVmStatusEnum = typeof RangeVMKubevirtVmStatusEnum[keyof typeof RangeVMKubevirtVmStatusEnum];
export const RangeVMStatusEnum = {
    Unknown: 'Unknown',
    Ready: 'Ready',
    NotReady: 'NotReady',
    Creating: 'Creating',
    Error: 'Error',
    Deleting: 'Deleting',
    Stopped: 'Stopped'
} as const;

export type RangeVMStatusEnum = typeof RangeVMStatusEnum[keyof typeof RangeVMStatusEnum];

/**
 * 
 * @export
 * @interface RangeVMInterface
 */
export interface RangeVMInterface {
    /**
     * Optional ID of a range network
     * @type {string}
     * @memberof RangeVMInterface
     */
    'rangeNetwork'?: string | null;
    /**
     * Optional ID of a range host network
     * @type {string}
     * @memberof RangeVMInterface
     */
    'rangeHostNetwork'?: string | null;
    /**
     * Optional ID of a range IP
     * @type {string}
     * @memberof RangeVMInterface
     */
    'rangeIP'?: string | null;
    /**
     * Optional ID of a range auto IP
     * @type {string}
     * @memberof RangeVMInterface
     */
    'rangeAutoIP'?: string | null;
    /**
     * Optional MAC address, if not provided one will be randomly generated
     * @type {string}
     * @memberof RangeVMInterface
     */
    'macAddress'?: string | null;
    /**
     * Optional list of network ports to mirror to this interface
     * @type {Array<DeployedMirrorPort>}
     * @memberof RangeVMInterface
     */
    'mirrorPorts'?: Array<DeployedMirrorPort>;
    /**
     * Optional unique identifier, only used with advanced networking
     * @type {object}
     * @memberof RangeVMInterface
     */
    'id'?: object;
    /**
     * Optional interface name
     * @type {object}
     * @memberof RangeVMInterface
     */
    'interfaceName'?: object;
    /**
     * 
     * @type {VmNicModel}
     * @memberof RangeVMInterface
     */
    'vmNicModel'?: VmNicModel | null;
    /**
     * If true, the default gateway will be assigned based on the RangeIP attached to this interface.
     * @type {boolean}
     * @memberof RangeVMInterface
     */
    'defaultGateway'?: boolean;
}


/**
 * RangeOS Range VM Export
 * @export
 * @interface RangeVmExportApi
 */
export interface RangeVmExportApi {
    /**
     * Name of the Virtual Machine Snapshot that will be exported as a new Disk Image
     * @type {string}
     * @memberof RangeVmExportApi
     */
    'virtualMachineSnapshotName'?: string;
    /**
     * Name that will be given to the new Disk Image. Do not add file extension of .qcow2
     * @type {string}
     * @memberof RangeVmExportApi
     */
    'imageName'?: string;
    /**
     * Name of the Range VM Export
     * @type {string}
     * @memberof RangeVmExportApi
     */
    'name'?: string;
    /**
     * Bearer Token
     * @type {string}
     * @memberof RangeVmExportApi
     */
    'jwtToken'?: string;
    /**
     * Range VM Status
     * @type {string}
     * @memberof RangeVmExportApi
     */
    'status'?: RangeVmExportApiStatusEnum;
    /**
     * Url to Image Upload Endpoint
     * @type {string}
     * @memberof RangeVmExportApi
     */
    'uploadUrl'?: string;
}

export const RangeVmExportApiStatusEnum = {
    Unknown: 'Unknown',
    Ready: 'Ready',
    NotReady: 'NotReady',
    Creating: 'Creating',
    Error: 'Error',
    Deleting: 'Deleting',
    Stopped: 'Stopped'
} as const;

export type RangeVmExportApiStatusEnum = typeof RangeVmExportApiStatusEnum[keyof typeof RangeVmExportApiStatusEnum];

/**
 * RangeOS Range VM Export
 * @export
 * @interface RangeVmExportForm
 */
export interface RangeVmExportForm {
    /**
     * Name of the Virtual Machine Snapshot that will be exported as a new Disk Image
     * @type {string}
     * @memberof RangeVmExportForm
     */
    'virtualMachineSnapshotName'?: string;
    /**
     * Name that will be given to the new Disk Image. Do not add file extension of .qcow2
     * @type {string}
     * @memberof RangeVmExportForm
     */
    'imageName'?: string;
}
/**
 * 
 * @export
 * @interface RangeVmExportsList200Response
 */
export interface RangeVmExportsList200Response {
    /**
     * 
     * @type {number}
     * @memberof RangeVmExportsList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeVmExportsList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeVmExportsList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeVmExportsList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<RangeVmExportApi>}
     * @memberof RangeVmExportsList200Response
     */
    'data'?: Array<RangeVmExportApi>;
}
/**
 * 
 * @export
 * @interface RangeVolume
 */
export interface RangeVolume {
    /**
     * 
     * @type {string}
     * @memberof RangeVolume
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof RangeVolume
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof RangeVolume
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeVolume
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeVolume
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof RangeVolume
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeVolume
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeVolume
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * The type of storage for this volume
     * @type {string}
     * @memberof RangeVolume
     */
    'storageClass'?: string | null;
    /**
     * Quantity of requested storage space to be allocated. Minimum supported value: 100M
     * @type {string}
     * @memberof RangeVolume
     */
    'storage'?: string;
    /**
     * Optional ID of the volume to be downloaded to the range
     * @type {string}
     * @memberof RangeVolume
     */
    'volume'?: string | null;
}
/**
 * 
 * @export
 * @interface RangeVolumeCreate
 */
export interface RangeVolumeCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeVolumeCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeVolumeCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeVolumeCreate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeVolumeCreate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * The type of storage for this volume
     * @type {string}
     * @memberof RangeVolumeCreate
     */
    'storageClass'?: string | null;
    /**
     * Quantity of requested storage space to be allocated. Minimum supported value: 100M
     * @type {string}
     * @memberof RangeVolumeCreate
     */
    'storage': string;
    /**
     * Optional ID of the volume to be downloaded to the range
     * @type {string}
     * @memberof RangeVolumeCreate
     */
    'volume'?: string | null;
}
/**
 * 
 * @export
 * @interface RangeVolumeOverride
 */
export interface RangeVolumeOverride {
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeVolumeOverride
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeVolumeOverride
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * The type of storage for this volume
     * @type {string}
     * @memberof RangeVolumeOverride
     */
    'storageClass'?: string | null;
    /**
     * Quantity of requested storage space to be allocated. Minimum supported value: 100M
     * @type {string}
     * @memberof RangeVolumeOverride
     */
    'storage'?: string;
}
/**
 * 
 * @export
 * @interface RangeVolumeUpdate
 */
export interface RangeVolumeUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RangeVolumeUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RangeVolumeUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof RangeVolumeUpdate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof RangeVolumeUpdate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * The type of storage for this volume
     * @type {string}
     * @memberof RangeVolumeUpdate
     */
    'storageClass'?: string | null;
    /**
     * Quantity of requested storage space to be allocated. Minimum supported value: 100M
     * @type {string}
     * @memberof RangeVolumeUpdate
     */
    'storage'?: string;
    /**
     * Optional ID of the volume to be downloaded to the range
     * @type {string}
     * @memberof RangeVolumeUpdate
     */
    'volume'?: string | null;
}
/**
 * 
 * @export
 * @interface RangeVolumesList200Response
 */
export interface RangeVolumesList200Response {
    /**
     * 
     * @type {number}
     * @memberof RangeVolumesList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeVolumesList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeVolumesList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeVolumesList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<RangeVolume>}
     * @memberof RangeVolumesList200Response
     */
    'data'?: Array<RangeVolume>;
}
/**
 * 
 * @export
 * @interface RangeVsphereSpecificationList200Response
 */
export interface RangeVsphereSpecificationList200Response {
    /**
     * 
     * @type {number}
     * @memberof RangeVsphereSpecificationList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeVsphereSpecificationList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeVsphereSpecificationList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof RangeVsphereSpecificationList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<RangeSpecificationVsphere>}
     * @memberof RangeVsphereSpecificationList200Response
     */
    'data'?: Array<RangeSpecificationVsphere>;
}
/**
 * 
 * @export
 * @interface RecentContent
 */
export interface RecentContent {
    /**
     * Date when the content was accessed.
     * @type {string}
     * @memberof RecentContent
     */
    'date'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof RecentContent
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof RecentContent
     */
    'name'?: string;
    /**
     * 
     * @type {RecentContentDraft}
     * @memberof RecentContent
     */
    'content'?: RecentContentDraft;
}
/**
 * 
 * @export
 * @interface RecentContentDraft
 */
export interface RecentContentDraft {
    /**
     * Type of the recent content
     * @type {string}
     * @memberof RecentContentDraft
     */
    'type': RecentContentDraftTypeEnum;
    /**
     * ID of the recent draft
     * @type {string}
     * @memberof RecentContentDraft
     */
    'uuid'?: string;
    /**
     * ID of the most recently published draft state
     * @type {string}
     * @memberof RecentContentDraft
     */
    'draftState'?: string | null;
    /**
     * List of currently deployed instances of the draft
     * @type {Array<RecentDeployedDraft>}
     * @memberof RecentContentDraft
     */
    'deployed'?: Array<RecentDeployedDraft>;
}

export const RecentContentDraftTypeEnum = {
    Draft: 'draft'
} as const;

export type RecentContentDraftTypeEnum = typeof RecentContentDraftTypeEnum[keyof typeof RecentContentDraftTypeEnum];

/**
 * 
 * @export
 * @interface RecentDeployedDraft
 */
export interface RecentDeployedDraft {
    /**
     * ID of the most recent deployed scenario
     * @type {string}
     * @memberof RecentDeployedDraft
     */
    'deployedScenario'?: string;
    /**
     * ID of the range the scenario is deployed to
     * @type {string}
     * @memberof RecentDeployedDraft
     */
    'rangeId'?: string;
}
/**
 * 
 * @export
 * @interface RecentList200Response
 */
export interface RecentList200Response {
    /**
     * 
     * @type {number}
     * @memberof RecentList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof RecentList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof RecentList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof RecentList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<RecentContent>}
     * @memberof RecentList200Response
     */
    'data'?: Array<RecentContent>;
}
/**
 * 
 * @export
 * @interface Registries
 */
export interface Registries {
    /**
     * Map of registry FQDN/IP to configuration values
     * @type {{ [key: string]: RegistryConfig; }}
     * @memberof Registries
     */
    'configs'?: { [key: string]: RegistryConfig; };
    /**
     * Map of registry FQDN/IP to configuration values
     * @type {{ [key: string]: RegistryMirror; }}
     * @memberof Registries
     */
    'mirrors'?: { [key: string]: RegistryMirror; };
}
/**
 * 
 * @export
 * @interface RegistryConfig
 */
export interface RegistryConfig {
    /**
     * CA bundle for registry
     * @type {string}
     * @memberof RegistryConfig
     */
    'caBundle'?: string;
    /**
     * Skip verification of registry TLS
     * @type {boolean}
     * @memberof RegistryConfig
     */
    'insecureSkipVerify'?: boolean;
}
/**
 * 
 * @export
 * @interface RegistryMirror
 */
export interface RegistryMirror {
    /**
     * CRI plugin will try the endpoints one by one until a working one is found. The endpoint must be a valid url with host specified. The scheme, host and path from the endpoint URL will be used.
     * @type {Array<string>}
     * @memberof RegistryMirror
     */
    'endpoint'?: Array<string>;
    /**
     * Rewrites are repository rewrite rules for a namespace. When fetching image resources from an endpoint and a key matches the repository via regular expression matching it will be replaced with the corresponding value from the map in the resource request.
     * @type {{ [key: string]: string; }}
     * @memberof RegistryMirror
     */
    'rewrite'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface Scenario
 */
export interface Scenario {
    /**
     * 
     * @type {string}
     * @memberof Scenario
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof Scenario
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof Scenario
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof Scenario
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof Scenario
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof Scenario
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof Scenario
     */
    'metadata'?: object;
    /**
     * Deprecated in favor of metadata
     * @type {Array<string>}
     * @memberof Scenario
     * @deprecated
     */
    'metadata_tags'?: Array<string>;
    /**
     * Array of Draft UUIDs that this scenario is a part of
     * @type {Array<string>}
     * @memberof Scenario
     */
    'drafts'?: Array<string>;
    /**
     * MTO path and group for users to access this scenario
     * @type {Array<MTOPermissions>}
     * @memberof Scenario
     */
    'mtoPermissions'?: Array<MTOPermissions>;
    /**
     * List of package IDs
     * @type {Array<string>}
     * @memberof Scenario
     */
    'packages'?: Array<string>;
    /**
     * The UUID of the event tree
     * @type {string}
     * @memberof Scenario
     */
    'eventTree'?: string | null;
}
/**
 * 
 * @export
 * @interface ScenarioCreate
 */
export interface ScenarioCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof ScenarioCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof ScenarioCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof ScenarioCreate
     */
    'metadata'?: object;
    /**
     * Deprecated in favor of metadata
     * @type {Array<string>}
     * @memberof ScenarioCreate
     * @deprecated
     */
    'metadata_tags'?: Array<string>;
    /**
     * MTO path and group for users to access this scenario
     * @type {Array<MTOPermissions>}
     * @memberof ScenarioCreate
     */
    'mtoPermissions'?: Array<MTOPermissions>;
    /**
     * List of package IDs
     * @type {Array<string>}
     * @memberof ScenarioCreate
     */
    'packages'?: Array<string>;
    /**
     * The UUID of the event tree
     * @type {string}
     * @memberof ScenarioCreate
     */
    'eventTree'?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ScenarioGroup = {
    BlueCell: 'blueCell',
    RedCell: 'redCell',
    WhiteCell: 'whiteCell',
    ScenarioAdmin: 'scenarioAdmin'
} as const;

export type ScenarioGroup = typeof ScenarioGroup[keyof typeof ScenarioGroup];


/**
 * Overrides for resource types in a scenario
 * @export
 * @interface ScenarioOverridesOverride
 */
export interface ScenarioOverridesOverride {
    /**
     * Override container specifications by UUID
     * @type {{ [key: string]: ContainerSpecificationOverride; }}
     * @memberof ScenarioOverridesOverride
     */
    'containerSpecifications'?: { [key: string]: ContainerSpecificationOverride; };
    /**
     * Override ghost agents by UUID
     * @type {{ [key: string]: GhostAgentOverride; }}
     * @memberof ScenarioOverridesOverride
     */
    'ghostAgents'?: { [key: string]: GhostAgentOverride; };
    /**
     * Override ghost C2 servers by UUID
     * @type {{ [key: string]: GhostC2ServerOverride; }}
     * @memberof ScenarioOverridesOverride
     */
    'ghostC2Servers'?: { [key: string]: GhostC2ServerOverride; };
    /**
     * Override ghost clients by UUID
     * @type {{ [key: string]: GhostClientOverride; }}
     * @memberof ScenarioOverridesOverride
     */
    'ghostClients'?: { [key: string]: GhostClientOverride; };
    /**
     * Override ghost traffic profiles by UUID
     * @type {{ [key: string]: GhostTrafficProfileOverride; }}
     * @memberof ScenarioOverridesOverride
     */
    'ghostTrafficProfiles'?: { [key: string]: GhostTrafficProfileOverride; };
    /**
     * Override internet gateways by UUID
     * @type {{ [key: string]: InternetGatewayOverride; }}
     * @memberof ScenarioOverridesOverride
     */
    'internetGateways'?: { [key: string]: InternetGatewayOverride; };
    /**
     * Override range BGPs by UUID
     * @type {{ [key: string]: RangeBgpOverride; }}
     * @memberof ScenarioOverridesOverride
     */
    'rangeBGPs'?: { [key: string]: RangeBgpOverride; };
    /**
     * Override range BGP links by UUID
     * @type {{ [key: string]: RangeBgpLinkOverride; }}
     * @memberof ScenarioOverridesOverride
     */
    'rangeBGPLinks'?: { [key: string]: RangeBgpLinkOverride; };
    /**
     * Override range certs by UUID
     * @type {{ [key: string]: RangeCertOverride; }}
     * @memberof ScenarioOverridesOverride
     */
    'rangeCerts'?: { [key: string]: RangeCertOverride; };
    /**
     * Override range certs by UUID
     * @type {{ [key: string]: RangePkiOverride; }}
     * @memberof ScenarioOverridesOverride
     */
    'rangePkis'?: { [key: string]: RangePkiOverride; };
    /**
     * Override range consoles by UUID
     * @type {{ [key: string]: RangeConsoleOverride; }}
     * @memberof ScenarioOverridesOverride
     */
    'rangeConsoles'?: { [key: string]: RangeConsoleOverride; };
    /**
     * Override range DNS servers by UUID
     * @type {{ [key: string]: RangeDnsServerOverride; }}
     * @memberof ScenarioOverridesOverride
     */
    'rangeDNSServers'?: { [key: string]: RangeDnsServerOverride; };
    /**
     * Override range DNS zone by UUID
     * @type {{ [key: string]: RangeDnsZoneOverride; }}
     * @memberof ScenarioOverridesOverride
     */
    'rangeDNSZones'?: { [key: string]: RangeDnsZoneOverride; };
    /**
     * Override range DNS record by UUID
     * @type {{ [key: string]: RangeDnsRecordOverride; }}
     * @memberof ScenarioOverridesOverride
     */
    'rangeDNSRecords'?: { [key: string]: RangeDnsRecordOverride; };
    /**
     * Override range auto IPs by UUID
     * @type {{ [key: string]: RangeAutoIpOverride; }}
     * @memberof ScenarioOverridesOverride
     */
    'rangeAutoIPs'?: { [key: string]: RangeAutoIpOverride; };
    /**
     * Override range IPs by UUID
     * @type {{ [key: string]: RangeIpOverride; }}
     * @memberof ScenarioOverridesOverride
     */
    'rangeIPs'?: { [key: string]: RangeIpOverride; };
    /**
     * Override range auto L3 networks by UUID
     * @type {{ [key: string]: RangeAutoL3NetworkOverride; }}
     * @memberof ScenarioOverridesOverride
     */
    'rangeAutoL3Networks'?: { [key: string]: RangeAutoL3NetworkOverride; };
    /**
     * Override range L3 networks by UUID
     * @type {{ [key: string]: RangeL3NetworkOverride; }}
     * @memberof ScenarioOverridesOverride
     */
    'rangeL3Networks'?: { [key: string]: RangeL3NetworkOverride; };
    /**
     * Override range networks by UUID
     * @type {{ [key: string]: RangeNetworkOverride; }}
     * @memberof ScenarioOverridesOverride
     */
    'rangeNetworks'?: { [key: string]: RangeNetworkOverride; };
    /**
     * Override provisioning service composites by UUID
     * @type {{ [key: string]: AnsiblePlaybookOverride; }}
     * @memberof ScenarioOverridesOverride
     */
    'rangeAnsiblePlaybooks'?: { [key: string]: AnsiblePlaybookOverride; };
    /**
     * Override range routers by UUID
     * @type {{ [key: string]: RangeRouterOverride; }}
     * @memberof ScenarioOverridesOverride
     */
    'rangeRouters'?: { [key: string]: RangeRouterOverride; };
    /**
     * Override range tor nets by UUID
     * @type {{ [key: string]: RangeTorNetOverride; }}
     * @memberof ScenarioOverridesOverride
     */
    'rangeTorNets'?: { [key: string]: RangeTorNetOverride; };
    /**
     * Override range volumes by UUID
     * @type {{ [key: string]: RangeVolumeOverride; }}
     * @memberof ScenarioOverridesOverride
     */
    'rangeVolumes'?: { [key: string]: RangeVolumeOverride; };
    /**
     * Override VM specifications by UUID
     * @type {{ [key: string]: VmSpecificationOverride; }}
     * @memberof ScenarioOverridesOverride
     */
    'vmSpecifications'?: { [key: string]: VmSpecificationOverride; };
}
/**
 * Grant or revoke access to specific users for the given scenario
 * @export
 * @interface ScenarioPermissionUpdate
 */
export interface ScenarioPermissionUpdate {
    /**
     * If true, all scenario group permissions are enforced; otherwise, only scenarioAdmins can access the scenario and any blue/red/whiteCell users\' access is revoked
     * @type {boolean}
     * @memberof ScenarioPermissionUpdate
     */
    'enabled'?: boolean;
    /**
     * List of SSO usernames in the Blue Cell scenario group
     * @type {Array<string>}
     * @memberof ScenarioPermissionUpdate
     */
    'blueCell'?: Array<string>;
    /**
     * List of SSO usernames in the Red Cell scenario group
     * @type {Array<string>}
     * @memberof ScenarioPermissionUpdate
     */
    'redCell'?: Array<string>;
    /**
     * List of SSO usernames in the White Cell scenario group
     * @type {Array<string>}
     * @memberof ScenarioPermissionUpdate
     */
    'whiteCell'?: Array<string>;
    /**
     * List of SSO usernames in the Scenario Admin scenario group
     * @type {Array<string>}
     * @memberof ScenarioPermissionUpdate
     */
    'scenarioAdmin'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ScenarioUpdate
 */
export interface ScenarioUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof ScenarioUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof ScenarioUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof ScenarioUpdate
     */
    'metadata'?: object;
    /**
     * Deprecated in favor of metadata
     * @type {Array<string>}
     * @memberof ScenarioUpdate
     * @deprecated
     */
    'metadata_tags'?: Array<string>;
    /**
     * MTO path and group for users to access this scenario
     * @type {Array<MTOPermissions>}
     * @memberof ScenarioUpdate
     */
    'mtoPermissions'?: Array<MTOPermissions>;
    /**
     * List of package IDs
     * @type {Array<string>}
     * @memberof ScenarioUpdate
     */
    'packages'?: Array<string>;
    /**
     * The UUID of the event tree
     * @type {string}
     * @memberof ScenarioUpdate
     */
    'eventTree'?: string | null;
}
/**
 * 
 * @export
 * @interface ScenariosCreate1Request
 */
export interface ScenariosCreate1Request {
    /**
     * 
     * @type {string}
     * @memberof ScenariosCreate1Request
     */
    'classId'?: string;
}
/**
 * 
 * @export
 * @interface ScenariosCreateByRangeIdRequest
 */
export interface ScenariosCreateByRangeIdRequest {
    /**
     * 
     * @type {string}
     * @memberof ScenariosCreateByRangeIdRequest
     */
    'scenarioId': string;
    /**
     * 
     * @type {string}
     * @memberof ScenariosCreateByRangeIdRequest
     */
    'name'?: string;
    /**
     * 
     * @type {ScenarioOverridesOverride}
     * @memberof ScenariosCreateByRangeIdRequest
     */
    'overrides'?: ScenarioOverridesOverride;
}
/**
 * 
 * @export
 * @interface ScenariosDeployRequest
 */
export interface ScenariosDeployRequest {
    /**
     * 
     * @type {number}
     * @memberof ScenariosDeployRequest
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof ScenariosDeployRequest
     */
    'classId': string;
    /**
     * 
     * @type {string}
     * @memberof ScenariosDeployRequest
     */
    'cmi5Key'?: string;
}
/**
 * 
 * @export
 * @interface ScenariosList200Response
 */
export interface ScenariosList200Response {
    /**
     * 
     * @type {number}
     * @memberof ScenariosList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScenariosList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScenariosList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScenariosList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<Scenario>}
     * @memberof ScenariosList200Response
     */
    'data'?: Array<Scenario>;
}
/**
 * 
 * @export
 * @interface ScenariosListByRangeId200Response
 */
export interface ScenariosListByRangeId200Response {
    /**
     * 
     * @type {number}
     * @memberof ScenariosListByRangeId200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScenariosListByRangeId200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScenariosListByRangeId200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ScenariosListByRangeId200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<DeployedScenarioDetail>}
     * @memberof ScenariosListByRangeId200Response
     */
    'data'?: Array<DeployedScenarioDetail>;
}
/**
 * 
 * @export
 * @interface ScenariosUpdateByRangeIdUuidRequest
 */
export interface ScenariosUpdateByRangeIdUuidRequest {
    /**
     * 
     * @type {string}
     * @memberof ScenariosUpdateByRangeIdUuidRequest
     */
    'name'?: string;
    /**
     * 
     * @type {ScenarioOverridesOverride}
     * @memberof ScenariosUpdateByRangeIdUuidRequest
     */
    'overrides'?: ScenarioOverridesOverride;
}
/**
 * 
 * @export
 * @interface ScenariosValidateBeforeCreateRequest
 */
export interface ScenariosValidateBeforeCreateRequest {
    /**
     * 
     * @type {ScenarioCreate}
     * @memberof ScenariosValidateBeforeCreateRequest
     */
    'scenario'?: ScenarioCreate;
    /**
     * 
     * @type {ScenarioOverridesOverride}
     * @memberof ScenariosValidateBeforeCreateRequest
     */
    'overrides'?: ScenarioOverridesOverride;
}
/**
 * 
 * @export
 * @interface ScenariosValidateRequest
 */
export interface ScenariosValidateRequest {
    /**
     * 
     * @type {ScenarioOverridesOverride}
     * @memberof ScenariosValidateRequest
     */
    'overrides'?: ScenarioOverridesOverride;
}
/**
 * 
 * @export
 * @interface Stream
 */
export interface Stream {
    /**
     * 
     * @type {string}
     * @memberof Stream
     */
    'streamId'?: string;
    /**
     * Name of the Stream
     * @type {string}
     * @memberof Stream
     */
    'streamName': string;
    /**
     * Description of the Stream
     * @type {string}
     * @memberof Stream
     */
    'streamDescription'?: string;
    /**
     * List of captureIds, dropdown from list of captures being created
     * @type {Array<string>}
     * @memberof Stream
     */
    'captures'?: Array<string>;
}
/**
 * 
 * @export
 * @interface StreamCreate
 */
export interface StreamCreate {
    /**
     * Name of the Stream
     * @type {string}
     * @memberof StreamCreate
     */
    'streamName': string;
    /**
     * Description of the Stream
     * @type {string}
     * @memberof StreamCreate
     */
    'streamDescription'?: string;
    /**
     * List of captureIds, dropdown from list of captures being created
     * @type {Array<string>}
     * @memberof StreamCreate
     */
    'captures'?: Array<string>;
}
/**
 * 
 * @export
 * @interface StreamUpdate
 */
export interface StreamUpdate {
    /**
     * Name of the Stream
     * @type {string}
     * @memberof StreamUpdate
     */
    'streamName': string;
    /**
     * Description of the Stream
     * @type {string}
     * @memberof StreamUpdate
     */
    'streamDescription'?: string;
    /**
     * List of captureIds, dropdown from list of captures being created
     * @type {Array<string>}
     * @memberof StreamUpdate
     */
    'captures'?: Array<string>;
}
/**
 * 
 * @export
 * @interface TelemetryAgent
 */
export interface TelemetryAgent {
    /**
     * 
     * @type {string}
     * @memberof TelemetryAgent
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof TelemetryAgent
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof TelemetryAgent
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof TelemetryAgent
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof TelemetryAgent
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof TelemetryAgent
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof TelemetryAgent
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof TelemetryAgent
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Interval that the script will run in seconds
     * @type {number}
     * @memberof TelemetryAgent
     */
    'interval'?: number;
    /**
     * Script to run
     * @type {string}
     * @memberof TelemetryAgent
     */
    'script'?: string;
    /**
     * Ansible Role ID
     * @type {string}
     * @memberof TelemetryAgent
     */
    'ansibleRoleId'?: string;
    /**
     * Ansible User
     * @type {string}
     * @memberof TelemetryAgent
     */
    'ansibleUser'?: string;
    /**
     * Ansible Password
     * @type {string}
     * @memberof TelemetryAgent
     */
    'ansiblePassword'?: string;
    /**
     * UUID of RangeVM to have Telegraf Installed
     * @type {string}
     * @memberof TelemetryAgent
     */
    'targetRangeVm'?: string;
}
/**
 * 
 * @export
 * @interface TelemetryAgentCreate
 */
export interface TelemetryAgentCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof TelemetryAgentCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof TelemetryAgentCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof TelemetryAgentCreate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof TelemetryAgentCreate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Interval that the script will run in seconds
     * @type {number}
     * @memberof TelemetryAgentCreate
     */
    'interval': number;
    /**
     * Script to run
     * @type {string}
     * @memberof TelemetryAgentCreate
     */
    'script': string;
    /**
     * UUID of RangeVM to have Telegraf Installed
     * @type {string}
     * @memberof TelemetryAgentCreate
     */
    'targetRangeVm': string;
}
/**
 * 
 * @export
 * @interface TelemetryAgentUpdate
 */
export interface TelemetryAgentUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof TelemetryAgentUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof TelemetryAgentUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof TelemetryAgentUpdate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof TelemetryAgentUpdate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Interval that the script will run in seconds
     * @type {number}
     * @memberof TelemetryAgentUpdate
     */
    'interval'?: number;
    /**
     * Script to run
     * @type {string}
     * @memberof TelemetryAgentUpdate
     */
    'script'?: string;
    /**
     * UUID of RangeVM to have Telegraf Installed
     * @type {string}
     * @memberof TelemetryAgentUpdate
     */
    'targetRangeVm'?: string;
}
/**
 * 
 * @export
 * @interface TelemetryAgentsList200Response
 */
export interface TelemetryAgentsList200Response {
    /**
     * 
     * @type {number}
     * @memberof TelemetryAgentsList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof TelemetryAgentsList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof TelemetryAgentsList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof TelemetryAgentsList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<TelemetryAgent>}
     * @memberof TelemetryAgentsList200Response
     */
    'data'?: Array<TelemetryAgent>;
}
/**
 * 
 * @export
 * @interface TimePeriod
 */
export interface TimePeriod {
    /**
     * End Time Period
     * @type {string}
     * @memberof TimePeriod
     */
    'end'?: string;
    /**
     * Start Time Period
     * @type {string}
     * @memberof TimePeriod
     */
    'start'?: string;
}
/**
 * 
 * @export
 * @interface TimePeriodTotal
 */
export interface TimePeriodTotal {
    /**
     * 
     * @type {TimePeriod}
     * @memberof TimePeriodTotal
     */
    'timePeriod'?: TimePeriod;
    /**
     * 
     * @type {TotalCost}
     * @memberof TimePeriodTotal
     */
    'blendedCosts'?: TotalCost;
}
/**
 * 
 * @export
 * @interface TotalCost
 */
export interface TotalCost {
    /**
     * Amount
     * @type {string}
     * @memberof TotalCost
     */
    'amount'?: string;
    /**
     * Unit
     * @type {string}
     * @memberof TotalCost
     */
    'unit'?: string;
}
/**
 * 
 * @export
 * @interface TrafficTracker
 */
export interface TrafficTracker {
    /**
     * 
     * @type {string}
     * @memberof TrafficTracker
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof TrafficTracker
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof TrafficTracker
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof TrafficTracker
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof TrafficTracker
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof TrafficTracker
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof TrafficTracker
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof TrafficTracker
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * 
     * @type {Array<Stream>}
     * @memberof TrafficTracker
     */
    'streams'?: Array<Stream>;
    /**
     * Network Overrides
     * @type {Array<string>}
     * @memberof TrafficTracker
     */
    'networkOverrides'?: Array<string>;
    /**
     * List of Captures
     * @type {Array<CaptureApi>}
     * @memberof TrafficTracker
     */
    'captures'?: Array<CaptureApi>;
}
/**
 * 
 * @export
 * @interface TrafficTrackerCreate
 */
export interface TrafficTrackerCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof TrafficTrackerCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof TrafficTrackerCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof TrafficTrackerCreate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof TrafficTrackerCreate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * 
     * @type {Array<StreamCreate>}
     * @memberof TrafficTrackerCreate
     */
    'streams'?: Array<StreamCreate>;
    /**
     * Network Overrides
     * @type {Array<string>}
     * @memberof TrafficTrackerCreate
     */
    'networkOverrides'?: Array<string>;
    /**
     * List of Captures
     * @type {Array<CaptureApi>}
     * @memberof TrafficTrackerCreate
     */
    'captures'?: Array<CaptureApi>;
}
/**
 * 
 * @export
 * @interface TrafficTrackerUpdate
 */
export interface TrafficTrackerUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof TrafficTrackerUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof TrafficTrackerUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof TrafficTrackerUpdate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof TrafficTrackerUpdate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * 
     * @type {Array<StreamUpdate>}
     * @memberof TrafficTrackerUpdate
     */
    'streams'?: Array<StreamUpdate>;
    /**
     * Network Overrides
     * @type {Array<string>}
     * @memberof TrafficTrackerUpdate
     */
    'networkOverrides'?: Array<string>;
    /**
     * List of Captures
     * @type {Array<CaptureApi>}
     * @memberof TrafficTrackerUpdate
     */
    'captures'?: Array<CaptureApi>;
}
/**
 * 
 * @export
 * @interface TrafficTrackersList200Response
 */
export interface TrafficTrackersList200Response {
    /**
     * 
     * @type {number}
     * @memberof TrafficTrackersList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof TrafficTrackersList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof TrafficTrackersList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof TrafficTrackersList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<TrafficTracker>}
     * @memberof TrafficTrackersList200Response
     */
    'data'?: Array<TrafficTracker>;
}
/**
 * 
 * @export
 * @interface VMDisk
 */
export interface VMDisk {
    /**
     * UUID of the VM Image to load onto the disk
     * @type {string}
     * @memberof VMDisk
     */
    'vmImage': string;
    /**
     * Type of storage to use for this disk
     * @type {string}
     * @memberof VMDisk
     */
    'storageClass'?: string | null;
    /**
     * Quantity of requested storage space to be allocated
     * @type {string}
     * @memberof VMDisk
     */
    'storage': string;
}
/**
 * 
 * @export
 * @interface VMImage
 */
export interface VMImage {
    /**
     * 
     * @type {string}
     * @memberof VMImage
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof VMImage
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof VMImage
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof VMImage
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof VMImage
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof VMImage
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof VMImage
     */
    'metadata'?: object;
    /**
     * Filename of the the upload
     * @type {string}
     * @memberof VMImage
     */
    'filename'?: string;
    /**
     * The signed https url for downloading the image
     * @type {string}
     * @memberof VMImage
     */
    'publicUrl'?: string;
    /**
     * Size of the image in bytes
     * @type {number}
     * @memberof VMImage
     */
    'size'?: number;
    /**
     * 
     * @type {BootDetails}
     * @memberof VMImage
     */
    'bootDetails'?: BootDetails;
}
/**
 * 
 * @export
 * @interface VMInterface
 */
export interface VMInterface {
    /**
     * Optional MAC address, if not provided one will be randomly generated.      NOTE: Containers currently only support MAC addresses with the private prefix of \"0A:58\".
     * @type {string}
     * @memberof VMInterface
     */
    'macAddress'?: string | null;
    /**
     * Optional unique identifier, only used with advanced networking
     * @type {string}
     * @memberof VMInterface
     */
    'id'?: string;
    /**
     * Optional interface name
     * @type {string}
     * @memberof VMInterface
     */
    'interfaceName'?: string;
    /**
     * Optional list of network ports to mirror to this interface
     * @type {Array<MirrorPort>}
     * @memberof VMInterface
     */
    'mirrorPorts'?: Array<MirrorPort>;
    /**
     * Optional ID of a range network, if not provided the default network will be used
     * @type {string}
     * @memberof VMInterface
     */
    'rangeNetwork'?: string | null;
    /**
     * Optional ID of a range host network, only one of rangeIP, rangeAutoIP, rangeNetwork, or rangeHostNetwork should be provided
     * @type {string}
     * @memberof VMInterface
     */
    'rangeHostNetwork'?: string | null;
    /**
     * Optional ID of a range IP, only one of rangeIP, rangeAutoIP, rangeNetwork, or rangeHostNetwork should be provided
     * @type {string}
     * @memberof VMInterface
     */
    'rangeIP'?: string | null;
    /**
     * Optional ID of a range auto IP, only one of rangeIP, rangeAutoIP, rangeNetwork, or rangeHostNetwork should be provided
     * @type {string}
     * @memberof VMInterface
     */
    'rangeAutoIP'?: string | null;
    /**
     * 
     * @type {VmNicModel}
     * @memberof VMInterface
     */
    'vmNicModel'?: VmNicModel | null;
    /**
     * If true, the default gateway will be assigned based on the RangeIP attached to this interface.
     * @type {boolean}
     * @memberof VMInterface
     */
    'defaultGateway'?: boolean;
}


/**
 * 
 * @export
 * @interface VMSpecification
 */
export interface VMSpecification {
    /**
     * 
     * @type {string}
     * @memberof VMSpecification
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof VMSpecification
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof VMSpecification
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof VMSpecification
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof VMSpecification
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof VMSpecification
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof VMSpecification
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof VMSpecification
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Whether the control network NIC is enabled
     * @type {boolean}
     * @memberof VMSpecification
     */
    'controlNetNicEnabled'?: boolean;
    /**
     * Ordered list of disks to attach to the VM
     * @type {Array<VMDisk>}
     * @memberof VMSpecification
     */
    'disks'?: Array<VMDisk>;
    /**
     * 
     * @type {BootImage}
     * @memberof VMSpecification
     */
    'bootImage'?: BootImage;
    /**
     * 
     * @type {CloudInit}
     * @memberof VMSpecification
     */
    'cloudInit'?: CloudInit | null;
    /**
     * Number of CPU cores
     * @type {number}
     * @memberof VMSpecification
     */
    'cpuCores'?: number;
    /**
     * Quantity of requested memory to be allocated
     * @type {string}
     * @memberof VMSpecification
     */
    'memory'?: string;
    /**
     * Hostname of the VM
     * @type {string}
     * @memberof VMSpecification
     */
    'hostname'?: string | null;
    /**
     * Display icon for the vm image
     * @type {string}
     * @memberof VMSpecification
     */
    'iconType'?: VMSpecificationIconTypeEnum;
    /**
     * Ordered list of networks to attach to the VM
     * @type {Array<VMInterface>}
     * @memberof VMSpecification
     */
    'interfaces'?: Array<VMInterface>;
}

export const VMSpecificationIconTypeEnum = {
    FileServer: 'FileServer',
    Firewall: 'Firewall',
    Internet: 'Internet',
    Laptop: 'Laptop',
    MailServer: 'MailServer',
    Mobile: 'Mobile',
    Plc: 'PLC',
    Printer: 'Printer',
    Router: 'Router',
    Server: 'Server',
    Switch: 'Switch',
    WebProxy: 'WebProxy',
    WebServer: 'WebServer',
    WirelessAccessPoint: 'WirelessAccessPoint',
    Workstation: 'Workstation'
} as const;

export type VMSpecificationIconTypeEnum = typeof VMSpecificationIconTypeEnum[keyof typeof VMSpecificationIconTypeEnum];

/**
 * Validation
 * @export
 * @interface Validation
 */
export interface Validation {
    /**
     * User friendly validation message
     * @type {string}
     * @memberof Validation
     */
    'message': string;
    /**
     * Type of validation message
     * @type {string}
     * @memberof Validation
     */
    'code': ValidationCodeEnum;
    /**
     * Severity of the validation message
     * @type {string}
     * @memberof Validation
     */
    'severity': ValidationSeverityEnum;
    /**
     * 
     * @type {ValidationSource}
     * @memberof Validation
     */
    'source'?: ValidationSource;
    /**
     * 
     * @type {ValidationData}
     * @memberof Validation
     */
    'data'?: ValidationData;
}

export const ValidationCodeEnum = {
    Unknown: 'unknown',
    MissingResource: 'missing_resource',
    MissingResourceType: 'missing_resource_type',
    InvalidField: 'invalid_field',
    DuplicateResource: 'duplicate_resource'
} as const;

export type ValidationCodeEnum = typeof ValidationCodeEnum[keyof typeof ValidationCodeEnum];
export const ValidationSeverityEnum = {
    Info: 'info',
    Warning: 'warning',
    Error: 'error'
} as const;

export type ValidationSeverityEnum = typeof ValidationSeverityEnum[keyof typeof ValidationSeverityEnum];

/**
 * @type ValidationData
 * Extra information depending on the code
 * @export
 */
export type ValidationData = ValidationDuplicateResource | ValidationInvalidField | ValidationMissingResource | ValidationMissingResourceType;

/**
 * 
 * @export
 * @interface ValidationDuplicateResource
 */
export interface ValidationDuplicateResource {
    /**
     * 
     * @type {ValidationResource}
     * @memberof ValidationDuplicateResource
     */
    'duplicate': ValidationResource;
    /**
     * Referenced by resource
     * @type {object}
     * @memberof ValidationDuplicateResource
     */
    'referencedBy'?: object;
}
/**
 * 
 * @export
 * @interface ValidationInvalidField
 */
export interface ValidationInvalidField {
    /**
     * 
     * @type {ValidationResource}
     * @memberof ValidationInvalidField
     */
    'resource': ValidationResource;
    /**
     * Name of the invalid field in the resource
     * @type {string}
     * @memberof ValidationInvalidField
     */
    'field': string;
}
/**
 * 
 * @export
 * @interface ValidationMissingResource
 */
export interface ValidationMissingResource {
    /**
     * 
     * @type {ValidationResource}
     * @memberof ValidationMissingResource
     */
    'missing': ValidationResource;
    /**
     * Referenced by resource
     * @type {object}
     * @memberof ValidationMissingResource
     */
    'referencedBy'?: object;
}
/**
 * 
 * @export
 * @interface ValidationMissingResourceType
 */
export interface ValidationMissingResourceType {
    /**
     * Missing resource type
     * @type {object}
     * @memberof ValidationMissingResourceType
     */
    'missingType': object;
    /**
     * Required by resource
     * @type {object}
     * @memberof ValidationMissingResourceType
     */
    'requiredBy'?: object;
}
/**
 * Validation Resource
 * @export
 * @interface ValidationResource
 */
export interface ValidationResource {
    /**
     * Resource identifier
     * @type {string}
     * @memberof ValidationResource
     */
    'uuid': string;
    /**
     * Human readable name
     * @type {string}
     * @memberof ValidationResource
     */
    'name'?: string;
    /**
     * Resource type
     * @type {string}
     * @memberof ValidationResource
     */
    'type': ValidationResourceTypeEnum;
}

export const ValidationResourceTypeEnum = {
    AnsiblePlaybook: 'AnsiblePlaybook',
    ContainerSpecification: 'ContainerSpecification',
    EventTree: 'EventTree',
    GhostAgent: 'GhostAgent',
    GhostC2Server: 'GhostC2Server',
    GhostClient: 'GhostClient',
    GhostTrafficProfile: 'GhostTrafficProfile',
    InternetGateway: 'InternetGateway',
    Package: 'Package',
    RangeAutoIp: 'RangeAutoIP',
    RangeBgp: 'RangeBGP',
    RangeBgpLink: 'RangeBGPLink',
    RangeCert: 'RangeCert',
    RangeConsole: 'RangeConsole',
    RangeDnsRecord: 'RangeDNSRecord',
    RangeDnsServer: 'RangeDNSServer',
    RangeDnsZone: 'RangeDNSZone',
    RangeHostNetwork: 'RangeHostNetwork',
    RangeIp: 'RangeIP',
    RangeL3Network: 'RangeL3Network',
    RangeNetwork: 'RangeNetwork',
    RangePki: 'RangePki',
    RangeRouter: 'RangeRouter',
    RangeTorNet: 'RangeTorNet',
    RangeVolume: 'RangeVolume',
    VmSpecification: 'VMSpecification'
} as const;

export type ValidationResourceTypeEnum = typeof ValidationResourceTypeEnum[keyof typeof ValidationResourceTypeEnum];

/**
 * Validation source
 * @export
 * @interface ValidationSource
 */
export interface ValidationSource {
    /**
     * Source identifier
     * @type {string}
     * @memberof ValidationSource
     */
    'uuid': string;
    /**
     * Human readable name
     * @type {string}
     * @memberof ValidationSource
     */
    'name'?: string;
    /**
     * Source type
     * @type {string}
     * @memberof ValidationSource
     */
    'type': ValidationSourceTypeEnum;
}

export const ValidationSourceTypeEnum = {
    Package: 'Package',
    ContainerSpecification: 'ContainerSpecification'
} as const;

export type ValidationSourceTypeEnum = typeof ValidationSourceTypeEnum[keyof typeof ValidationSourceTypeEnum];

/**
 * Virtual Machine Restore
 * @export
 * @interface VirtualMachineRestore
 */
export interface VirtualMachineRestore {
    /**
     * Name of the restore
     * @type {string}
     * @memberof VirtualMachineRestore
     */
    'name'?: string;
    /**
     * Creation timestamp of the restore from Kubernetes
     * @type {string}
     * @memberof VirtualMachineRestore
     */
    'creationTimestamp'?: string;
    /**
     * Name of the VM that was restored 
     * @type {string}
     * @memberof VirtualMachineRestore
     */
    'vmName'?: string;
    /**
     * UUID of the range that the VM belongs to
     * @type {string}
     * @memberof VirtualMachineRestore
     */
    'rangeId'?: string;
    /**
     * UUID of the scenario that the VM belongs to
     * @type {string}
     * @memberof VirtualMachineRestore
     */
    'scenarioId'?: string;
    /**
     * Name of the snapshot that the VM was restored from
     * @type {string}
     * @memberof VirtualMachineRestore
     */
    'snapshotName'?: string;
    /**
     * Volume that contains the restore
     * @type {string}
     * @memberof VirtualMachineRestore
     */
    'volumeName'?: string;
    /**
     * Claim that the volume is attached to
     * @type {string}
     * @memberof VirtualMachineRestore
     */
    'claimName'?: string;
    /**
     * Name of volume snapshot that the restore was created from
     * @type {string}
     * @memberof VirtualMachineRestore
     */
    'volumeSnapshotName'?: string;
    /**
     * True if the restore is complete, false otherwise
     * @type {boolean}
     * @memberof VirtualMachineRestore
     */
    'complete'?: boolean;
    /**
     * True if the restore is ready, false otherwise
     * @type {boolean}
     * @memberof VirtualMachineRestore
     */
    'ready'?: boolean;
    /**
     * Kubevirt\'s VirtualMachineRestore condition status
     * @type {string}
     * @memberof VirtualMachineRestore
     */
    'status'?: string;
    /**
     * Failure message for the condition only present if failed
     * @type {string}
     * @memberof VirtualMachineRestore
     */
    'message'?: string;
    /**
     * Type of condition: Ready, Progressing, or Failure
     * @type {string}
     * @memberof VirtualMachineRestore
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface VirtualMachineRestoresList200Response
 */
export interface VirtualMachineRestoresList200Response {
    /**
     * 
     * @type {number}
     * @memberof VirtualMachineRestoresList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof VirtualMachineRestoresList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof VirtualMachineRestoresList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof VirtualMachineRestoresList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<VirtualMachineRestore>}
     * @memberof VirtualMachineRestoresList200Response
     */
    'data'?: Array<VirtualMachineRestore>;
}
/**
 * Virtual Machine Snapshot
 * @export
 * @interface VirtualMachineSnapshot
 */
export interface VirtualMachineSnapshot {
    /**
     * Name of the snapshot
     * @type {string}
     * @memberof VirtualMachineSnapshot
     */
    'name'?: string;
    /**
     * Creation timestamp of the snapshot from Kubernetes
     * @type {string}
     * @memberof VirtualMachineSnapshot
     */
    'creationTimestamp'?: string;
    /**
     * Name of the VM that the snapshot was taken of
     * @type {string}
     * @memberof VirtualMachineSnapshot
     */
    'vmName'?: string;
    /**
     * UUID of the range that the VM belongs to
     * @type {string}
     * @memberof VirtualMachineSnapshot
     */
    'rangeId'?: string;
    /**
     * UUID of the scenario that the VM belongs to
     * @type {string}
     * @memberof VirtualMachineSnapshot
     */
    'scenarioId'?: string;
    /**
     * Phase that the Snapshot is in
     * @type {string}
     * @memberof VirtualMachineSnapshot
     */
    'phase'?: string;
    /**
     * Whether the snapshot is ready to use or not
     * @type {boolean}
     * @memberof VirtualMachineSnapshot
     */
    'readyToUse'?: boolean;
}
/**
 * 
 * @export
 * @interface VirtualMachineSnapshotsListSnapshots200Response
 */
export interface VirtualMachineSnapshotsListSnapshots200Response {
    /**
     * 
     * @type {number}
     * @memberof VirtualMachineSnapshotsListSnapshots200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof VirtualMachineSnapshotsListSnapshots200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof VirtualMachineSnapshotsListSnapshots200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof VirtualMachineSnapshotsListSnapshots200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<VirtualMachineSnapshot>}
     * @memberof VirtualMachineSnapshotsListSnapshots200Response
     */
    'data'?: Array<VirtualMachineSnapshot>;
}
/**
 * 
 * @export
 * @interface VmImageCreate
 */
export interface VmImageCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof VmImageCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof VmImageCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof VmImageCreate
     */
    'metadata'?: object;
    /**
     * The file to upload
     * @type {File}
     * @memberof VmImageCreate
     */
    'file': File;
    /**
     * 
     * @type {BootDetailsCreate}
     * @memberof VmImageCreate
     */
    'bootDetails'?: BootDetailsCreate;
}
/**
 * 
 * @export
 * @interface VmImageUpdate
 */
export interface VmImageUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof VmImageUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof VmImageUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof VmImageUpdate
     */
    'metadata'?: object;
    /**
     * 
     * @type {BootDetailsUpdate}
     * @memberof VmImageUpdate
     */
    'bootDetails'?: BootDetailsUpdate;
}
/**
 * 
 * @export
 * @interface VmImagesList200Response
 */
export interface VmImagesList200Response {
    /**
     * 
     * @type {number}
     * @memberof VmImagesList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof VmImagesList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof VmImagesList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof VmImagesList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<VMImage>}
     * @memberof VmImagesList200Response
     */
    'data'?: Array<VMImage>;
}
/**
 * 
 * @export
 * @interface VmInterfaceCreate
 */
export interface VmInterfaceCreate {
    /**
     * Optional MAC address, if not provided one will be randomly generated.      NOTE: Containers currently only support MAC addresses with the private prefix of \"0A:58\".
     * @type {string}
     * @memberof VmInterfaceCreate
     */
    'macAddress'?: string | null;
    /**
     * Optional unique identifier, only used with advanced networking
     * @type {string}
     * @memberof VmInterfaceCreate
     */
    'id'?: string;
    /**
     * Optional interface name
     * @type {string}
     * @memberof VmInterfaceCreate
     */
    'interfaceName'?: string;
    /**
     * Optional list of network ports to mirror to this interface
     * @type {Array<MirrorPort>}
     * @memberof VmInterfaceCreate
     */
    'mirrorPorts'?: Array<MirrorPort>;
    /**
     * Optional ID of a range network, if not provided the default network will be used
     * @type {string}
     * @memberof VmInterfaceCreate
     */
    'rangeNetwork'?: string | null;
    /**
     * Optional ID of a range host network, only one of rangeIP, rangeAutoIP, rangeNetwork, or rangeHostNetwork should be provided
     * @type {string}
     * @memberof VmInterfaceCreate
     */
    'rangeHostNetwork'?: string | null;
    /**
     * Optional ID of a range IP, only one of rangeIP, rangeAutoIP, rangeNetwork, or rangeHostNetwork should be provided
     * @type {string}
     * @memberof VmInterfaceCreate
     */
    'rangeIP'?: string | null;
    /**
     * Optional ID of a range auto IP, only one of rangeIP, rangeAutoIP, rangeNetwork, or rangeHostNetwork should be provided
     * @type {string}
     * @memberof VmInterfaceCreate
     */
    'rangeAutoIP'?: string | null;
    /**
     * 
     * @type {VmNicModel}
     * @memberof VmInterfaceCreate
     */
    'vmNicModel'?: VmNicModel | null;
    /**
     * If true, the default gateway will be assigned based on the RangeIP attached to this interface.
     * @type {boolean}
     * @memberof VmInterfaceCreate
     */
    'defaultGateway'?: boolean;
}


/**
 * 
 * @export
 * @interface VmInterfaceUpdate
 */
export interface VmInterfaceUpdate {
    /**
     * Optional MAC address, if not provided one will be randomly generated.      NOTE: Containers currently only support MAC addresses with the private prefix of \"0A:58\".
     * @type {string}
     * @memberof VmInterfaceUpdate
     */
    'macAddress'?: string | null;
    /**
     * Optional unique identifier, only used with advanced networking
     * @type {string}
     * @memberof VmInterfaceUpdate
     */
    'id'?: string;
    /**
     * Optional interface name
     * @type {string}
     * @memberof VmInterfaceUpdate
     */
    'interfaceName'?: string;
    /**
     * Optional list of network ports to mirror to this interface
     * @type {Array<MirrorPort>}
     * @memberof VmInterfaceUpdate
     */
    'mirrorPorts'?: Array<MirrorPort>;
    /**
     * Optional ID of a range network, if not provided the default network will be used
     * @type {string}
     * @memberof VmInterfaceUpdate
     */
    'rangeNetwork'?: string | null;
    /**
     * Optional ID of a range host network, only one of rangeIP, rangeAutoIP, rangeNetwork, or rangeHostNetwork should be provided
     * @type {string}
     * @memberof VmInterfaceUpdate
     */
    'rangeHostNetwork'?: string | null;
    /**
     * Optional ID of a range IP, only one of rangeIP, rangeAutoIP, rangeNetwork, or rangeHostNetwork should be provided
     * @type {string}
     * @memberof VmInterfaceUpdate
     */
    'rangeIP'?: string | null;
    /**
     * Optional ID of a range auto IP, only one of rangeIP, rangeAutoIP, rangeNetwork, or rangeHostNetwork should be provided
     * @type {string}
     * @memberof VmInterfaceUpdate
     */
    'rangeAutoIP'?: string | null;
    /**
     * 
     * @type {VmNicModel}
     * @memberof VmInterfaceUpdate
     */
    'vmNicModel'?: VmNicModel | null;
    /**
     * If true, the default gateway will be assigned based on the RangeIP attached to this interface.
     * @type {boolean}
     * @memberof VmInterfaceUpdate
     */
    'defaultGateway'?: boolean;
}


/**
 * Nic Model
 * @export
 * @enum {string}
 */

export const VmNicModel = {
    E1000: 'e1000',
    E1000e: 'e1000e',
    Ne2kPci: 'ne2k_pci',
    Pcnet: 'pcnet',
    Rtl8139: 'rtl8139',
    Virtio: 'virtio'
} as const;

export type VmNicModel = typeof VmNicModel[keyof typeof VmNicModel];


/**
 * 
 * @export
 * @interface VmSpecificationCreate
 */
export interface VmSpecificationCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof VmSpecificationCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof VmSpecificationCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof VmSpecificationCreate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof VmSpecificationCreate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Whether the control network NIC is enabled
     * @type {boolean}
     * @memberof VmSpecificationCreate
     */
    'controlNetNicEnabled': boolean;
    /**
     * Ordered list of disks to attach to the VM
     * @type {Array<VMDisk>}
     * @memberof VmSpecificationCreate
     */
    'disks'?: Array<VMDisk>;
    /**
     * 
     * @type {BootImageCreate}
     * @memberof VmSpecificationCreate
     */
    'bootImage': BootImageCreate;
    /**
     * 
     * @type {CloudInit}
     * @memberof VmSpecificationCreate
     */
    'cloudInit'?: CloudInit | null;
    /**
     * Number of CPU cores
     * @type {number}
     * @memberof VmSpecificationCreate
     */
    'cpuCores': number;
    /**
     * Quantity of requested memory to be allocated
     * @type {string}
     * @memberof VmSpecificationCreate
     */
    'memory': string;
    /**
     * Hostname of the VM
     * @type {string}
     * @memberof VmSpecificationCreate
     */
    'hostname'?: string | null;
    /**
     * Ordered list of networks to attach to the VM
     * @type {Array<VmInterfaceCreate>}
     * @memberof VmSpecificationCreate
     */
    'interfaces'?: Array<VmInterfaceCreate>;
}
/**
 * 
 * @export
 * @interface VmSpecificationOverride
 */
export interface VmSpecificationOverride {
    /**
     * User provided metadata
     * @type {object}
     * @memberof VmSpecificationOverride
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof VmSpecificationOverride
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Whether the control network NIC is enabled
     * @type {boolean}
     * @memberof VmSpecificationOverride
     */
    'controlNetNicEnabled'?: boolean;
    /**
     * Ordered list of disks to attach to the VM
     * @type {Array<VMDisk>}
     * @memberof VmSpecificationOverride
     */
    'disks'?: Array<VMDisk>;
    /**
     * 
     * @type {BootImageOverride}
     * @memberof VmSpecificationOverride
     */
    'bootImage'?: BootImageOverride;
    /**
     * 
     * @type {CloudInit}
     * @memberof VmSpecificationOverride
     */
    'cloudInit'?: CloudInit | null;
    /**
     * Number of CPU cores
     * @type {number}
     * @memberof VmSpecificationOverride
     */
    'cpuCores'?: number;
    /**
     * Quantity of requested memory to be allocated
     * @type {string}
     * @memberof VmSpecificationOverride
     */
    'memory'?: string;
    /**
     * Hostname of the VM
     * @type {string}
     * @memberof VmSpecificationOverride
     */
    'hostname'?: string | null;
}
/**
 * 
 * @export
 * @interface VmSpecificationUpdate
 */
export interface VmSpecificationUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof VmSpecificationUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof VmSpecificationUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof VmSpecificationUpdate
     */
    'metadata'?: object;
    /**
     * Optional list of ScenarioGroups that can view the resource when deployed
     * @type {Array<ScenarioGroup>}
     * @memberof VmSpecificationUpdate
     */
    'scenarioGroups'?: Array<ScenarioGroup>;
    /**
     * Whether the control network NIC is enabled
     * @type {boolean}
     * @memberof VmSpecificationUpdate
     */
    'controlNetNicEnabled'?: boolean;
    /**
     * Ordered list of disks to attach to the VM
     * @type {Array<VMDisk>}
     * @memberof VmSpecificationUpdate
     */
    'disks'?: Array<VMDisk>;
    /**
     * 
     * @type {BootImageUpdate}
     * @memberof VmSpecificationUpdate
     */
    'bootImage'?: BootImageUpdate;
    /**
     * 
     * @type {CloudInit}
     * @memberof VmSpecificationUpdate
     */
    'cloudInit'?: CloudInit | null;
    /**
     * Number of CPU cores
     * @type {number}
     * @memberof VmSpecificationUpdate
     */
    'cpuCores'?: number;
    /**
     * Quantity of requested memory to be allocated
     * @type {string}
     * @memberof VmSpecificationUpdate
     */
    'memory'?: string;
    /**
     * Hostname of the VM
     * @type {string}
     * @memberof VmSpecificationUpdate
     */
    'hostname'?: string | null;
    /**
     * Ordered list of networks to attach to the VM
     * @type {Array<VmInterfaceUpdate>}
     * @memberof VmSpecificationUpdate
     */
    'interfaces'?: Array<VmInterfaceUpdate>;
}
/**
 * 
 * @export
 * @interface VmSpecificationsList200Response
 */
export interface VmSpecificationsList200Response {
    /**
     * 
     * @type {number}
     * @memberof VmSpecificationsList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof VmSpecificationsList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof VmSpecificationsList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof VmSpecificationsList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<VMSpecification>}
     * @memberof VmSpecificationsList200Response
     */
    'data'?: Array<VMSpecification>;
}
/**
 * 
 * @export
 * @interface Volume
 */
export interface Volume {
    /**
     * 
     * @type {string}
     * @memberof Volume
     */
    'uuid'?: string;
    /**
     * Date when the object was created.
     * @type {string}
     * @memberof Volume
     */
    'dateCreated'?: string;
    /**
     * Date when the object was last edited.
     * @type {string}
     * @memberof Volume
     */
    'dateEdited'?: string;
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof Volume
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof Volume
     */
    'name'?: string;
    /**
     * The author of the package.
     * @type {string}
     * @memberof Volume
     */
    'author'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof Volume
     */
    'metadata'?: object;
    /**
     * Filename of the the upload
     * @type {string}
     * @memberof Volume
     */
    'filename'?: string;
    /**
     * The signed https url for downloading the image
     * @type {string}
     * @memberof Volume
     */
    'publicUrl'?: string;
    /**
     * Size of the image in bytes
     * @type {number}
     * @memberof Volume
     */
    'size'?: number;
    /**
     * Type of the volume
     * @type {string}
     * @memberof Volume
     */
    'volumeType'?: string;
}
/**
 * 
 * @export
 * @interface VolumeCreate
 */
export interface VolumeCreate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof VolumeCreate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof VolumeCreate
     */
    'name': string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof VolumeCreate
     */
    'metadata'?: object;
    /**
     * The file to upload
     * @type {File}
     * @memberof VolumeCreate
     */
    'file': File;
    /**
     * Type of the volume
     * @type {string}
     * @memberof VolumeCreate
     */
    'volumeType': string;
}
/**
 * 
 * @export
 * @interface VolumeUpdate
 */
export interface VolumeUpdate {
    /**
     * A user provided human readable description.
     * @type {string}
     * @memberof VolumeUpdate
     */
    'description'?: string;
    /**
     * A user provided human readable name.
     * @type {string}
     * @memberof VolumeUpdate
     */
    'name'?: string;
    /**
     * User provided metadata
     * @type {object}
     * @memberof VolumeUpdate
     */
    'metadata'?: object;
    /**
     * Type of the volume
     * @type {string}
     * @memberof VolumeUpdate
     */
    'volumeType'?: string;
}
/**
 * 
 * @export
 * @interface VolumesList200Response
 */
export interface VolumesList200Response {
    /**
     * 
     * @type {number}
     * @memberof VolumesList200Response
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof VolumesList200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof VolumesList200Response
     */
    'totalCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof VolumesList200Response
     */
    'totalPages'?: number;
    /**
     * 
     * @type {Array<Volume>}
     * @memberof VolumesList200Response
     */
    'data'?: Array<Volume>;
}
/**
 * 
 * @export
 * @interface VsphereMachineConfig
 */
export interface VsphereMachineConfig {
    /**
     * vSphere vm configuration parameters (used for guestinfo)
     * @type {Array<string>}
     * @memberof VsphereMachineConfig
     */
    'cfgparam'?: Array<string>;
    /**
     * Name of what to clone
     * @type {string}
     * @memberof VsphereMachineConfig
     */
    'cloneFrom'?: string;
    /**
     * Filepath to a cloud-config yaml file to put into the ISO user-data
     * @type {string}
     * @memberof VsphereMachineConfig
     */
    'cloudConfig'?: string;
    /**
     * vSphere cloud-init filepath or url to add to guestinfo, filepath will be read and base64 encoded before adding
     * @type {string}
     * @memberof VsphereMachineConfig
     */
    'cloudinit'?: string;
    /**
     * vSphere CPU number for docker VM
     * @type {number}
     * @memberof VsphereMachineConfig
     */
    'cpuCount'?: number;
    /**
     * Creation type when creating a new virtual machine
     * @type {string}
     * @memberof VsphereMachineConfig
     */
    'creationType'?: VsphereMachineConfigCreationTypeEnum;
    /**
     * vSphere datacenter for virtual machine
     * @type {string}
     * @memberof VsphereMachineConfig
     */
    'datacenter'?: string;
    /**
     * vSphere datastore for virtual machine
     * @type {string}
     * @memberof VsphereMachineConfig
     */
    'datastore'?: string;
    /**
     * vSphere datastore cluster for virtual machine
     * @type {string}
     * @memberof VsphereMachineConfig
     */
    'datastoreCluster'?: string;
    /**
     * vSphere size of disk for docker VM (in MB)
     * @type {number}
     * @memberof VsphereMachineConfig
     */
    'diskSize'?: number;
    /**
     * vSphere folder for the docker VM. This folder must already exist in the datacenter
     * @type {string}
     * @memberof VsphereMachineConfig
     */
    'folder'?: string;
    /**
     * vSphere size of memory for docker VM (in MB)
     * @type {number}
     * @memberof VsphereMachineConfig
     */
    'memorySize'?: number;
    /**
     * vSphere networks where the virtual machine will be attached
     * @type {Array<string>}
     * @memberof VsphereMachineConfig
     */
    'network'?: Array<string>;
    /**
     * If using a non-B2D image you can specify the desired machine OS
     * @type {string}
     * @memberof VsphereMachineConfig
     */
    'os'?: string;
    /**
     * vSphere resource pool for docker VM
     * @type {string}
     * @memberof VsphereMachineConfig
     */
    'pool'?: string;
    /**
     * If using a non-B2D image you can specify the ssh password
     * @type {string}
     * @memberof VsphereMachineConfig
     */
    'sshPassword'?: string;
    /**
     * If using a non-B2D image you can specify the ssh port
     * @type {number}
     * @memberof VsphereMachineConfig
     */
    'sshPort'?: number;
    /**
     * If using a non-B2D image you can specify the ssh user
     * @type {string}
     * @memberof VsphereMachineConfig
     */
    'sshUser'?: string;
    /**
     * If using a non-B2D image the uploaded keys will need chown\'ed, defaults to staff e.g. docker:staff
     * @type {string}
     * @memberof VsphereMachineConfig
     */
    'sshUserGroup'?: string;
    /**
     * vSphere tag id e.g. urn:xxx
     * @type {Array<string>}
     * @memberof VsphereMachineConfig
     */
    'tag'?: Array<string>;
}

export const VsphereMachineConfigCreationTypeEnum = {
    Vm: 'vm',
    Template: 'template',
    Library: 'library',
    Legacy: 'legacy'
} as const;

export type VsphereMachineConfigCreationTypeEnum = typeof VsphereMachineConfigCreationTypeEnum[keyof typeof VsphereMachineConfigCreationTypeEnum];

/**
 * 
 * @export
 * @interface VsphereMachineConfigCreate
 */
export interface VsphereMachineConfigCreate {
    /**
     * vSphere vm configuration parameters (used for guestinfo)
     * @type {Array<string>}
     * @memberof VsphereMachineConfigCreate
     */
    'cfgparam'?: Array<string>;
    /**
     * Name of what to clone
     * @type {string}
     * @memberof VsphereMachineConfigCreate
     */
    'cloneFrom'?: string;
    /**
     * Filepath to a cloud-config yaml file to put into the ISO user-data
     * @type {string}
     * @memberof VsphereMachineConfigCreate
     */
    'cloudConfig'?: string;
    /**
     * vSphere cloud-init filepath or url to add to guestinfo, filepath will be read and base64 encoded before adding
     * @type {string}
     * @memberof VsphereMachineConfigCreate
     */
    'cloudinit'?: string;
    /**
     * vSphere CPU number for docker VM
     * @type {number}
     * @memberof VsphereMachineConfigCreate
     */
    'cpuCount': number;
    /**
     * Creation type when creating a new virtual machine
     * @type {string}
     * @memberof VsphereMachineConfigCreate
     */
    'creationType': VsphereMachineConfigCreateCreationTypeEnum;
    /**
     * vSphere datacenter for virtual machine
     * @type {string}
     * @memberof VsphereMachineConfigCreate
     */
    'datacenter': string;
    /**
     * vSphere datastore for virtual machine
     * @type {string}
     * @memberof VsphereMachineConfigCreate
     */
    'datastore'?: string;
    /**
     * vSphere datastore cluster for virtual machine
     * @type {string}
     * @memberof VsphereMachineConfigCreate
     */
    'datastoreCluster'?: string;
    /**
     * vSphere size of disk for docker VM (in MB)
     * @type {number}
     * @memberof VsphereMachineConfigCreate
     */
    'diskSize': number;
    /**
     * vSphere folder for the docker VM. This folder must already exist in the datacenter
     * @type {string}
     * @memberof VsphereMachineConfigCreate
     */
    'folder'?: string;
    /**
     * vSphere size of memory for docker VM (in MB)
     * @type {number}
     * @memberof VsphereMachineConfigCreate
     */
    'memorySize': number;
    /**
     * vSphere networks where the virtual machine will be attached
     * @type {Array<string>}
     * @memberof VsphereMachineConfigCreate
     */
    'network'?: Array<string>;
    /**
     * If using a non-B2D image you can specify the desired machine OS
     * @type {string}
     * @memberof VsphereMachineConfigCreate
     */
    'os'?: string;
    /**
     * vSphere resource pool for docker VM
     * @type {string}
     * @memberof VsphereMachineConfigCreate
     */
    'pool'?: string;
    /**
     * If using a non-B2D image you can specify the ssh password
     * @type {string}
     * @memberof VsphereMachineConfigCreate
     */
    'sshPassword'?: string;
    /**
     * If using a non-B2D image you can specify the ssh port
     * @type {number}
     * @memberof VsphereMachineConfigCreate
     */
    'sshPort'?: number;
    /**
     * If using a non-B2D image you can specify the ssh user
     * @type {string}
     * @memberof VsphereMachineConfigCreate
     */
    'sshUser'?: string;
    /**
     * If using a non-B2D image the uploaded keys will need chown\'ed, defaults to staff e.g. docker:staff
     * @type {string}
     * @memberof VsphereMachineConfigCreate
     */
    'sshUserGroup'?: string;
    /**
     * vSphere tag id e.g. urn:xxx
     * @type {Array<string>}
     * @memberof VsphereMachineConfigCreate
     */
    'tag'?: Array<string>;
}

export const VsphereMachineConfigCreateCreationTypeEnum = {
    Vm: 'vm',
    Template: 'template',
    Library: 'library',
    Legacy: 'legacy'
} as const;

export type VsphereMachineConfigCreateCreationTypeEnum = typeof VsphereMachineConfigCreateCreationTypeEnum[keyof typeof VsphereMachineConfigCreateCreationTypeEnum];

/**
 * 
 * @export
 * @interface VsphereMachineConfigUpdate
 */
export interface VsphereMachineConfigUpdate {
    /**
     * vSphere vm configuration parameters (used for guestinfo)
     * @type {Array<string>}
     * @memberof VsphereMachineConfigUpdate
     */
    'cfgparam'?: Array<string>;
    /**
     * Name of what to clone
     * @type {string}
     * @memberof VsphereMachineConfigUpdate
     */
    'cloneFrom'?: string;
    /**
     * Filepath to a cloud-config yaml file to put into the ISO user-data
     * @type {string}
     * @memberof VsphereMachineConfigUpdate
     */
    'cloudConfig'?: string;
    /**
     * vSphere cloud-init filepath or url to add to guestinfo, filepath will be read and base64 encoded before adding
     * @type {string}
     * @memberof VsphereMachineConfigUpdate
     */
    'cloudinit'?: string;
    /**
     * vSphere CPU number for docker VM
     * @type {number}
     * @memberof VsphereMachineConfigUpdate
     */
    'cpuCount'?: number;
    /**
     * Creation type when creating a new virtual machine
     * @type {string}
     * @memberof VsphereMachineConfigUpdate
     */
    'creationType'?: VsphereMachineConfigUpdateCreationTypeEnum;
    /**
     * vSphere datacenter for virtual machine
     * @type {string}
     * @memberof VsphereMachineConfigUpdate
     */
    'datacenter'?: string;
    /**
     * vSphere datastore for virtual machine
     * @type {string}
     * @memberof VsphereMachineConfigUpdate
     */
    'datastore'?: string;
    /**
     * vSphere datastore cluster for virtual machine
     * @type {string}
     * @memberof VsphereMachineConfigUpdate
     */
    'datastoreCluster'?: string;
    /**
     * vSphere size of disk for docker VM (in MB)
     * @type {number}
     * @memberof VsphereMachineConfigUpdate
     */
    'diskSize'?: number;
    /**
     * vSphere folder for the docker VM. This folder must already exist in the datacenter
     * @type {string}
     * @memberof VsphereMachineConfigUpdate
     */
    'folder'?: string;
    /**
     * vSphere size of memory for docker VM (in MB)
     * @type {number}
     * @memberof VsphereMachineConfigUpdate
     */
    'memorySize'?: number;
    /**
     * vSphere networks where the virtual machine will be attached
     * @type {Array<string>}
     * @memberof VsphereMachineConfigUpdate
     */
    'network'?: Array<string>;
    /**
     * If using a non-B2D image you can specify the desired machine OS
     * @type {string}
     * @memberof VsphereMachineConfigUpdate
     */
    'os'?: string;
    /**
     * vSphere resource pool for docker VM
     * @type {string}
     * @memberof VsphereMachineConfigUpdate
     */
    'pool'?: string;
    /**
     * If using a non-B2D image you can specify the ssh password
     * @type {string}
     * @memberof VsphereMachineConfigUpdate
     */
    'sshPassword'?: string;
    /**
     * If using a non-B2D image you can specify the ssh port
     * @type {number}
     * @memberof VsphereMachineConfigUpdate
     */
    'sshPort'?: number;
    /**
     * If using a non-B2D image you can specify the ssh user
     * @type {string}
     * @memberof VsphereMachineConfigUpdate
     */
    'sshUser'?: string;
    /**
     * If using a non-B2D image the uploaded keys will need chown\'ed, defaults to staff e.g. docker:staff
     * @type {string}
     * @memberof VsphereMachineConfigUpdate
     */
    'sshUserGroup'?: string;
    /**
     * vSphere tag id e.g. urn:xxx
     * @type {Array<string>}
     * @memberof VsphereMachineConfigUpdate
     */
    'tag'?: Array<string>;
}

export const VsphereMachineConfigUpdateCreationTypeEnum = {
    Vm: 'vm',
    Template: 'template',
    Library: 'library',
    Legacy: 'legacy'
} as const;

export type VsphereMachineConfigUpdateCreationTypeEnum = typeof VsphereMachineConfigUpdateCreationTypeEnum[keyof typeof VsphereMachineConfigUpdateCreationTypeEnum];

/**
 * 
 * @export
 * @interface VsphereMachinePool
 */
export interface VsphereMachinePool {
    /**
     * If true, assigns the Control Plane role to machines in this pool
     * @type {boolean}
     * @memberof VsphereMachinePool
     */
    'controlPlaneRole'?: boolean;
    /**
     * If true, assigns the etcd role to machines in this pool
     * @type {boolean}
     * @memberof VsphereMachinePool
     */
    'etcdRole'?: boolean;
    /**
     * If true, assigns the worker role to machines in this pool
     * @type {boolean}
     * @memberof VsphereMachinePool
     */
    'workerRole'?: boolean;
    /**
     * Labels to assign to machines in this pool
     * @type {{ [key: string]: string; }}
     * @memberof VsphereMachinePool
     */
    'labels'?: { [key: string]: string; };
    /**
     * Name of the machine pool, should be unique for a range
     * @type {string}
     * @memberof VsphereMachinePool
     */
    'name'?: string;
    /**
     * Number of machines in the pool
     * @type {number}
     * @memberof VsphereMachinePool
     */
    'quantity'?: number;
    /**
     * Taints to assign to machines in this pool
     * @type {Array<MachineTaint>}
     * @memberof VsphereMachinePool
     */
    'taints'?: Array<MachineTaint>;
    /**
     * Time (in secs) before a machine is considered unhealthy if it cannot be reached
     * @type {number}
     * @memberof VsphereMachinePool
     */
    'unhealthyNodeTimeout'?: number;
    /**
     * Operating system of machines in this pool
     * @type {string}
     * @memberof VsphereMachinePool
     */
    'machineOS'?: VsphereMachinePoolMachineOSEnum;
    /**
     * 
     * @type {VsphereMachineConfig}
     * @memberof VsphereMachinePool
     */
    'machineConfig'?: VsphereMachineConfig;
}

export const VsphereMachinePoolMachineOSEnum = {
    Linux: 'linux',
    Windows: 'windows'
} as const;

export type VsphereMachinePoolMachineOSEnum = typeof VsphereMachinePoolMachineOSEnum[keyof typeof VsphereMachinePoolMachineOSEnum];

/**
 * 
 * @export
 * @interface VsphereMachinePoolCreate
 */
export interface VsphereMachinePoolCreate {
    /**
     * If true, assigns the Control Plane role to machines in this pool
     * @type {boolean}
     * @memberof VsphereMachinePoolCreate
     */
    'controlPlaneRole'?: boolean;
    /**
     * If true, assigns the etcd role to machines in this pool
     * @type {boolean}
     * @memberof VsphereMachinePoolCreate
     */
    'etcdRole'?: boolean;
    /**
     * If true, assigns the worker role to machines in this pool
     * @type {boolean}
     * @memberof VsphereMachinePoolCreate
     */
    'workerRole'?: boolean;
    /**
     * Labels to assign to machines in this pool
     * @type {{ [key: string]: string; }}
     * @memberof VsphereMachinePoolCreate
     */
    'labels'?: { [key: string]: string; };
    /**
     * Name of the machine pool, should be unique for a range
     * @type {string}
     * @memberof VsphereMachinePoolCreate
     */
    'name'?: string;
    /**
     * Number of machines in the pool
     * @type {number}
     * @memberof VsphereMachinePoolCreate
     */
    'quantity'?: number;
    /**
     * Taints to assign to machines in this pool
     * @type {Array<MachineTaint>}
     * @memberof VsphereMachinePoolCreate
     */
    'taints'?: Array<MachineTaint>;
    /**
     * Time (in secs) before a machine is considered unhealthy if it cannot be reached
     * @type {number}
     * @memberof VsphereMachinePoolCreate
     */
    'unhealthyNodeTimeout'?: number;
    /**
     * Operating system of machines in this pool
     * @type {string}
     * @memberof VsphereMachinePoolCreate
     */
    'machineOS'?: VsphereMachinePoolCreateMachineOSEnum;
    /**
     * 
     * @type {VsphereMachineConfigCreate}
     * @memberof VsphereMachinePoolCreate
     */
    'machineConfig'?: VsphereMachineConfigCreate;
}

export const VsphereMachinePoolCreateMachineOSEnum = {
    Linux: 'linux',
    Windows: 'windows'
} as const;

export type VsphereMachinePoolCreateMachineOSEnum = typeof VsphereMachinePoolCreateMachineOSEnum[keyof typeof VsphereMachinePoolCreateMachineOSEnum];

/**
 * 
 * @export
 * @interface VsphereMachinePoolUpdate
 */
export interface VsphereMachinePoolUpdate {
    /**
     * If true, assigns the Control Plane role to machines in this pool
     * @type {boolean}
     * @memberof VsphereMachinePoolUpdate
     */
    'controlPlaneRole'?: boolean;
    /**
     * If true, assigns the etcd role to machines in this pool
     * @type {boolean}
     * @memberof VsphereMachinePoolUpdate
     */
    'etcdRole'?: boolean;
    /**
     * If true, assigns the worker role to machines in this pool
     * @type {boolean}
     * @memberof VsphereMachinePoolUpdate
     */
    'workerRole'?: boolean;
    /**
     * Labels to assign to machines in this pool
     * @type {{ [key: string]: string; }}
     * @memberof VsphereMachinePoolUpdate
     */
    'labels'?: { [key: string]: string; };
    /**
     * Name of the machine pool, should be unique for a range
     * @type {string}
     * @memberof VsphereMachinePoolUpdate
     */
    'name'?: string;
    /**
     * Number of machines in the pool
     * @type {number}
     * @memberof VsphereMachinePoolUpdate
     */
    'quantity'?: number;
    /**
     * Taints to assign to machines in this pool
     * @type {Array<MachineTaint>}
     * @memberof VsphereMachinePoolUpdate
     */
    'taints'?: Array<MachineTaint>;
    /**
     * Time (in secs) before a machine is considered unhealthy if it cannot be reached
     * @type {number}
     * @memberof VsphereMachinePoolUpdate
     */
    'unhealthyNodeTimeout'?: number;
    /**
     * Operating system of machines in this pool
     * @type {string}
     * @memberof VsphereMachinePoolUpdate
     */
    'machineOS'?: VsphereMachinePoolUpdateMachineOSEnum;
    /**
     * 
     * @type {VsphereMachineConfigUpdate}
     * @memberof VsphereMachinePoolUpdate
     */
    'machineConfig'?: VsphereMachineConfigUpdate;
}

export const VsphereMachinePoolUpdateMachineOSEnum = {
    Linux: 'linux',
    Windows: 'windows'
} as const;

export type VsphereMachinePoolUpdateMachineOSEnum = typeof VsphereMachinePoolUpdateMachineOSEnum[keyof typeof VsphereMachinePoolUpdateMachineOSEnum];


/**
 * AssetsCPEApi - axios parameter creator
 * @export
 */
export const AssetsCPEApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a CPE
         * @param {CpeCreate} [cpeCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cpeCreate: async (cpeCreate?: CpeCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/assets/cpe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cpeCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a CPE
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cpeDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('cpeDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/assets/cpe/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * CPE match fields used for filtering must conform to the CPE (2.3) Name Matching Specification
         * @summary List of existing CPEs
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [lang] CPE Match Field
         * @param {string} [other] CPE Match Field
         * @param {CpeListPartEnum} [part] CPE Match Field
         * @param {string} [product] CPE Match Field
         * @param {string} [softwareEdition] CPE Match Field
         * @param {string} [targetHardware] CPE Match Field
         * @param {string} [targetSoftware] CPE Match Field
         * @param {string} [update] CPE Match Field
         * @param {string} [vendor] CPE Match Field
         * @param {string} [version] CPE Match Field
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {CpeListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {CpeListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cpeList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, lang?: string, other?: string, part?: CpeListPartEnum, product?: string, softwareEdition?: string, targetHardware?: string, targetSoftware?: string, update?: string, vendor?: string, version?: string, offset?: number, limit?: number, search?: string, sortBy?: CpeListSortByEnum, sort?: CpeListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/assets/cpe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }

            if (other !== undefined) {
                localVarQueryParameter['other'] = other;
            }

            if (part !== undefined) {
                localVarQueryParameter['part'] = part;
            }

            if (product !== undefined) {
                localVarQueryParameter['product'] = product;
            }

            if (softwareEdition !== undefined) {
                localVarQueryParameter['softwareEdition'] = softwareEdition;
            }

            if (targetHardware !== undefined) {
                localVarQueryParameter['targetHardware'] = targetHardware;
            }

            if (targetSoftware !== undefined) {
                localVarQueryParameter['targetSoftware'] = targetSoftware;
            }

            if (update !== undefined) {
                localVarQueryParameter['update'] = update;
            }

            if (vendor !== undefined) {
                localVarQueryParameter['vendor'] = vendor;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a CPE
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cpeRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('cpeRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/assets/cpe/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a CPE
         * @param {string} uuid 
         * @param {CpeUpdate} [cpeUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cpeUpdate: async (uuid: string, cpeUpdate?: CpeUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('cpeUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/assets/cpe/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cpeUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetsCPEApi - functional programming interface
 * @export
 */
export const AssetsCPEApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssetsCPEApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a CPE
         * @param {CpeCreate} [cpeCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cpeCreate(cpeCreate?: CpeCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CPE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cpeCreate(cpeCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsCPEApi.cpeCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a CPE
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cpeDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cpeDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsCPEApi.cpeDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * CPE match fields used for filtering must conform to the CPE (2.3) Name Matching Specification
         * @summary List of existing CPEs
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [lang] CPE Match Field
         * @param {string} [other] CPE Match Field
         * @param {CpeListPartEnum} [part] CPE Match Field
         * @param {string} [product] CPE Match Field
         * @param {string} [softwareEdition] CPE Match Field
         * @param {string} [targetHardware] CPE Match Field
         * @param {string} [targetSoftware] CPE Match Field
         * @param {string} [update] CPE Match Field
         * @param {string} [vendor] CPE Match Field
         * @param {string} [version] CPE Match Field
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {CpeListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {CpeListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cpeList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, lang?: string, other?: string, part?: CpeListPartEnum, product?: string, softwareEdition?: string, targetHardware?: string, targetSoftware?: string, update?: string, vendor?: string, version?: string, offset?: number, limit?: number, search?: string, sortBy?: CpeListSortByEnum, sort?: CpeListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CpeList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cpeList(uuid, name, description, author, metadata, lang, other, part, product, softwareEdition, targetHardware, targetSoftware, update, vendor, version, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsCPEApi.cpeList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a CPE
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cpeRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CPE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cpeRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsCPEApi.cpeRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a CPE
         * @param {string} uuid 
         * @param {CpeUpdate} [cpeUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cpeUpdate(uuid: string, cpeUpdate?: CpeUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CPE>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cpeUpdate(uuid, cpeUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsCPEApi.cpeUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AssetsCPEApi - factory interface
 * @export
 */
export const AssetsCPEApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssetsCPEApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a CPE
         * @param {CpeCreate} [cpeCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cpeCreate(cpeCreate?: CpeCreate, options?: RawAxiosRequestConfig): AxiosPromise<CPE> {
            return localVarFp.cpeCreate(cpeCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a CPE
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cpeDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cpeDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * CPE match fields used for filtering must conform to the CPE (2.3) Name Matching Specification
         * @summary List of existing CPEs
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [lang] CPE Match Field
         * @param {string} [other] CPE Match Field
         * @param {CpeListPartEnum} [part] CPE Match Field
         * @param {string} [product] CPE Match Field
         * @param {string} [softwareEdition] CPE Match Field
         * @param {string} [targetHardware] CPE Match Field
         * @param {string} [targetSoftware] CPE Match Field
         * @param {string} [update] CPE Match Field
         * @param {string} [vendor] CPE Match Field
         * @param {string} [version] CPE Match Field
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {CpeListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {CpeListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cpeList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, lang?: string, other?: string, part?: CpeListPartEnum, product?: string, softwareEdition?: string, targetHardware?: string, targetSoftware?: string, update?: string, vendor?: string, version?: string, offset?: number, limit?: number, search?: string, sortBy?: CpeListSortByEnum, sort?: CpeListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<CpeList200Response> {
            return localVarFp.cpeList(uuid, name, description, author, metadata, lang, other, part, product, softwareEdition, targetHardware, targetSoftware, update, vendor, version, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a CPE
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cpeRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<CPE> {
            return localVarFp.cpeRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a CPE
         * @param {string} uuid 
         * @param {CpeUpdate} [cpeUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cpeUpdate(uuid: string, cpeUpdate?: CpeUpdate, options?: RawAxiosRequestConfig): AxiosPromise<CPE> {
            return localVarFp.cpeUpdate(uuid, cpeUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AssetsCPEApi - object-oriented interface
 * @export
 * @class AssetsCPEApi
 * @extends {BaseAPI}
 */
export class AssetsCPEApi extends BaseAPI {
    /**
     * 
     * @summary Create a CPE
     * @param {CpeCreate} [cpeCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsCPEApi
     */
    public cpeCreate(cpeCreate?: CpeCreate, options?: RawAxiosRequestConfig) {
        return AssetsCPEApiFp(this.configuration).cpeCreate(cpeCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a CPE
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsCPEApi
     */
    public cpeDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return AssetsCPEApiFp(this.configuration).cpeDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * CPE match fields used for filtering must conform to the CPE (2.3) Name Matching Specification
     * @summary List of existing CPEs
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {string} [lang] CPE Match Field
     * @param {string} [other] CPE Match Field
     * @param {CpeListPartEnum} [part] CPE Match Field
     * @param {string} [product] CPE Match Field
     * @param {string} [softwareEdition] CPE Match Field
     * @param {string} [targetHardware] CPE Match Field
     * @param {string} [targetSoftware] CPE Match Field
     * @param {string} [update] CPE Match Field
     * @param {string} [vendor] CPE Match Field
     * @param {string} [version] CPE Match Field
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {CpeListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {CpeListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsCPEApi
     */
    public cpeList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, lang?: string, other?: string, part?: CpeListPartEnum, product?: string, softwareEdition?: string, targetHardware?: string, targetSoftware?: string, update?: string, vendor?: string, version?: string, offset?: number, limit?: number, search?: string, sortBy?: CpeListSortByEnum, sort?: CpeListSortEnum, options?: RawAxiosRequestConfig) {
        return AssetsCPEApiFp(this.configuration).cpeList(uuid, name, description, author, metadata, lang, other, part, product, softwareEdition, targetHardware, targetSoftware, update, vendor, version, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a CPE
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsCPEApi
     */
    public cpeRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return AssetsCPEApiFp(this.configuration).cpeRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a CPE
     * @param {string} uuid 
     * @param {CpeUpdate} [cpeUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsCPEApi
     */
    public cpeUpdate(uuid: string, cpeUpdate?: CpeUpdate, options?: RawAxiosRequestConfig) {
        return AssetsCPEApiFp(this.configuration).cpeUpdate(uuid, cpeUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const CpeListPartEnum = {
    A: 'a',
    O: 'o',
    H: 'h',
    Star: '*',
    Minus: '-'
} as const;
export type CpeListPartEnum = typeof CpeListPartEnum[keyof typeof CpeListPartEnum];
/**
 * @export
 */
export const CpeListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author'
} as const;
export type CpeListSortByEnum = typeof CpeListSortByEnum[keyof typeof CpeListSortByEnum];
/**
 * @export
 */
export const CpeListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type CpeListSortEnum = typeof CpeListSortEnum[keyof typeof CpeListSortEnum];


/**
 * AssetsChartsApi - axios parameter creator
 * @export
 */
export const AssetsChartsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes a chart version
         * @param {string} name 
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chartVersionsDelete: async (name: string, version: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('chartVersionsDelete', 'name', name)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('chartVersionsDelete', 'version', version)
            const localVarPath = `/v1/content/assets/charts/{name}/versions/{version}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download a chart version
         * @param {string} name 
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chartVersionsDownload: async (name: string, version: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('chartVersionsDownload', 'name', name)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('chartVersionsDownload', 'version', version)
            const localVarPath = `/v1/content/assets/charts/{name}/versions/{version}/download`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List chart versions
         * @param {string} name 
         * @param {string} [uuid] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {string} [appVersion] 
         * @param {string} [digest] 
         * @param {string} [version] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {ChartVersionsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {ChartVersionsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chartVersionsList: async (name: string, uuid?: string, description?: string, author?: string, appVersion?: string, digest?: string, version?: string, offset?: number, limit?: number, search?: string, sortBy?: ChartVersionsListSortByEnum, sort?: ChartVersionsListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('chartVersionsList', 'name', name)
            const localVarPath = `/v1/content/assets/charts/{name}/versions`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (appVersion !== undefined) {
                localVarQueryParameter['appVersion'] = appVersion;
            }

            if (digest !== undefined) {
                localVarQueryParameter['digest'] = digest;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a chart version
         * @param {string} name 
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chartVersionsRetrieve: async (name: string, version: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('chartVersionsRetrieve', 'name', name)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('chartVersionsRetrieve', 'version', version)
            const localVarPath = `/v1/content/assets/charts/{name}/versions/{version}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a JSON schema for chart values
         * @param {string} name 
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chartVersionsRetrieveSchema: async (name: string, version: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('chartVersionsRetrieveSchema', 'name', name)
            // verify required parameter 'version' is not null or undefined
            assertParamExists('chartVersionsRetrieveSchema', 'version', version)
            const localVarPath = `/v1/content/assets/charts/{name}/versions/{version}/schema`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a chart
         * @param {string} cpe Common Platform Enumeration - post provisioning actions
         * @param {File} file The file to upload
         * @param {ChartsCreateIconTypeEnum} iconType Changes the icon displayed in the UI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chartsCreate: async (cpe: string, file: File, iconType: ChartsCreateIconTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cpe' is not null or undefined
            assertParamExists('chartsCreate', 'cpe', cpe)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('chartsCreate', 'file', file)
            // verify required parameter 'iconType' is not null or undefined
            assertParamExists('chartsCreate', 'iconType', iconType)
            const localVarPath = `/v1/content/assets/charts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            if (cpe !== undefined) { 
                localVarFormParams.append('cpe', cpe as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (iconType !== undefined) { 
                localVarFormParams.append('iconType', iconType as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a chart
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chartsDelete: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('chartsDelete', 'name', name)
            const localVarPath = `/v1/content/assets/charts/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * CPE match fields used for filtering must conform to the CPE (2.3) Name Matching Specification
         * @summary List of existing charts
         * @param {string} [name] 
         * @param {string} [lang] CPE Match Field
         * @param {string} [other] CPE Match Field
         * @param {ChartsListPartEnum} [part] CPE Match Field
         * @param {string} [product] CPE Match Field
         * @param {string} [softwareEdition] CPE Match Field
         * @param {string} [targetHardware] CPE Match Field
         * @param {string} [targetSoftware] CPE Match Field
         * @param {string} [update] CPE Match Field
         * @param {string} [vendor] CPE Match Field
         * @param {string} [version] CPE Match Field
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {ChartsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {ChartsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chartsList: async (name?: string, lang?: string, other?: string, part?: ChartsListPartEnum, product?: string, softwareEdition?: string, targetHardware?: string, targetSoftware?: string, update?: string, vendor?: string, version?: string, offset?: number, limit?: number, search?: string, sortBy?: ChartsListSortByEnum, sort?: ChartsListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/assets/charts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }

            if (other !== undefined) {
                localVarQueryParameter['other'] = other;
            }

            if (part !== undefined) {
                localVarQueryParameter['part'] = part;
            }

            if (product !== undefined) {
                localVarQueryParameter['product'] = product;
            }

            if (softwareEdition !== undefined) {
                localVarQueryParameter['softwareEdition'] = softwareEdition;
            }

            if (targetHardware !== undefined) {
                localVarQueryParameter['targetHardware'] = targetHardware;
            }

            if (targetSoftware !== undefined) {
                localVarQueryParameter['targetSoftware'] = targetSoftware;
            }

            if (update !== undefined) {
                localVarQueryParameter['update'] = update;
            }

            if (vendor !== undefined) {
                localVarQueryParameter['vendor'] = vendor;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a chart
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chartsRetrieve: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('chartsRetrieve', 'name', name)
            const localVarPath = `/v1/content/assets/charts/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetsChartsApi - functional programming interface
 * @export
 */
export const AssetsChartsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssetsChartsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deletes a chart version
         * @param {string} name 
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chartVersionsDelete(name: string, version: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chartVersionsDelete(name, version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsChartsApi.chartVersionsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download a chart version
         * @param {string} name 
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chartVersionsDownload(name: string, version: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chartVersionsDownload(name, version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsChartsApi.chartVersionsDownload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List chart versions
         * @param {string} name 
         * @param {string} [uuid] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {string} [appVersion] 
         * @param {string} [digest] 
         * @param {string} [version] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {ChartVersionsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {ChartVersionsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chartVersionsList(name: string, uuid?: string, description?: string, author?: string, appVersion?: string, digest?: string, version?: string, offset?: number, limit?: number, search?: string, sortBy?: ChartVersionsListSortByEnum, sort?: ChartVersionsListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChartVersionsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chartVersionsList(name, uuid, description, author, appVersion, digest, version, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsChartsApi.chartVersionsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a chart version
         * @param {string} name 
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chartVersionsRetrieve(name: string, version: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChartVersion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chartVersionsRetrieve(name, version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsChartsApi.chartVersionsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a JSON schema for chart values
         * @param {string} name 
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chartVersionsRetrieveSchema(name: string, version: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chartVersionsRetrieveSchema(name, version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsChartsApi.chartVersionsRetrieveSchema']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a chart
         * @param {string} cpe Common Platform Enumeration - post provisioning actions
         * @param {File} file The file to upload
         * @param {ChartsCreateIconTypeEnum} iconType Changes the icon displayed in the UI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chartsCreate(cpe: string, file: File, iconType: ChartsCreateIconTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Chart>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chartsCreate(cpe, file, iconType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsChartsApi.chartsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a chart
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chartsDelete(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chartsDelete(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsChartsApi.chartsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * CPE match fields used for filtering must conform to the CPE (2.3) Name Matching Specification
         * @summary List of existing charts
         * @param {string} [name] 
         * @param {string} [lang] CPE Match Field
         * @param {string} [other] CPE Match Field
         * @param {ChartsListPartEnum} [part] CPE Match Field
         * @param {string} [product] CPE Match Field
         * @param {string} [softwareEdition] CPE Match Field
         * @param {string} [targetHardware] CPE Match Field
         * @param {string} [targetSoftware] CPE Match Field
         * @param {string} [update] CPE Match Field
         * @param {string} [vendor] CPE Match Field
         * @param {string} [version] CPE Match Field
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {ChartsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {ChartsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chartsList(name?: string, lang?: string, other?: string, part?: ChartsListPartEnum, product?: string, softwareEdition?: string, targetHardware?: string, targetSoftware?: string, update?: string, vendor?: string, version?: string, offset?: number, limit?: number, search?: string, sortBy?: ChartsListSortByEnum, sort?: ChartsListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChartsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chartsList(name, lang, other, part, product, softwareEdition, targetHardware, targetSoftware, update, vendor, version, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsChartsApi.chartsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a chart
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chartsRetrieve(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Chart>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chartsRetrieve(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsChartsApi.chartsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AssetsChartsApi - factory interface
 * @export
 */
export const AssetsChartsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssetsChartsApiFp(configuration)
    return {
        /**
         * 
         * @summary Deletes a chart version
         * @param {string} name 
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chartVersionsDelete(name: string, version: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.chartVersionsDelete(name, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download a chart version
         * @param {string} name 
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chartVersionsDownload(name: string, version: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.chartVersionsDownload(name, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List chart versions
         * @param {string} name 
         * @param {string} [uuid] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {string} [appVersion] 
         * @param {string} [digest] 
         * @param {string} [version] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {ChartVersionsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {ChartVersionsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chartVersionsList(name: string, uuid?: string, description?: string, author?: string, appVersion?: string, digest?: string, version?: string, offset?: number, limit?: number, search?: string, sortBy?: ChartVersionsListSortByEnum, sort?: ChartVersionsListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<ChartVersionsList200Response> {
            return localVarFp.chartVersionsList(name, uuid, description, author, appVersion, digest, version, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a chart version
         * @param {string} name 
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chartVersionsRetrieve(name: string, version: string, options?: RawAxiosRequestConfig): AxiosPromise<ChartVersion> {
            return localVarFp.chartVersionsRetrieve(name, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a JSON schema for chart values
         * @param {string} name 
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chartVersionsRetrieveSchema(name: string, version: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.chartVersionsRetrieveSchema(name, version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a chart
         * @param {string} cpe Common Platform Enumeration - post provisioning actions
         * @param {File} file The file to upload
         * @param {ChartsCreateIconTypeEnum} iconType Changes the icon displayed in the UI
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chartsCreate(cpe: string, file: File, iconType: ChartsCreateIconTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<Chart> {
            return localVarFp.chartsCreate(cpe, file, iconType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a chart
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chartsDelete(name: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.chartsDelete(name, options).then((request) => request(axios, basePath));
        },
        /**
         * CPE match fields used for filtering must conform to the CPE (2.3) Name Matching Specification
         * @summary List of existing charts
         * @param {string} [name] 
         * @param {string} [lang] CPE Match Field
         * @param {string} [other] CPE Match Field
         * @param {ChartsListPartEnum} [part] CPE Match Field
         * @param {string} [product] CPE Match Field
         * @param {string} [softwareEdition] CPE Match Field
         * @param {string} [targetHardware] CPE Match Field
         * @param {string} [targetSoftware] CPE Match Field
         * @param {string} [update] CPE Match Field
         * @param {string} [vendor] CPE Match Field
         * @param {string} [version] CPE Match Field
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {ChartsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {ChartsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chartsList(name?: string, lang?: string, other?: string, part?: ChartsListPartEnum, product?: string, softwareEdition?: string, targetHardware?: string, targetSoftware?: string, update?: string, vendor?: string, version?: string, offset?: number, limit?: number, search?: string, sortBy?: ChartsListSortByEnum, sort?: ChartsListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<ChartsList200Response> {
            return localVarFp.chartsList(name, lang, other, part, product, softwareEdition, targetHardware, targetSoftware, update, vendor, version, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a chart
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chartsRetrieve(name: string, options?: RawAxiosRequestConfig): AxiosPromise<Chart> {
            return localVarFp.chartsRetrieve(name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AssetsChartsApi - object-oriented interface
 * @export
 * @class AssetsChartsApi
 * @extends {BaseAPI}
 */
export class AssetsChartsApi extends BaseAPI {
    /**
     * 
     * @summary Deletes a chart version
     * @param {string} name 
     * @param {string} version 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsChartsApi
     */
    public chartVersionsDelete(name: string, version: string, options?: RawAxiosRequestConfig) {
        return AssetsChartsApiFp(this.configuration).chartVersionsDelete(name, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download a chart version
     * @param {string} name 
     * @param {string} version 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsChartsApi
     */
    public chartVersionsDownload(name: string, version: string, options?: RawAxiosRequestConfig) {
        return AssetsChartsApiFp(this.configuration).chartVersionsDownload(name, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List chart versions
     * @param {string} name 
     * @param {string} [uuid] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {string} [appVersion] 
     * @param {string} [digest] 
     * @param {string} [version] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {ChartVersionsListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {ChartVersionsListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsChartsApi
     */
    public chartVersionsList(name: string, uuid?: string, description?: string, author?: string, appVersion?: string, digest?: string, version?: string, offset?: number, limit?: number, search?: string, sortBy?: ChartVersionsListSortByEnum, sort?: ChartVersionsListSortEnum, options?: RawAxiosRequestConfig) {
        return AssetsChartsApiFp(this.configuration).chartVersionsList(name, uuid, description, author, appVersion, digest, version, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a chart version
     * @param {string} name 
     * @param {string} version 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsChartsApi
     */
    public chartVersionsRetrieve(name: string, version: string, options?: RawAxiosRequestConfig) {
        return AssetsChartsApiFp(this.configuration).chartVersionsRetrieve(name, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a JSON schema for chart values
     * @param {string} name 
     * @param {string} version 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsChartsApi
     */
    public chartVersionsRetrieveSchema(name: string, version: string, options?: RawAxiosRequestConfig) {
        return AssetsChartsApiFp(this.configuration).chartVersionsRetrieveSchema(name, version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a chart
     * @param {string} cpe Common Platform Enumeration - post provisioning actions
     * @param {File} file The file to upload
     * @param {ChartsCreateIconTypeEnum} iconType Changes the icon displayed in the UI
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsChartsApi
     */
    public chartsCreate(cpe: string, file: File, iconType: ChartsCreateIconTypeEnum, options?: RawAxiosRequestConfig) {
        return AssetsChartsApiFp(this.configuration).chartsCreate(cpe, file, iconType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a chart
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsChartsApi
     */
    public chartsDelete(name: string, options?: RawAxiosRequestConfig) {
        return AssetsChartsApiFp(this.configuration).chartsDelete(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * CPE match fields used for filtering must conform to the CPE (2.3) Name Matching Specification
     * @summary List of existing charts
     * @param {string} [name] 
     * @param {string} [lang] CPE Match Field
     * @param {string} [other] CPE Match Field
     * @param {ChartsListPartEnum} [part] CPE Match Field
     * @param {string} [product] CPE Match Field
     * @param {string} [softwareEdition] CPE Match Field
     * @param {string} [targetHardware] CPE Match Field
     * @param {string} [targetSoftware] CPE Match Field
     * @param {string} [update] CPE Match Field
     * @param {string} [vendor] CPE Match Field
     * @param {string} [version] CPE Match Field
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {ChartsListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {ChartsListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsChartsApi
     */
    public chartsList(name?: string, lang?: string, other?: string, part?: ChartsListPartEnum, product?: string, softwareEdition?: string, targetHardware?: string, targetSoftware?: string, update?: string, vendor?: string, version?: string, offset?: number, limit?: number, search?: string, sortBy?: ChartsListSortByEnum, sort?: ChartsListSortEnum, options?: RawAxiosRequestConfig) {
        return AssetsChartsApiFp(this.configuration).chartsList(name, lang, other, part, product, softwareEdition, targetHardware, targetSoftware, update, vendor, version, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a chart
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsChartsApi
     */
    public chartsRetrieve(name: string, options?: RawAxiosRequestConfig) {
        return AssetsChartsApiFp(this.configuration).chartsRetrieve(name, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ChartVersionsListSortByEnum = {
    Author: 'author',
    Description: 'description',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Name: 'name',
    AppVersion: 'appVersion',
    Digest: 'digest',
    Version: 'version'
} as const;
export type ChartVersionsListSortByEnum = typeof ChartVersionsListSortByEnum[keyof typeof ChartVersionsListSortByEnum];
/**
 * @export
 */
export const ChartVersionsListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ChartVersionsListSortEnum = typeof ChartVersionsListSortEnum[keyof typeof ChartVersionsListSortEnum];
/**
 * @export
 */
export const ChartsCreateIconTypeEnum = {
    FileServer: 'FileServer',
    Firewall: 'Firewall',
    Internet: 'Internet',
    Laptop: 'Laptop',
    MailServer: 'MailServer',
    Mobile: 'Mobile',
    Plc: 'PLC',
    Printer: 'Printer',
    Router: 'Router',
    Server: 'Server',
    Switch: 'Switch',
    WebProxy: 'WebProxy',
    WebServer: 'WebServer',
    WirelessAccessPoint: 'WirelessAccessPoint',
    Workstation: 'Workstation'
} as const;
export type ChartsCreateIconTypeEnum = typeof ChartsCreateIconTypeEnum[keyof typeof ChartsCreateIconTypeEnum];
/**
 * @export
 */
export const ChartsListPartEnum = {
    A: 'a',
    O: 'o',
    H: 'h',
    Star: '*',
    Minus: '-'
} as const;
export type ChartsListPartEnum = typeof ChartsListPartEnum[keyof typeof ChartsListPartEnum];
/**
 * @export
 */
export const ChartsListSortByEnum = {
    Name: 'name',
    CpeLang: 'cpe.lang',
    CpeOther: 'cpe.other',
    CpePart: 'cpe.part',
    CpeProduct: 'cpe.product',
    CpeSoftwareEdition: 'cpe.softwareEdition',
    CpeTargetHardware: 'cpe.targetHardware',
    CpeTargetSoftware: 'cpe.targetSoftware',
    CpeUpdate: 'cpe.update',
    CpeVendor: 'cpe.vendor',
    CpeVersion: 'cpe.version'
} as const;
export type ChartsListSortByEnum = typeof ChartsListSortByEnum[keyof typeof ChartsListSortByEnum];
/**
 * @export
 */
export const ChartsListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ChartsListSortEnum = typeof ChartsListSortEnum[keyof typeof ChartsListSortEnum];


/**
 * AssetsContainersApi - axios parameter creator
 * @export
 */
export const AssetsContainersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a container tag
         * @param {string} name 
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerTagsDelete: async (name: string, tag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('containerTagsDelete', 'name', name)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('containerTagsDelete', 'tag', tag)
            const localVarPath = `/v1/content/assets/containers/{name}/tags/{tag}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Downloads a container by tag
         * @param {string} name 
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerTagsDownload: async (name: string, tag: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('containerTagsDownload', 'name', name)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('containerTagsDownload', 'tag', tag)
            const localVarPath = `/v1/content/assets/containers/{name}/tags/{tag}/download`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)))
                .replace(`{${"tag"}}`, encodeURIComponent(String(tag)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List container tags
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerTagsList: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('containerTagsList', 'name', name)
            const localVarPath = `/v1/content/assets/containers/{name}/tags`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a container asset
         * @param {File} file The file to upload
         * @param {string} tag Sets the tag of the container within the system
         * @param {string} [name] Sets the name of the container within the system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containersCreate: async (file: File, tag: string, name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('containersCreate', 'file', file)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('containersCreate', 'tag', tag)
            const localVarPath = `/v1/content/assets/containers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (tag !== undefined) { 
                localVarFormParams.append('tag', tag as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This is a convenience method that deletes every tag for a container.
         * @summary Delete a container asset
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containersDelete: async (name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('containersDelete', 'name', name)
            const localVarPath = `/v1/content/assets/containers/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of existing container assets
         * @param {string} [name] 
         * @param {string} [tag] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {ContainersListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {ContainersListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containersList: async (name?: string, tag?: string, offset?: number, limit?: number, search?: string, sortBy?: ContainersListSortByEnum, sort?: ContainersListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/assets/containers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetsContainersApi - functional programming interface
 * @export
 */
export const AssetsContainersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssetsContainersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a container tag
         * @param {string} name 
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerTagsDelete(name: string, tag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containerTagsDelete(name, tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsContainersApi.containerTagsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Downloads a container by tag
         * @param {string} name 
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerTagsDownload(name: string, tag: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containerTagsDownload(name, tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsContainersApi.containerTagsDownload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List container tags
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerTagsList(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containerTagsList(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsContainersApi.containerTagsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a container asset
         * @param {File} file The file to upload
         * @param {string} tag Sets the tag of the container within the system
         * @param {string} [name] Sets the name of the container within the system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containersCreate(file: File, tag: string, name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containersCreate(file, tag, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsContainersApi.containersCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This is a convenience method that deletes every tag for a container.
         * @summary Delete a container asset
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containersDelete(name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containersDelete(name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsContainersApi.containersDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List of existing container assets
         * @param {string} [name] 
         * @param {string} [tag] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {ContainersListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {ContainersListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containersList(name?: string, tag?: string, offset?: number, limit?: number, search?: string, sortBy?: ContainersListSortByEnum, sort?: ContainersListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainersList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containersList(name, tag, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsContainersApi.containersList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AssetsContainersApi - factory interface
 * @export
 */
export const AssetsContainersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssetsContainersApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a container tag
         * @param {string} name 
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerTagsDelete(name: string, tag: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.containerTagsDelete(name, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Downloads a container by tag
         * @param {string} name 
         * @param {string} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerTagsDownload(name: string, tag: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.containerTagsDownload(name, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List container tags
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerTagsList(name: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.containerTagsList(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a container asset
         * @param {File} file The file to upload
         * @param {string} tag Sets the tag of the container within the system
         * @param {string} [name] Sets the name of the container within the system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containersCreate(file: File, tag: string, name?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.containersCreate(file, tag, name, options).then((request) => request(axios, basePath));
        },
        /**
         * This is a convenience method that deletes every tag for a container.
         * @summary Delete a container asset
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containersDelete(name: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.containersDelete(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List of existing container assets
         * @param {string} [name] 
         * @param {string} [tag] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {ContainersListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {ContainersListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containersList(name?: string, tag?: string, offset?: number, limit?: number, search?: string, sortBy?: ContainersListSortByEnum, sort?: ContainersListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<ContainersList200Response> {
            return localVarFp.containersList(name, tag, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AssetsContainersApi - object-oriented interface
 * @export
 * @class AssetsContainersApi
 * @extends {BaseAPI}
 */
export class AssetsContainersApi extends BaseAPI {
    /**
     * 
     * @summary Delete a container tag
     * @param {string} name 
     * @param {string} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsContainersApi
     */
    public containerTagsDelete(name: string, tag: string, options?: RawAxiosRequestConfig) {
        return AssetsContainersApiFp(this.configuration).containerTagsDelete(name, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Downloads a container by tag
     * @param {string} name 
     * @param {string} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsContainersApi
     */
    public containerTagsDownload(name: string, tag: string, options?: RawAxiosRequestConfig) {
        return AssetsContainersApiFp(this.configuration).containerTagsDownload(name, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List container tags
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsContainersApi
     */
    public containerTagsList(name: string, options?: RawAxiosRequestConfig) {
        return AssetsContainersApiFp(this.configuration).containerTagsList(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a container asset
     * @param {File} file The file to upload
     * @param {string} tag Sets the tag of the container within the system
     * @param {string} [name] Sets the name of the container within the system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsContainersApi
     */
    public containersCreate(file: File, tag: string, name?: string, options?: RawAxiosRequestConfig) {
        return AssetsContainersApiFp(this.configuration).containersCreate(file, tag, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This is a convenience method that deletes every tag for a container.
     * @summary Delete a container asset
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsContainersApi
     */
    public containersDelete(name: string, options?: RawAxiosRequestConfig) {
        return AssetsContainersApiFp(this.configuration).containersDelete(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List of existing container assets
     * @param {string} [name] 
     * @param {string} [tag] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {ContainersListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {ContainersListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsContainersApi
     */
    public containersList(name?: string, tag?: string, offset?: number, limit?: number, search?: string, sortBy?: ContainersListSortByEnum, sort?: ContainersListSortEnum, options?: RawAxiosRequestConfig) {
        return AssetsContainersApiFp(this.configuration).containersList(name, tag, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ContainersListSortByEnum = {
    Name: 'name'
} as const;
export type ContainersListSortByEnum = typeof ContainersListSortByEnum[keyof typeof ContainersListSortByEnum];
/**
 * @export
 */
export const ContainersListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ContainersListSortEnum = typeof ContainersListSortEnum[keyof typeof ContainersListSortEnum];


/**
 * AssetsVMImagesApi - axios parameter creator
 * @export
 */
export const AssetsVMImagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a VM image
         * @param {string} name A user provided human readable name.
         * @param {File} file The file to upload
         * @param {string} [description] A user provided human readable description.
         * @param {object} [metadata] User provided metadata
         * @param {BootDetailsCreate} [bootDetails] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmImagesCreate: async (name: string, file: File, description?: string, metadata?: object, bootDetails?: BootDetailsCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('vmImagesCreate', 'name', name)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('vmImagesCreate', 'file', file)
            const localVarPath = `/v1/content/assets/virtual-machine/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (metadata !== undefined) { 
                localVarFormParams.append('metadata', new Blob([JSON.stringify(metadata)], { type: "application/json", }));
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (bootDetails !== undefined) { 
                localVarFormParams.append('bootDetails', JSON.stringify(bootDetails));
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a VM image
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmImagesDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('vmImagesDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/assets/virtual-machine/images/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download a VM image
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmImagesDownload: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('vmImagesDownload', 'uuid', uuid)
            const localVarPath = `/v1/content/assets/virtual-machine/images/{uuid}/download`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * CPE match fields used for filtering must conform to the CPE (2.3) Name Matching Specification
         * @summary List of existing VM images
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {VmImagesListIconTypeEnum} [iconType] Icon Type used for the VM Image
         * @param {boolean} [publicUrl] 
         * @param {string} [lang] CPE Match Field
         * @param {string} [other] CPE Match Field
         * @param {VmImagesListPartEnum} [part] CPE Match Field
         * @param {string} [product] CPE Match Field
         * @param {string} [softwareEdition] CPE Match Field
         * @param {string} [targetHardware] CPE Match Field
         * @param {string} [targetSoftware] CPE Match Field
         * @param {string} [update] CPE Match Field
         * @param {string} [vendor] CPE Match Field
         * @param {string} [version] CPE Match Field
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {VmImagesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {VmImagesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmImagesList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, iconType?: VmImagesListIconTypeEnum, publicUrl?: boolean, lang?: string, other?: string, part?: VmImagesListPartEnum, product?: string, softwareEdition?: string, targetHardware?: string, targetSoftware?: string, update?: string, vendor?: string, version?: string, offset?: number, limit?: number, search?: string, sortBy?: VmImagesListSortByEnum, sort?: VmImagesListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/assets/virtual-machine/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (iconType !== undefined) {
                localVarQueryParameter['iconType'] = iconType;
            }

            if (publicUrl !== undefined) {
                localVarQueryParameter['publicUrl'] = publicUrl;
            }

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }

            if (other !== undefined) {
                localVarQueryParameter['other'] = other;
            }

            if (part !== undefined) {
                localVarQueryParameter['part'] = part;
            }

            if (product !== undefined) {
                localVarQueryParameter['product'] = product;
            }

            if (softwareEdition !== undefined) {
                localVarQueryParameter['softwareEdition'] = softwareEdition;
            }

            if (targetHardware !== undefined) {
                localVarQueryParameter['targetHardware'] = targetHardware;
            }

            if (targetSoftware !== undefined) {
                localVarQueryParameter['targetSoftware'] = targetSoftware;
            }

            if (update !== undefined) {
                localVarQueryParameter['update'] = update;
            }

            if (vendor !== undefined) {
                localVarQueryParameter['vendor'] = vendor;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a VM image
         * @param {string} uuid 
         * @param {boolean} [publicUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmImagesRetrieve: async (uuid: string, publicUrl?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('vmImagesRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/assets/virtual-machine/images/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (publicUrl !== undefined) {
                localVarQueryParameter['publicUrl'] = publicUrl;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a VM image
         * @param {string} uuid 
         * @param {VmImageUpdate} [vmImageUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmImagesUpdate: async (uuid: string, vmImageUpdate?: VmImageUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('vmImagesUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/assets/virtual-machine/images/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vmImageUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetsVMImagesApi - functional programming interface
 * @export
 */
export const AssetsVMImagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssetsVMImagesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a VM image
         * @param {string} name A user provided human readable name.
         * @param {File} file The file to upload
         * @param {string} [description] A user provided human readable description.
         * @param {object} [metadata] User provided metadata
         * @param {BootDetailsCreate} [bootDetails] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vmImagesCreate(name: string, file: File, description?: string, metadata?: object, bootDetails?: BootDetailsCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VMImage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vmImagesCreate(name, file, description, metadata, bootDetails, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsVMImagesApi.vmImagesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a VM image
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vmImagesDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vmImagesDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsVMImagesApi.vmImagesDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download a VM image
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vmImagesDownload(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vmImagesDownload(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsVMImagesApi.vmImagesDownload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * CPE match fields used for filtering must conform to the CPE (2.3) Name Matching Specification
         * @summary List of existing VM images
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {VmImagesListIconTypeEnum} [iconType] Icon Type used for the VM Image
         * @param {boolean} [publicUrl] 
         * @param {string} [lang] CPE Match Field
         * @param {string} [other] CPE Match Field
         * @param {VmImagesListPartEnum} [part] CPE Match Field
         * @param {string} [product] CPE Match Field
         * @param {string} [softwareEdition] CPE Match Field
         * @param {string} [targetHardware] CPE Match Field
         * @param {string} [targetSoftware] CPE Match Field
         * @param {string} [update] CPE Match Field
         * @param {string} [vendor] CPE Match Field
         * @param {string} [version] CPE Match Field
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {VmImagesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {VmImagesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vmImagesList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, iconType?: VmImagesListIconTypeEnum, publicUrl?: boolean, lang?: string, other?: string, part?: VmImagesListPartEnum, product?: string, softwareEdition?: string, targetHardware?: string, targetSoftware?: string, update?: string, vendor?: string, version?: string, offset?: number, limit?: number, search?: string, sortBy?: VmImagesListSortByEnum, sort?: VmImagesListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VmImagesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vmImagesList(uuid, name, description, author, metadata, iconType, publicUrl, lang, other, part, product, softwareEdition, targetHardware, targetSoftware, update, vendor, version, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsVMImagesApi.vmImagesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a VM image
         * @param {string} uuid 
         * @param {boolean} [publicUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vmImagesRetrieve(uuid: string, publicUrl?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VMImage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vmImagesRetrieve(uuid, publicUrl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsVMImagesApi.vmImagesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a VM image
         * @param {string} uuid 
         * @param {VmImageUpdate} [vmImageUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vmImagesUpdate(uuid: string, vmImageUpdate?: VmImageUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VMImage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vmImagesUpdate(uuid, vmImageUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsVMImagesApi.vmImagesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AssetsVMImagesApi - factory interface
 * @export
 */
export const AssetsVMImagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssetsVMImagesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a VM image
         * @param {string} name A user provided human readable name.
         * @param {File} file The file to upload
         * @param {string} [description] A user provided human readable description.
         * @param {object} [metadata] User provided metadata
         * @param {BootDetailsCreate} [bootDetails] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmImagesCreate(name: string, file: File, description?: string, metadata?: object, bootDetails?: BootDetailsCreate, options?: RawAxiosRequestConfig): AxiosPromise<VMImage> {
            return localVarFp.vmImagesCreate(name, file, description, metadata, bootDetails, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a VM image
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmImagesDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.vmImagesDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download a VM image
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmImagesDownload(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.vmImagesDownload(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * CPE match fields used for filtering must conform to the CPE (2.3) Name Matching Specification
         * @summary List of existing VM images
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {VmImagesListIconTypeEnum} [iconType] Icon Type used for the VM Image
         * @param {boolean} [publicUrl] 
         * @param {string} [lang] CPE Match Field
         * @param {string} [other] CPE Match Field
         * @param {VmImagesListPartEnum} [part] CPE Match Field
         * @param {string} [product] CPE Match Field
         * @param {string} [softwareEdition] CPE Match Field
         * @param {string} [targetHardware] CPE Match Field
         * @param {string} [targetSoftware] CPE Match Field
         * @param {string} [update] CPE Match Field
         * @param {string} [vendor] CPE Match Field
         * @param {string} [version] CPE Match Field
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {VmImagesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {VmImagesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmImagesList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, iconType?: VmImagesListIconTypeEnum, publicUrl?: boolean, lang?: string, other?: string, part?: VmImagesListPartEnum, product?: string, softwareEdition?: string, targetHardware?: string, targetSoftware?: string, update?: string, vendor?: string, version?: string, offset?: number, limit?: number, search?: string, sortBy?: VmImagesListSortByEnum, sort?: VmImagesListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<VmImagesList200Response> {
            return localVarFp.vmImagesList(uuid, name, description, author, metadata, iconType, publicUrl, lang, other, part, product, softwareEdition, targetHardware, targetSoftware, update, vendor, version, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a VM image
         * @param {string} uuid 
         * @param {boolean} [publicUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmImagesRetrieve(uuid: string, publicUrl?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<VMImage> {
            return localVarFp.vmImagesRetrieve(uuid, publicUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a VM image
         * @param {string} uuid 
         * @param {VmImageUpdate} [vmImageUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmImagesUpdate(uuid: string, vmImageUpdate?: VmImageUpdate, options?: RawAxiosRequestConfig): AxiosPromise<VMImage> {
            return localVarFp.vmImagesUpdate(uuid, vmImageUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AssetsVMImagesApi - object-oriented interface
 * @export
 * @class AssetsVMImagesApi
 * @extends {BaseAPI}
 */
export class AssetsVMImagesApi extends BaseAPI {
    /**
     * 
     * @summary Create a VM image
     * @param {string} name A user provided human readable name.
     * @param {File} file The file to upload
     * @param {string} [description] A user provided human readable description.
     * @param {object} [metadata] User provided metadata
     * @param {BootDetailsCreate} [bootDetails] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsVMImagesApi
     */
    public vmImagesCreate(name: string, file: File, description?: string, metadata?: object, bootDetails?: BootDetailsCreate, options?: RawAxiosRequestConfig) {
        return AssetsVMImagesApiFp(this.configuration).vmImagesCreate(name, file, description, metadata, bootDetails, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a VM image
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsVMImagesApi
     */
    public vmImagesDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return AssetsVMImagesApiFp(this.configuration).vmImagesDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download a VM image
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsVMImagesApi
     */
    public vmImagesDownload(uuid: string, options?: RawAxiosRequestConfig) {
        return AssetsVMImagesApiFp(this.configuration).vmImagesDownload(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * CPE match fields used for filtering must conform to the CPE (2.3) Name Matching Specification
     * @summary List of existing VM images
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {VmImagesListIconTypeEnum} [iconType] Icon Type used for the VM Image
     * @param {boolean} [publicUrl] 
     * @param {string} [lang] CPE Match Field
     * @param {string} [other] CPE Match Field
     * @param {VmImagesListPartEnum} [part] CPE Match Field
     * @param {string} [product] CPE Match Field
     * @param {string} [softwareEdition] CPE Match Field
     * @param {string} [targetHardware] CPE Match Field
     * @param {string} [targetSoftware] CPE Match Field
     * @param {string} [update] CPE Match Field
     * @param {string} [vendor] CPE Match Field
     * @param {string} [version] CPE Match Field
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {VmImagesListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {VmImagesListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsVMImagesApi
     */
    public vmImagesList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, iconType?: VmImagesListIconTypeEnum, publicUrl?: boolean, lang?: string, other?: string, part?: VmImagesListPartEnum, product?: string, softwareEdition?: string, targetHardware?: string, targetSoftware?: string, update?: string, vendor?: string, version?: string, offset?: number, limit?: number, search?: string, sortBy?: VmImagesListSortByEnum, sort?: VmImagesListSortEnum, options?: RawAxiosRequestConfig) {
        return AssetsVMImagesApiFp(this.configuration).vmImagesList(uuid, name, description, author, metadata, iconType, publicUrl, lang, other, part, product, softwareEdition, targetHardware, targetSoftware, update, vendor, version, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a VM image
     * @param {string} uuid 
     * @param {boolean} [publicUrl] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsVMImagesApi
     */
    public vmImagesRetrieve(uuid: string, publicUrl?: boolean, options?: RawAxiosRequestConfig) {
        return AssetsVMImagesApiFp(this.configuration).vmImagesRetrieve(uuid, publicUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a VM image
     * @param {string} uuid 
     * @param {VmImageUpdate} [vmImageUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsVMImagesApi
     */
    public vmImagesUpdate(uuid: string, vmImageUpdate?: VmImageUpdate, options?: RawAxiosRequestConfig) {
        return AssetsVMImagesApiFp(this.configuration).vmImagesUpdate(uuid, vmImageUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const VmImagesListIconTypeEnum = {
    FileServer: 'FileServer',
    Firewall: 'Firewall',
    Internet: 'Internet',
    Laptop: 'Laptop',
    MailServer: 'MailServer',
    Mobile: 'Mobile',
    Plc: 'PLC',
    Printer: 'Printer',
    Router: 'Router',
    Server: 'Server',
    Switch: 'Switch',
    WebProxy: 'WebProxy',
    WebServer: 'WebServer',
    WirelessAccessPoint: 'WirelessAccessPoint',
    Workstation: 'Workstation'
} as const;
export type VmImagesListIconTypeEnum = typeof VmImagesListIconTypeEnum[keyof typeof VmImagesListIconTypeEnum];
/**
 * @export
 */
export const VmImagesListPartEnum = {
    A: 'a',
    O: 'o',
    H: 'h',
    Star: '*',
    Minus: '-'
} as const;
export type VmImagesListPartEnum = typeof VmImagesListPartEnum[keyof typeof VmImagesListPartEnum];
/**
 * @export
 */
export const VmImagesListSortByEnum = {
    Author: 'author',
    Description: 'description',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Name: 'name',
    Size: 'size',
    BootDetailsMetaIconType: 'bootDetails.meta.iconType',
    CpeLang: 'cpe.lang',
    CpeOther: 'cpe.other',
    CpePart: 'cpe.part',
    CpeProduct: 'cpe.product',
    CpeSoftwareEdition: 'cpe.softwareEdition',
    CpeTargetHardware: 'cpe.targetHardware',
    CpeTargetSoftware: 'cpe.targetSoftware',
    CpeUpdate: 'cpe.update',
    CpeVendor: 'cpe.vendor',
    CpeVersion: 'cpe.version'
} as const;
export type VmImagesListSortByEnum = typeof VmImagesListSortByEnum[keyof typeof VmImagesListSortByEnum];
/**
 * @export
 */
export const VmImagesListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type VmImagesListSortEnum = typeof VmImagesListSortEnum[keyof typeof VmImagesListSortEnum];


/**
 * AssetsVolumesApi - axios parameter creator
 * @export
 */
export const AssetsVolumesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a volume
         * @param {string} name A user provided human readable name.
         * @param {File} file The file to upload
         * @param {string} volumeType Type of the volume
         * @param {string} [description] A user provided human readable description.
         * @param {object} [metadata] User provided metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        volumesCreate: async (name: string, file: File, volumeType: string, description?: string, metadata?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('volumesCreate', 'name', name)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('volumesCreate', 'file', file)
            // verify required parameter 'volumeType' is not null or undefined
            assertParamExists('volumesCreate', 'volumeType', volumeType)
            const localVarPath = `/v1/content/assets/volumes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (metadata !== undefined) { 
                localVarFormParams.append('metadata', new Blob([JSON.stringify(metadata)], { type: "application/json", }));
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (volumeType !== undefined) { 
                localVarFormParams.append('volumeType', volumeType as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a volume
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        volumesDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('volumesDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/assets/volumes/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download a volume
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        volumesDownload: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('volumesDownload', 'uuid', uuid)
            const localVarPath = `/v1/content/assets/volumes/{uuid}/download`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of existing volumes
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [volumeType] 
         * @param {boolean} [publicUrl] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {VolumesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {VolumesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        volumesList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, volumeType?: string, publicUrl?: boolean, offset?: number, limit?: number, search?: string, sortBy?: VolumesListSortByEnum, sort?: VolumesListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/assets/volumes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (volumeType !== undefined) {
                localVarQueryParameter['volumeType'] = volumeType;
            }

            if (publicUrl !== undefined) {
                localVarQueryParameter['publicUrl'] = publicUrl;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a volume
         * @param {string} uuid 
         * @param {boolean} [publicUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        volumesRetrieve: async (uuid: string, publicUrl?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('volumesRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/assets/volumes/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (publicUrl !== undefined) {
                localVarQueryParameter['publicUrl'] = publicUrl;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a volume
         * @param {string} uuid 
         * @param {VolumeUpdate} [volumeUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        volumesUpdate: async (uuid: string, volumeUpdate?: VolumeUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('volumesUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/assets/volumes/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(volumeUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetsVolumesApi - functional programming interface
 * @export
 */
export const AssetsVolumesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssetsVolumesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a volume
         * @param {string} name A user provided human readable name.
         * @param {File} file The file to upload
         * @param {string} volumeType Type of the volume
         * @param {string} [description] A user provided human readable description.
         * @param {object} [metadata] User provided metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async volumesCreate(name: string, file: File, volumeType: string, description?: string, metadata?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Volume>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.volumesCreate(name, file, volumeType, description, metadata, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsVolumesApi.volumesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a volume
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async volumesDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.volumesDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsVolumesApi.volumesDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download a volume
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async volumesDownload(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.volumesDownload(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsVolumesApi.volumesDownload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List of existing volumes
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [volumeType] 
         * @param {boolean} [publicUrl] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {VolumesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {VolumesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async volumesList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, volumeType?: string, publicUrl?: boolean, offset?: number, limit?: number, search?: string, sortBy?: VolumesListSortByEnum, sort?: VolumesListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VolumesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.volumesList(uuid, name, description, author, metadata, volumeType, publicUrl, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsVolumesApi.volumesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a volume
         * @param {string} uuid 
         * @param {boolean} [publicUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async volumesRetrieve(uuid: string, publicUrl?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Volume>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.volumesRetrieve(uuid, publicUrl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsVolumesApi.volumesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a volume
         * @param {string} uuid 
         * @param {VolumeUpdate} [volumeUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async volumesUpdate(uuid: string, volumeUpdate?: VolumeUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Volume>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.volumesUpdate(uuid, volumeUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AssetsVolumesApi.volumesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AssetsVolumesApi - factory interface
 * @export
 */
export const AssetsVolumesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssetsVolumesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a volume
         * @param {string} name A user provided human readable name.
         * @param {File} file The file to upload
         * @param {string} volumeType Type of the volume
         * @param {string} [description] A user provided human readable description.
         * @param {object} [metadata] User provided metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        volumesCreate(name: string, file: File, volumeType: string, description?: string, metadata?: object, options?: RawAxiosRequestConfig): AxiosPromise<Volume> {
            return localVarFp.volumesCreate(name, file, volumeType, description, metadata, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a volume
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        volumesDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.volumesDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download a volume
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        volumesDownload(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.volumesDownload(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List of existing volumes
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [volumeType] 
         * @param {boolean} [publicUrl] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {VolumesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {VolumesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        volumesList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, volumeType?: string, publicUrl?: boolean, offset?: number, limit?: number, search?: string, sortBy?: VolumesListSortByEnum, sort?: VolumesListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<VolumesList200Response> {
            return localVarFp.volumesList(uuid, name, description, author, metadata, volumeType, publicUrl, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a volume
         * @param {string} uuid 
         * @param {boolean} [publicUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        volumesRetrieve(uuid: string, publicUrl?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Volume> {
            return localVarFp.volumesRetrieve(uuid, publicUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a volume
         * @param {string} uuid 
         * @param {VolumeUpdate} [volumeUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        volumesUpdate(uuid: string, volumeUpdate?: VolumeUpdate, options?: RawAxiosRequestConfig): AxiosPromise<Volume> {
            return localVarFp.volumesUpdate(uuid, volumeUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AssetsVolumesApi - object-oriented interface
 * @export
 * @class AssetsVolumesApi
 * @extends {BaseAPI}
 */
export class AssetsVolumesApi extends BaseAPI {
    /**
     * 
     * @summary Create a volume
     * @param {string} name A user provided human readable name.
     * @param {File} file The file to upload
     * @param {string} volumeType Type of the volume
     * @param {string} [description] A user provided human readable description.
     * @param {object} [metadata] User provided metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsVolumesApi
     */
    public volumesCreate(name: string, file: File, volumeType: string, description?: string, metadata?: object, options?: RawAxiosRequestConfig) {
        return AssetsVolumesApiFp(this.configuration).volumesCreate(name, file, volumeType, description, metadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a volume
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsVolumesApi
     */
    public volumesDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return AssetsVolumesApiFp(this.configuration).volumesDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download a volume
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsVolumesApi
     */
    public volumesDownload(uuid: string, options?: RawAxiosRequestConfig) {
        return AssetsVolumesApiFp(this.configuration).volumesDownload(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List of existing volumes
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {string} [volumeType] 
     * @param {boolean} [publicUrl] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {VolumesListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {VolumesListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsVolumesApi
     */
    public volumesList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, volumeType?: string, publicUrl?: boolean, offset?: number, limit?: number, search?: string, sortBy?: VolumesListSortByEnum, sort?: VolumesListSortEnum, options?: RawAxiosRequestConfig) {
        return AssetsVolumesApiFp(this.configuration).volumesList(uuid, name, description, author, metadata, volumeType, publicUrl, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a volume
     * @param {string} uuid 
     * @param {boolean} [publicUrl] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsVolumesApi
     */
    public volumesRetrieve(uuid: string, publicUrl?: boolean, options?: RawAxiosRequestConfig) {
        return AssetsVolumesApiFp(this.configuration).volumesRetrieve(uuid, publicUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a volume
     * @param {string} uuid 
     * @param {VolumeUpdate} [volumeUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsVolumesApi
     */
    public volumesUpdate(uuid: string, volumeUpdate?: VolumeUpdate, options?: RawAxiosRequestConfig) {
        return AssetsVolumesApiFp(this.configuration).volumesUpdate(uuid, volumeUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const VolumesListSortByEnum = {
    Author: 'author',
    Description: 'description',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Name: 'name',
    Size: 'size',
    VolumeType: 'volumeType'
} as const;
export type VolumesListSortByEnum = typeof VolumesListSortByEnum[keyof typeof VolumesListSortByEnum];
/**
 * @export
 */
export const VolumesListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type VolumesListSortEnum = typeof VolumesListSortEnum[keyof typeof VolumesListSortEnum];


/**
 * BackgroundJobsApi - axios parameter creator
 * @export
 */
export const BackgroundJobsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List background jobs
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [scenarioId] 
         * @param {string} [jobId] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {BackgroundJobsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {BackgroundJobsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backgroundJobsList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, scenarioId?: string, jobId?: string, offset?: number, limit?: number, search?: string, sortBy?: BackgroundJobsListSortByEnum, sort?: BackgroundJobsListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/background-jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (scenarioId !== undefined) {
                localVarQueryParameter['scenarioId'] = scenarioId;
            }

            if (jobId !== undefined) {
                localVarQueryParameter['jobId'] = jobId;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a background job
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backgroundJobsRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('backgroundJobsRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/background-jobs/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BackgroundJobsApi - functional programming interface
 * @export
 */
export const BackgroundJobsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BackgroundJobsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List background jobs
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [scenarioId] 
         * @param {string} [jobId] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {BackgroundJobsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {BackgroundJobsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async backgroundJobsList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, scenarioId?: string, jobId?: string, offset?: number, limit?: number, search?: string, sortBy?: BackgroundJobsListSortByEnum, sort?: BackgroundJobsListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BackgroundJobsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.backgroundJobsList(uuid, name, description, author, metadata, scenarioId, jobId, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BackgroundJobsApi.backgroundJobsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a background job
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async backgroundJobsRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BackgroundJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.backgroundJobsRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BackgroundJobsApi.backgroundJobsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BackgroundJobsApi - factory interface
 * @export
 */
export const BackgroundJobsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BackgroundJobsApiFp(configuration)
    return {
        /**
         * 
         * @summary List background jobs
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [scenarioId] 
         * @param {string} [jobId] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {BackgroundJobsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {BackgroundJobsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backgroundJobsList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, scenarioId?: string, jobId?: string, offset?: number, limit?: number, search?: string, sortBy?: BackgroundJobsListSortByEnum, sort?: BackgroundJobsListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<BackgroundJobsList200Response> {
            return localVarFp.backgroundJobsList(uuid, name, description, author, metadata, scenarioId, jobId, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a background job
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backgroundJobsRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<BackgroundJob> {
            return localVarFp.backgroundJobsRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BackgroundJobsApi - object-oriented interface
 * @export
 * @class BackgroundJobsApi
 * @extends {BaseAPI}
 */
export class BackgroundJobsApi extends BaseAPI {
    /**
     * 
     * @summary List background jobs
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {string} [scenarioId] 
     * @param {string} [jobId] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {BackgroundJobsListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {BackgroundJobsListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackgroundJobsApi
     */
    public backgroundJobsList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, scenarioId?: string, jobId?: string, offset?: number, limit?: number, search?: string, sortBy?: BackgroundJobsListSortByEnum, sort?: BackgroundJobsListSortEnum, options?: RawAxiosRequestConfig) {
        return BackgroundJobsApiFp(this.configuration).backgroundJobsList(uuid, name, description, author, metadata, scenarioId, jobId, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a background job
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackgroundJobsApi
     */
    public backgroundJobsRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return BackgroundJobsApiFp(this.configuration).backgroundJobsRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const BackgroundJobsListSortByEnum = {
    Author: 'author',
    Description: 'description',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Name: 'name'
} as const;
export type BackgroundJobsListSortByEnum = typeof BackgroundJobsListSortByEnum[keyof typeof BackgroundJobsListSortByEnum];
/**
 * @export
 */
export const BackgroundJobsListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type BackgroundJobsListSortEnum = typeof BackgroundJobsListSortEnum[keyof typeof BackgroundJobsListSortEnum];


/**
 * Cmi5AUMappingApi - axios parameter creator
 * @export
 */
export const Cmi5AUMappingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a cmi5 au mapping
         * @param {Cmi5AuMappingCreate} [cmi5AuMappingCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmi5AuMappingCreate: async (cmi5AuMappingCreate?: Cmi5AuMappingCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/cmi5/auMapping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cmi5AuMappingCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a cmi5 au mapping
         * @param {string} auId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmi5AuMappingDelete: async (auId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'auId' is not null or undefined
            assertParamExists('cmi5AuMappingDelete', 'auId', auId)
            const localVarPath = `/v1/cmi5/auMapping/{auId}`
                .replace(`{${"auId"}}`, encodeURIComponent(String(auId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve list of cmi5 au mappings
         * @param {string} [author] 
         * @param {string} [dateCreated] 
         * @param {string} [dateEdited] 
         * @param {string} [name] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {Cmi5AuMappingListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {Cmi5AuMappingListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmi5AuMappingList: async (author?: string, dateCreated?: string, dateEdited?: string, name?: string, offset?: number, limit?: number, search?: string, sortBy?: Cmi5AuMappingListSortByEnum, sort?: Cmi5AuMappingListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/cmi5/auMapping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (dateCreated !== undefined) {
                localVarQueryParameter['dateCreated'] = dateCreated;
            }

            if (dateEdited !== undefined) {
                localVarQueryParameter['dateEdited'] = dateEdited;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a cmi5 au mapping
         * @param {string} auId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmi5AuMappingRetrieve: async (auId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'auId' is not null or undefined
            assertParamExists('cmi5AuMappingRetrieve', 'auId', auId)
            const localVarPath = `/v1/cmi5/auMapping/{auId}`
                .replace(`{${"auId"}}`, encodeURIComponent(String(auId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a cmi5 au mapping
         * @param {string} auId 
         * @param {Cmi5AuMappingUpdate} [cmi5AuMappingUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmi5AuMappingUpdate: async (auId: string, cmi5AuMappingUpdate?: Cmi5AuMappingUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'auId' is not null or undefined
            assertParamExists('cmi5AuMappingUpdate', 'auId', auId)
            const localVarPath = `/v1/cmi5/auMapping/{auId}`
                .replace(`{${"auId"}}`, encodeURIComponent(String(auId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cmi5AuMappingUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Cmi5AUMappingApi - functional programming interface
 * @export
 */
export const Cmi5AUMappingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Cmi5AUMappingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a cmi5 au mapping
         * @param {Cmi5AuMappingCreate} [cmi5AuMappingCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmi5AuMappingCreate(cmi5AuMappingCreate?: Cmi5AuMappingCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cmi5AUMapping>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmi5AuMappingCreate(cmi5AuMappingCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Cmi5AUMappingApi.cmi5AuMappingCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a cmi5 au mapping
         * @param {string} auId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmi5AuMappingDelete(auId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmi5AuMappingDelete(auId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Cmi5AUMappingApi.cmi5AuMappingDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve list of cmi5 au mappings
         * @param {string} [author] 
         * @param {string} [dateCreated] 
         * @param {string} [dateEdited] 
         * @param {string} [name] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {Cmi5AuMappingListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {Cmi5AuMappingListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmi5AuMappingList(author?: string, dateCreated?: string, dateEdited?: string, name?: string, offset?: number, limit?: number, search?: string, sortBy?: Cmi5AuMappingListSortByEnum, sort?: Cmi5AuMappingListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cmi5AuMappingList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmi5AuMappingList(author, dateCreated, dateEdited, name, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Cmi5AUMappingApi.cmi5AuMappingList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a cmi5 au mapping
         * @param {string} auId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmi5AuMappingRetrieve(auId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cmi5AUMapping>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmi5AuMappingRetrieve(auId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Cmi5AUMappingApi.cmi5AuMappingRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a cmi5 au mapping
         * @param {string} auId 
         * @param {Cmi5AuMappingUpdate} [cmi5AuMappingUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmi5AuMappingUpdate(auId: string, cmi5AuMappingUpdate?: Cmi5AuMappingUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cmi5AUMapping>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmi5AuMappingUpdate(auId, cmi5AuMappingUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Cmi5AUMappingApi.cmi5AuMappingUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Cmi5AUMappingApi - factory interface
 * @export
 */
export const Cmi5AUMappingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Cmi5AUMappingApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a cmi5 au mapping
         * @param {Cmi5AuMappingCreate} [cmi5AuMappingCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmi5AuMappingCreate(cmi5AuMappingCreate?: Cmi5AuMappingCreate, options?: RawAxiosRequestConfig): AxiosPromise<Cmi5AUMapping> {
            return localVarFp.cmi5AuMappingCreate(cmi5AuMappingCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a cmi5 au mapping
         * @param {string} auId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmi5AuMappingDelete(auId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cmi5AuMappingDelete(auId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve list of cmi5 au mappings
         * @param {string} [author] 
         * @param {string} [dateCreated] 
         * @param {string} [dateEdited] 
         * @param {string} [name] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {Cmi5AuMappingListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {Cmi5AuMappingListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmi5AuMappingList(author?: string, dateCreated?: string, dateEdited?: string, name?: string, offset?: number, limit?: number, search?: string, sortBy?: Cmi5AuMappingListSortByEnum, sort?: Cmi5AuMappingListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<Cmi5AuMappingList200Response> {
            return localVarFp.cmi5AuMappingList(author, dateCreated, dateEdited, name, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a cmi5 au mapping
         * @param {string} auId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmi5AuMappingRetrieve(auId: string, options?: RawAxiosRequestConfig): AxiosPromise<Cmi5AUMapping> {
            return localVarFp.cmi5AuMappingRetrieve(auId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a cmi5 au mapping
         * @param {string} auId 
         * @param {Cmi5AuMappingUpdate} [cmi5AuMappingUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmi5AuMappingUpdate(auId: string, cmi5AuMappingUpdate?: Cmi5AuMappingUpdate, options?: RawAxiosRequestConfig): AxiosPromise<Cmi5AUMapping> {
            return localVarFp.cmi5AuMappingUpdate(auId, cmi5AuMappingUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Cmi5AUMappingApi - object-oriented interface
 * @export
 * @class Cmi5AUMappingApi
 * @extends {BaseAPI}
 */
export class Cmi5AUMappingApi extends BaseAPI {
    /**
     * 
     * @summary Create a cmi5 au mapping
     * @param {Cmi5AuMappingCreate} [cmi5AuMappingCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Cmi5AUMappingApi
     */
    public cmi5AuMappingCreate(cmi5AuMappingCreate?: Cmi5AuMappingCreate, options?: RawAxiosRequestConfig) {
        return Cmi5AUMappingApiFp(this.configuration).cmi5AuMappingCreate(cmi5AuMappingCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a cmi5 au mapping
     * @param {string} auId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Cmi5AUMappingApi
     */
    public cmi5AuMappingDelete(auId: string, options?: RawAxiosRequestConfig) {
        return Cmi5AUMappingApiFp(this.configuration).cmi5AuMappingDelete(auId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve list of cmi5 au mappings
     * @param {string} [author] 
     * @param {string} [dateCreated] 
     * @param {string} [dateEdited] 
     * @param {string} [name] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {Cmi5AuMappingListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {Cmi5AuMappingListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Cmi5AUMappingApi
     */
    public cmi5AuMappingList(author?: string, dateCreated?: string, dateEdited?: string, name?: string, offset?: number, limit?: number, search?: string, sortBy?: Cmi5AuMappingListSortByEnum, sort?: Cmi5AuMappingListSortEnum, options?: RawAxiosRequestConfig) {
        return Cmi5AUMappingApiFp(this.configuration).cmi5AuMappingList(author, dateCreated, dateEdited, name, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a cmi5 au mapping
     * @param {string} auId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Cmi5AUMappingApi
     */
    public cmi5AuMappingRetrieve(auId: string, options?: RawAxiosRequestConfig) {
        return Cmi5AUMappingApiFp(this.configuration).cmi5AuMappingRetrieve(auId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a cmi5 au mapping
     * @param {string} auId 
     * @param {Cmi5AuMappingUpdate} [cmi5AuMappingUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Cmi5AUMappingApi
     */
    public cmi5AuMappingUpdate(auId: string, cmi5AuMappingUpdate?: Cmi5AuMappingUpdate, options?: RawAxiosRequestConfig) {
        return Cmi5AUMappingApiFp(this.configuration).cmi5AuMappingUpdate(auId, cmi5AuMappingUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const Cmi5AuMappingListSortByEnum = {
    Author: 'author',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Name: 'name'
} as const;
export type Cmi5AuMappingListSortByEnum = typeof Cmi5AuMappingListSortByEnum[keyof typeof Cmi5AuMappingListSortByEnum];
/**
 * @export
 */
export const Cmi5AuMappingListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type Cmi5AuMappingListSortEnum = typeof Cmi5AuMappingListSortEnum[keyof typeof Cmi5AuMappingListSortEnum];


/**
 * Cmi5BuildApi - axios parameter creator
 * @export
 */
export const Cmi5BuildApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a cmi5 zip package and return it
         * @param {File} file 
         * @param {string} project The name of the CMI5 course
         * @param {boolean} createAuMappings Whether or not to create / update au mappings for a course
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmi5BuildBuild: async (file: File, project: string, createAuMappings: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('cmi5BuildBuild', 'file', file)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('cmi5BuildBuild', 'project', project)
            // verify required parameter 'createAuMappings' is not null or undefined
            assertParamExists('cmi5BuildBuild', 'createAuMappings', createAuMappings)
            const localVarPath = `/v1/cmi5/build`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (project !== undefined) { 
                localVarFormParams.append('project', project as any);
            }
    
            if (createAuMappings !== undefined) { 
                localVarFormParams.append('createAuMappings', String(createAuMappings) as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Cmi5BuildApi - functional programming interface
 * @export
 */
export const Cmi5BuildApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Cmi5BuildApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a cmi5 zip package and return it
         * @param {File} file 
         * @param {string} project The name of the CMI5 course
         * @param {boolean} createAuMappings Whether or not to create / update au mappings for a course
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmi5BuildBuild(file: File, project: string, createAuMappings: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmi5BuildBuild(file, project, createAuMappings, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Cmi5BuildApi.cmi5BuildBuild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Cmi5BuildApi - factory interface
 * @export
 */
export const Cmi5BuildApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Cmi5BuildApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a cmi5 zip package and return it
         * @param {File} file 
         * @param {string} project The name of the CMI5 course
         * @param {boolean} createAuMappings Whether or not to create / update au mappings for a course
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmi5BuildBuild(file: File, project: string, createAuMappings: boolean, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.cmi5BuildBuild(file, project, createAuMappings, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Cmi5BuildApi - object-oriented interface
 * @export
 * @class Cmi5BuildApi
 * @extends {BaseAPI}
 */
export class Cmi5BuildApi extends BaseAPI {
    /**
     * 
     * @summary Create a cmi5 zip package and return it
     * @param {File} file 
     * @param {string} project The name of the CMI5 course
     * @param {boolean} createAuMappings Whether or not to create / update au mappings for a course
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Cmi5BuildApi
     */
    public cmi5BuildBuild(file: File, project: string, createAuMappings: boolean, options?: RawAxiosRequestConfig) {
        return Cmi5BuildApiFp(this.configuration).cmi5BuildBuild(file, project, createAuMappings, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Cmi5CoursesApi - axios parameter creator
 * @export
 */
export const Cmi5CoursesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Uploads cmi5 course
         * @param {File} file 
         * @param {string} project The name of the CMI5 course
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coursesCreate: async (file: File, project: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('coursesCreate', 'file', file)
            // verify required parameter 'project' is not null or undefined
            assertParamExists('coursesCreate', 'project', project)
            const localVarPath = `/v1/cmi5/courses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (project !== undefined) { 
                localVarFormParams.append('project', project as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a cmi5 course
         * @param {string} project 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coursesDelete: async (project: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project' is not null or undefined
            assertParamExists('coursesDelete', 'project', project)
            const localVarPath = `/v1/cmi5/courses/{project}`
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Grants course access to a user
         * @param {string} project 
         * @param {CoursesGrantRequest} [coursesGrantRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coursesGrant: async (project: string, coursesGrantRequest?: CoursesGrantRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project' is not null or undefined
            assertParamExists('coursesGrant', 'project', project)
            const localVarPath = `/v1/cmi5/courses/{project}/grant`
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(coursesGrantRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Lists cmi5 courses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coursesList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/cmi5/courses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Revokes course access from a user
         * @param {string} project 
         * @param {CoursesGrantRequest} [coursesGrantRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coursesRevoke: async (project: string, coursesGrantRequest?: CoursesGrantRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'project' is not null or undefined
            assertParamExists('coursesRevoke', 'project', project)
            const localVarPath = `/v1/cmi5/courses/{project}/revoke`
                .replace(`{${"project"}}`, encodeURIComponent(String(project)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(coursesGrantRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Cmi5CoursesApi - functional programming interface
 * @export
 */
export const Cmi5CoursesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Cmi5CoursesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Uploads cmi5 course
         * @param {File} file 
         * @param {string} project The name of the CMI5 course
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coursesCreate(file: File, project: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coursesCreate(file, project, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Cmi5CoursesApi.coursesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Deletes a cmi5 course
         * @param {string} project 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coursesDelete(project: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coursesDelete(project, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Cmi5CoursesApi.coursesDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Grants course access to a user
         * @param {string} project 
         * @param {CoursesGrantRequest} [coursesGrantRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coursesGrant(project: string, coursesGrantRequest?: CoursesGrantRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coursesGrant(project, coursesGrantRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Cmi5CoursesApi.coursesGrant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Lists cmi5 courses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coursesList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProjectApi>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coursesList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Cmi5CoursesApi.coursesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Revokes course access from a user
         * @param {string} project 
         * @param {CoursesGrantRequest} [coursesGrantRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async coursesRevoke(project: string, coursesGrantRequest?: CoursesGrantRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.coursesRevoke(project, coursesGrantRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Cmi5CoursesApi.coursesRevoke']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Cmi5CoursesApi - factory interface
 * @export
 */
export const Cmi5CoursesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Cmi5CoursesApiFp(configuration)
    return {
        /**
         * 
         * @summary Uploads cmi5 course
         * @param {File} file 
         * @param {string} project The name of the CMI5 course
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coursesCreate(file: File, project: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coursesCreate(file, project, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a cmi5 course
         * @param {string} project 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coursesDelete(project: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coursesDelete(project, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Grants course access to a user
         * @param {string} project 
         * @param {CoursesGrantRequest} [coursesGrantRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coursesGrant(project: string, coursesGrantRequest?: CoursesGrantRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.coursesGrant(project, coursesGrantRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Lists cmi5 courses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coursesList(options?: RawAxiosRequestConfig): AxiosPromise<Array<ProjectApi>> {
            return localVarFp.coursesList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Revokes course access from a user
         * @param {string} project 
         * @param {CoursesGrantRequest} [coursesGrantRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        coursesRevoke(project: string, coursesGrantRequest?: CoursesGrantRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.coursesRevoke(project, coursesGrantRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Cmi5CoursesApi - object-oriented interface
 * @export
 * @class Cmi5CoursesApi
 * @extends {BaseAPI}
 */
export class Cmi5CoursesApi extends BaseAPI {
    /**
     * 
     * @summary Uploads cmi5 course
     * @param {File} file 
     * @param {string} project The name of the CMI5 course
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Cmi5CoursesApi
     */
    public coursesCreate(file: File, project: string, options?: RawAxiosRequestConfig) {
        return Cmi5CoursesApiFp(this.configuration).coursesCreate(file, project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a cmi5 course
     * @param {string} project 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Cmi5CoursesApi
     */
    public coursesDelete(project: string, options?: RawAxiosRequestConfig) {
        return Cmi5CoursesApiFp(this.configuration).coursesDelete(project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Grants course access to a user
     * @param {string} project 
     * @param {CoursesGrantRequest} [coursesGrantRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Cmi5CoursesApi
     */
    public coursesGrant(project: string, coursesGrantRequest?: CoursesGrantRequest, options?: RawAxiosRequestConfig) {
        return Cmi5CoursesApiFp(this.configuration).coursesGrant(project, coursesGrantRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Lists cmi5 courses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Cmi5CoursesApi
     */
    public coursesList(options?: RawAxiosRequestConfig) {
        return Cmi5CoursesApiFp(this.configuration).coursesList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Revokes course access from a user
     * @param {string} project 
     * @param {CoursesGrantRequest} [coursesGrantRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Cmi5CoursesApi
     */
    public coursesRevoke(project: string, coursesGrantRequest?: CoursesGrantRequest, options?: RawAxiosRequestConfig) {
        return Cmi5CoursesApiFp(this.configuration).coursesRevoke(project, coursesGrantRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Cmi5RegistrationApi - axios parameter creator
 * @export
 */
export const Cmi5RegistrationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve all mappings of cmi5 course registration IDs to scenarios
         * @param {string} [author] 
         * @param {string} [dateCreated] 
         * @param {string} [dateEdited] 
         * @param {string} [deployedScenario] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {Cmi5CourseRegistrationListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {Cmi5CourseRegistrationListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmi5CourseRegistrationList: async (author?: string, dateCreated?: string, dateEdited?: string, deployedScenario?: string, offset?: number, limit?: number, search?: string, sortBy?: Cmi5CourseRegistrationListSortByEnum, sort?: Cmi5CourseRegistrationListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/cmi5/registration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (dateCreated !== undefined) {
                localVarQueryParameter['dateCreated'] = dateCreated;
            }

            if (dateEdited !== undefined) {
                localVarQueryParameter['dateEdited'] = dateEdited;
            }

            if (deployedScenario !== undefined) {
                localVarQueryParameter['deployedScenario'] = deployedScenario;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve mapping of cmi5 course registration IDs to deployed scenarios
         * @param {string} registrationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmi5CourseRegistrationRetrieve: async (registrationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registrationId' is not null or undefined
            assertParamExists('cmi5CourseRegistrationRetrieve', 'registrationId', registrationId)
            const localVarPath = `/v1/cmi5/registration/{registrationId}`
                .replace(`{${"registrationId"}}`, encodeURIComponent(String(registrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve console credentials
         * @param {string} registrationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmi5CourseRegistrationRetrieveConsoles: async (registrationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registrationId' is not null or undefined
            assertParamExists('cmi5CourseRegistrationRetrieveConsoles', 'registrationId', registrationId)
            const localVarPath = `/v1/cmi5/registration/{registrationId}/consoles`
                .replace(`{${"registrationId"}}`, encodeURIComponent(String(registrationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Cmi5RegistrationApi - functional programming interface
 * @export
 */
export const Cmi5RegistrationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Cmi5RegistrationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve all mappings of cmi5 course registration IDs to scenarios
         * @param {string} [author] 
         * @param {string} [dateCreated] 
         * @param {string} [dateEdited] 
         * @param {string} [deployedScenario] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {Cmi5CourseRegistrationListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {Cmi5CourseRegistrationListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmi5CourseRegistrationList(author?: string, dateCreated?: string, dateEdited?: string, deployedScenario?: string, offset?: number, limit?: number, search?: string, sortBy?: Cmi5CourseRegistrationListSortByEnum, sort?: Cmi5CourseRegistrationListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cmi5CourseRegistrationList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmi5CourseRegistrationList(author, dateCreated, dateEdited, deployedScenario, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Cmi5RegistrationApi.cmi5CourseRegistrationList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve mapping of cmi5 course registration IDs to deployed scenarios
         * @param {string} registrationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmi5CourseRegistrationRetrieve(registrationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cmi5Registration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmi5CourseRegistrationRetrieve(registrationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Cmi5RegistrationApi.cmi5CourseRegistrationRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve console credentials
         * @param {string} registrationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cmi5CourseRegistrationRetrieveConsoles(registrationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GuacamoleUserApi>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cmi5CourseRegistrationRetrieveConsoles(registrationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Cmi5RegistrationApi.cmi5CourseRegistrationRetrieveConsoles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Cmi5RegistrationApi - factory interface
 * @export
 */
export const Cmi5RegistrationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Cmi5RegistrationApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve all mappings of cmi5 course registration IDs to scenarios
         * @param {string} [author] 
         * @param {string} [dateCreated] 
         * @param {string} [dateEdited] 
         * @param {string} [deployedScenario] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {Cmi5CourseRegistrationListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {Cmi5CourseRegistrationListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmi5CourseRegistrationList(author?: string, dateCreated?: string, dateEdited?: string, deployedScenario?: string, offset?: number, limit?: number, search?: string, sortBy?: Cmi5CourseRegistrationListSortByEnum, sort?: Cmi5CourseRegistrationListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<Cmi5CourseRegistrationList200Response> {
            return localVarFp.cmi5CourseRegistrationList(author, dateCreated, dateEdited, deployedScenario, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve mapping of cmi5 course registration IDs to deployed scenarios
         * @param {string} registrationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmi5CourseRegistrationRetrieve(registrationId: string, options?: RawAxiosRequestConfig): AxiosPromise<Cmi5Registration> {
            return localVarFp.cmi5CourseRegistrationRetrieve(registrationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve console credentials
         * @param {string} registrationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cmi5CourseRegistrationRetrieveConsoles(registrationId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GuacamoleUserApi>> {
            return localVarFp.cmi5CourseRegistrationRetrieveConsoles(registrationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Cmi5RegistrationApi - object-oriented interface
 * @export
 * @class Cmi5RegistrationApi
 * @extends {BaseAPI}
 */
export class Cmi5RegistrationApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve all mappings of cmi5 course registration IDs to scenarios
     * @param {string} [author] 
     * @param {string} [dateCreated] 
     * @param {string} [dateEdited] 
     * @param {string} [deployedScenario] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {Cmi5CourseRegistrationListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {Cmi5CourseRegistrationListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Cmi5RegistrationApi
     */
    public cmi5CourseRegistrationList(author?: string, dateCreated?: string, dateEdited?: string, deployedScenario?: string, offset?: number, limit?: number, search?: string, sortBy?: Cmi5CourseRegistrationListSortByEnum, sort?: Cmi5CourseRegistrationListSortEnum, options?: RawAxiosRequestConfig) {
        return Cmi5RegistrationApiFp(this.configuration).cmi5CourseRegistrationList(author, dateCreated, dateEdited, deployedScenario, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve mapping of cmi5 course registration IDs to deployed scenarios
     * @param {string} registrationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Cmi5RegistrationApi
     */
    public cmi5CourseRegistrationRetrieve(registrationId: string, options?: RawAxiosRequestConfig) {
        return Cmi5RegistrationApiFp(this.configuration).cmi5CourseRegistrationRetrieve(registrationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve console credentials
     * @param {string} registrationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Cmi5RegistrationApi
     */
    public cmi5CourseRegistrationRetrieveConsoles(registrationId: string, options?: RawAxiosRequestConfig) {
        return Cmi5RegistrationApiFp(this.configuration).cmi5CourseRegistrationRetrieveConsoles(registrationId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const Cmi5CourseRegistrationListSortByEnum = {
    Author: 'author',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited'
} as const;
export type Cmi5CourseRegistrationListSortByEnum = typeof Cmi5CourseRegistrationListSortByEnum[keyof typeof Cmi5CourseRegistrationListSortByEnum];
/**
 * @export
 */
export const Cmi5CourseRegistrationListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type Cmi5CourseRegistrationListSortEnum = typeof Cmi5CourseRegistrationListSortEnum[keyof typeof Cmi5CourseRegistrationListSortEnum];


/**
 * Cmi5ScenariosApi - axios parameter creator
 * @export
 */
export const Cmi5ScenariosApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Assigns a scenario to the current user, or deploys a new one if none are available.
         * @summary Initialize Scenario
         * @param {ScenariosCreate1Request} [scenariosCreate1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosCreate1: async (scenariosCreate1Request?: ScenariosCreate1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/cmi5/scenarios`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scenariosCreate1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploy multiple scenarios for a given class
         * @summary Deploy scenarios for a class
         * @param {string} scenarioId 
         * @param {ScenariosDeployRequest} scenariosDeployRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosDeploy: async (scenarioId: string, scenariosDeployRequest: ScenariosDeployRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('scenariosDeploy', 'scenarioId', scenarioId)
            // verify required parameter 'scenariosDeployRequest' is not null or undefined
            assertParamExists('scenariosDeploy', 'scenariosDeployRequest', scenariosDeployRequest)
            const localVarPath = `/v1/cmi5/scenarios/{scenarioId}`
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scenariosDeployRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List existing in-range scenarios
         * @summary List scenarios
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [tag] 
         * @param {string} [deployedBy] 
         * @param {string} [classId] 
         * @param {string} [studentId] 
         * @param {string} [studentUsername] 
         * @param {string} [scenarioId] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {ScenariosList1SortByEnum} [sortBy] Key used to sort the collection by
         * @param {ScenariosList1SortEnum} [sort] 
         * @param {Array<ScenariosList1IncludesEnum>} [includes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosList1: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, tag?: string, deployedBy?: string, classId?: string, studentId?: string, studentUsername?: string, scenarioId?: string, offset?: number, limit?: number, search?: string, sortBy?: ScenariosList1SortByEnum, sort?: ScenariosList1SortEnum, includes?: Array<ScenariosList1IncludesEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/cmi5/scenarios`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deployedBy !== undefined) {
                localVarQueryParameter['deployedBy'] = deployedBy;
            }

            if (classId !== undefined) {
                localVarQueryParameter['classId'] = classId;
            }

            if (studentId !== undefined) {
                localVarQueryParameter['studentId'] = studentId;
            }

            if (studentUsername !== undefined) {
                localVarQueryParameter['studentUsername'] = studentUsername;
            }

            if (scenarioId !== undefined) {
                localVarQueryParameter['scenarioId'] = scenarioId;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (includes) {
                localVarQueryParameter['includes'] = includes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all classes that have scenarios deployed.
         * @summary List Classes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosListAllClasses: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/cmi5/scenarios/classes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Cmi5ScenariosApi - functional programming interface
 * @export
 */
export const Cmi5ScenariosApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Cmi5ScenariosApiAxiosParamCreator(configuration)
    return {
        /**
         * Assigns a scenario to the current user, or deploys a new one if none are available.
         * @summary Initialize Scenario
         * @param {ScenariosCreate1Request} [scenariosCreate1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scenariosCreate1(scenariosCreate1Request?: ScenariosCreate1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cmi5RegistrationAu>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scenariosCreate1(scenariosCreate1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Cmi5ScenariosApi.scenariosCreate1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deploy multiple scenarios for a given class
         * @summary Deploy scenarios for a class
         * @param {string} scenarioId 
         * @param {ScenariosDeployRequest} scenariosDeployRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scenariosDeploy(scenarioId: string, scenariosDeployRequest: ScenariosDeployRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BackgroundJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scenariosDeploy(scenarioId, scenariosDeployRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Cmi5ScenariosApi.scenariosDeploy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List existing in-range scenarios
         * @summary List scenarios
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [tag] 
         * @param {string} [deployedBy] 
         * @param {string} [classId] 
         * @param {string} [studentId] 
         * @param {string} [studentUsername] 
         * @param {string} [scenarioId] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {ScenariosList1SortByEnum} [sortBy] Key used to sort the collection by
         * @param {ScenariosList1SortEnum} [sort] 
         * @param {Array<ScenariosList1IncludesEnum>} [includes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scenariosList1(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, tag?: string, deployedBy?: string, classId?: string, studentId?: string, studentUsername?: string, scenarioId?: string, offset?: number, limit?: number, search?: string, sortBy?: ScenariosList1SortByEnum, sort?: ScenariosList1SortEnum, includes?: Array<ScenariosList1IncludesEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenariosListByRangeId200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scenariosList1(uuid, name, description, author, metadata, tag, deployedBy, classId, studentId, studentUsername, scenarioId, offset, limit, search, sortBy, sort, includes, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Cmi5ScenariosApi.scenariosList1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all classes that have scenarios deployed.
         * @summary List Classes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scenariosListAllClasses(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Cmi5Class>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scenariosListAllClasses(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['Cmi5ScenariosApi.scenariosListAllClasses']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * Cmi5ScenariosApi - factory interface
 * @export
 */
export const Cmi5ScenariosApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Cmi5ScenariosApiFp(configuration)
    return {
        /**
         * Assigns a scenario to the current user, or deploys a new one if none are available.
         * @summary Initialize Scenario
         * @param {ScenariosCreate1Request} [scenariosCreate1Request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosCreate1(scenariosCreate1Request?: ScenariosCreate1Request, options?: RawAxiosRequestConfig): AxiosPromise<Cmi5RegistrationAu> {
            return localVarFp.scenariosCreate1(scenariosCreate1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * Deploy multiple scenarios for a given class
         * @summary Deploy scenarios for a class
         * @param {string} scenarioId 
         * @param {ScenariosDeployRequest} scenariosDeployRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosDeploy(scenarioId: string, scenariosDeployRequest: ScenariosDeployRequest, options?: RawAxiosRequestConfig): AxiosPromise<BackgroundJob> {
            return localVarFp.scenariosDeploy(scenarioId, scenariosDeployRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * List existing in-range scenarios
         * @summary List scenarios
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [tag] 
         * @param {string} [deployedBy] 
         * @param {string} [classId] 
         * @param {string} [studentId] 
         * @param {string} [studentUsername] 
         * @param {string} [scenarioId] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {ScenariosList1SortByEnum} [sortBy] Key used to sort the collection by
         * @param {ScenariosList1SortEnum} [sort] 
         * @param {Array<ScenariosList1IncludesEnum>} [includes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosList1(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, tag?: string, deployedBy?: string, classId?: string, studentId?: string, studentUsername?: string, scenarioId?: string, offset?: number, limit?: number, search?: string, sortBy?: ScenariosList1SortByEnum, sort?: ScenariosList1SortEnum, includes?: Array<ScenariosList1IncludesEnum>, options?: RawAxiosRequestConfig): AxiosPromise<ScenariosListByRangeId200Response> {
            return localVarFp.scenariosList1(uuid, name, description, author, metadata, tag, deployedBy, classId, studentId, studentUsername, scenarioId, offset, limit, search, sortBy, sort, includes, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all classes that have scenarios deployed.
         * @summary List Classes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosListAllClasses(options?: RawAxiosRequestConfig): AxiosPromise<Array<Cmi5Class>> {
            return localVarFp.scenariosListAllClasses(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Cmi5ScenariosApi - object-oriented interface
 * @export
 * @class Cmi5ScenariosApi
 * @extends {BaseAPI}
 */
export class Cmi5ScenariosApi extends BaseAPI {
    /**
     * Assigns a scenario to the current user, or deploys a new one if none are available.
     * @summary Initialize Scenario
     * @param {ScenariosCreate1Request} [scenariosCreate1Request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Cmi5ScenariosApi
     */
    public scenariosCreate1(scenariosCreate1Request?: ScenariosCreate1Request, options?: RawAxiosRequestConfig) {
        return Cmi5ScenariosApiFp(this.configuration).scenariosCreate1(scenariosCreate1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deploy multiple scenarios for a given class
     * @summary Deploy scenarios for a class
     * @param {string} scenarioId 
     * @param {ScenariosDeployRequest} scenariosDeployRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Cmi5ScenariosApi
     */
    public scenariosDeploy(scenarioId: string, scenariosDeployRequest: ScenariosDeployRequest, options?: RawAxiosRequestConfig) {
        return Cmi5ScenariosApiFp(this.configuration).scenariosDeploy(scenarioId, scenariosDeployRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List existing in-range scenarios
     * @summary List scenarios
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {string} [tag] 
     * @param {string} [deployedBy] 
     * @param {string} [classId] 
     * @param {string} [studentId] 
     * @param {string} [studentUsername] 
     * @param {string} [scenarioId] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {ScenariosList1SortByEnum} [sortBy] Key used to sort the collection by
     * @param {ScenariosList1SortEnum} [sort] 
     * @param {Array<ScenariosList1IncludesEnum>} [includes] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Cmi5ScenariosApi
     */
    public scenariosList1(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, tag?: string, deployedBy?: string, classId?: string, studentId?: string, studentUsername?: string, scenarioId?: string, offset?: number, limit?: number, search?: string, sortBy?: ScenariosList1SortByEnum, sort?: ScenariosList1SortEnum, includes?: Array<ScenariosList1IncludesEnum>, options?: RawAxiosRequestConfig) {
        return Cmi5ScenariosApiFp(this.configuration).scenariosList1(uuid, name, description, author, metadata, tag, deployedBy, classId, studentId, studentUsername, scenarioId, offset, limit, search, sortBy, sort, includes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all classes that have scenarios deployed.
     * @summary List Classes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Cmi5ScenariosApi
     */
    public scenariosListAllClasses(options?: RawAxiosRequestConfig) {
        return Cmi5ScenariosApiFp(this.configuration).scenariosListAllClasses(options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ScenariosList1SortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author',
    ScenarioId: 'scenarioId',
    DeployedBy: 'deployedBy',
    StudentUsername: 'studentUsername'
} as const;
export type ScenariosList1SortByEnum = typeof ScenariosList1SortByEnum[keyof typeof ScenariosList1SortByEnum];
/**
 * @export
 */
export const ScenariosList1SortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ScenariosList1SortEnum = typeof ScenariosList1SortEnum[keyof typeof ScenariosList1SortEnum];
/**
 * @export
 */
export const ScenariosList1IncludesEnum = {
    DetailPackages: 'detail.packages'
} as const;
export type ScenariosList1IncludesEnum = typeof ScenariosList1IncludesEnum[keyof typeof ScenariosList1IncludesEnum];


/**
 * CountryCodesApi - axios parameter creator
 * @export
 */
export const CountryCodesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all ISO 3316 country codes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryCodesList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/country-codes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CountryCodesApi - functional programming interface
 * @export
 */
export const CountryCodesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CountryCodesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all ISO 3316 country codes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countryCodesList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountryCodes>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countryCodesList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountryCodesApi.countryCodesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CountryCodesApi - factory interface
 * @export
 */
export const CountryCodesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CountryCodesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all ISO 3316 country codes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryCodesList(options?: RawAxiosRequestConfig): AxiosPromise<CountryCodes> {
            return localVarFp.countryCodesList(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CountryCodesApi - object-oriented interface
 * @export
 * @class CountryCodesApi
 * @extends {BaseAPI}
 */
export class CountryCodesApi extends BaseAPI {
    /**
     * 
     * @summary Get all ISO 3316 country codes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountryCodesApi
     */
    public countryCodesList(options?: RawAxiosRequestConfig) {
        return CountryCodesApiFp(this.configuration).countryCodesList(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DesignAIApi - axios parameter creator
 * @export
 */
export const DesignAIApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Query the Scenario Designer AI
         * @param {AiQueryRequest} [aiQueryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiQuery: async (aiQueryRequest?: AiQueryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/design/ai`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aiQueryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DesignAIApi - functional programming interface
 * @export
 */
export const DesignAIApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DesignAIApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Query the Scenario Designer AI
         * @param {AiQueryRequest} [aiQueryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async aiQuery(aiQueryRequest?: AiQueryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DesignAIResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.aiQuery(aiQueryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DesignAIApi.aiQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DesignAIApi - factory interface
 * @export
 */
export const DesignAIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DesignAIApiFp(configuration)
    return {
        /**
         * 
         * @summary Query the Scenario Designer AI
         * @param {AiQueryRequest} [aiQueryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aiQuery(aiQueryRequest?: AiQueryRequest, options?: RawAxiosRequestConfig): AxiosPromise<DesignAIResponse> {
            return localVarFp.aiQuery(aiQueryRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DesignAIApi - object-oriented interface
 * @export
 * @class DesignAIApi
 * @extends {BaseAPI}
 */
export class DesignAIApi extends BaseAPI {
    /**
     * 
     * @summary Query the Scenario Designer AI
     * @param {AiQueryRequest} [aiQueryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DesignAIApi
     */
    public aiQuery(aiQueryRequest?: AiQueryRequest, options?: RawAxiosRequestConfig) {
        return DesignAIApiFp(this.configuration).aiQuery(aiQueryRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DesignDraftsApi - axios parameter creator
 * @export
 */
export const DesignDraftsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a draft state
         * @param {string} draftId 
         * @param {DraftStateCreate} [draftStateCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        draftStatesCreate: async (draftId: string, draftStateCreate?: DraftStateCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'draftId' is not null or undefined
            assertParamExists('draftStatesCreate', 'draftId', draftId)
            const localVarPath = `/v1/design/drafts/{draftId}/states`
                .replace(`{${"draftId"}}`, encodeURIComponent(String(draftId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(draftStateCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a draft state
         * @param {string} draftId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        draftStatesDelete: async (draftId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'draftId' is not null or undefined
            assertParamExists('draftStatesDelete', 'draftId', draftId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('draftStatesDelete', 'uuid', uuid)
            const localVarPath = `/v1/design/drafts/{draftId}/states/{uuid}`
                .replace(`{${"draftId"}}`, encodeURIComponent(String(draftId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List draft states
         * @param {string} draftId 
         * @param {string} [uuid] 
         * @param {boolean} [published] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DraftStatesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DraftStatesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        draftStatesList: async (draftId: string, uuid?: string, published?: boolean, offset?: number, limit?: number, search?: string, sortBy?: DraftStatesListSortByEnum, sort?: DraftStatesListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'draftId' is not null or undefined
            assertParamExists('draftStatesList', 'draftId', draftId)
            const localVarPath = `/v1/design/drafts/{draftId}/states`
                .replace(`{${"draftId"}}`, encodeURIComponent(String(draftId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (published !== undefined) {
                localVarQueryParameter['published'] = published;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a draft state
         * @param {string} draftId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        draftStatesRetrieve: async (draftId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'draftId' is not null or undefined
            assertParamExists('draftStatesRetrieve', 'draftId', draftId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('draftStatesRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/design/drafts/{draftId}/states/{uuid}`
                .replace(`{${"draftId"}}`, encodeURIComponent(String(draftId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a draft
         * @param {DraftCreate} [draftCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        draftsCreate: async (draftCreate?: DraftCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/design/drafts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(draftCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a draft
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        draftsDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('draftsDelete', 'uuid', uuid)
            const localVarPath = `/v1/design/drafts/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List drafts
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DraftsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DraftsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        draftsList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: DraftsListSortByEnum, sort?: DraftsListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/design/drafts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a draft
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        draftsRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('draftsRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/design/drafts/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a draft
         * @param {string} uuid 
         * @param {DraftUpdate} [draftUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        draftsUpdate: async (uuid: string, draftUpdate?: DraftUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('draftsUpdate', 'uuid', uuid)
            const localVarPath = `/v1/design/drafts/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(draftUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DesignDraftsApi - functional programming interface
 * @export
 */
export const DesignDraftsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DesignDraftsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a draft state
         * @param {string} draftId 
         * @param {DraftStateCreate} [draftStateCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async draftStatesCreate(draftId: string, draftStateCreate?: DraftStateCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DraftState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.draftStatesCreate(draftId, draftStateCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DesignDraftsApi.draftStatesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a draft state
         * @param {string} draftId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async draftStatesDelete(draftId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.draftStatesDelete(draftId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DesignDraftsApi.draftStatesDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List draft states
         * @param {string} draftId 
         * @param {string} [uuid] 
         * @param {boolean} [published] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DraftStatesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DraftStatesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async draftStatesList(draftId: string, uuid?: string, published?: boolean, offset?: number, limit?: number, search?: string, sortBy?: DraftStatesListSortByEnum, sort?: DraftStatesListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DraftStatesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.draftStatesList(draftId, uuid, published, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DesignDraftsApi.draftStatesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a draft state
         * @param {string} draftId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async draftStatesRetrieve(draftId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DraftState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.draftStatesRetrieve(draftId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DesignDraftsApi.draftStatesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a draft
         * @param {DraftCreate} [draftCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async draftsCreate(draftCreate?: DraftCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Draft>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.draftsCreate(draftCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DesignDraftsApi.draftsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a draft
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async draftsDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.draftsDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DesignDraftsApi.draftsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List drafts
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DraftsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DraftsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async draftsList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: DraftsListSortByEnum, sort?: DraftsListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DraftsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.draftsList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DesignDraftsApi.draftsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a draft
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async draftsRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Draft>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.draftsRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DesignDraftsApi.draftsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a draft
         * @param {string} uuid 
         * @param {DraftUpdate} [draftUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async draftsUpdate(uuid: string, draftUpdate?: DraftUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Draft>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.draftsUpdate(uuid, draftUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DesignDraftsApi.draftsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DesignDraftsApi - factory interface
 * @export
 */
export const DesignDraftsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DesignDraftsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a draft state
         * @param {string} draftId 
         * @param {DraftStateCreate} [draftStateCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        draftStatesCreate(draftId: string, draftStateCreate?: DraftStateCreate, options?: RawAxiosRequestConfig): AxiosPromise<DraftState> {
            return localVarFp.draftStatesCreate(draftId, draftStateCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a draft state
         * @param {string} draftId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        draftStatesDelete(draftId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.draftStatesDelete(draftId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List draft states
         * @param {string} draftId 
         * @param {string} [uuid] 
         * @param {boolean} [published] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DraftStatesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DraftStatesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        draftStatesList(draftId: string, uuid?: string, published?: boolean, offset?: number, limit?: number, search?: string, sortBy?: DraftStatesListSortByEnum, sort?: DraftStatesListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<DraftStatesList200Response> {
            return localVarFp.draftStatesList(draftId, uuid, published, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a draft state
         * @param {string} draftId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        draftStatesRetrieve(draftId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<DraftState> {
            return localVarFp.draftStatesRetrieve(draftId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a draft
         * @param {DraftCreate} [draftCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        draftsCreate(draftCreate?: DraftCreate, options?: RawAxiosRequestConfig): AxiosPromise<Draft> {
            return localVarFp.draftsCreate(draftCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a draft
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        draftsDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.draftsDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List drafts
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DraftsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DraftsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        draftsList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: DraftsListSortByEnum, sort?: DraftsListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<DraftsList200Response> {
            return localVarFp.draftsList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a draft
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        draftsRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<Draft> {
            return localVarFp.draftsRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a draft
         * @param {string} uuid 
         * @param {DraftUpdate} [draftUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        draftsUpdate(uuid: string, draftUpdate?: DraftUpdate, options?: RawAxiosRequestConfig): AxiosPromise<Draft> {
            return localVarFp.draftsUpdate(uuid, draftUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DesignDraftsApi - object-oriented interface
 * @export
 * @class DesignDraftsApi
 * @extends {BaseAPI}
 */
export class DesignDraftsApi extends BaseAPI {
    /**
     * 
     * @summary Create a draft state
     * @param {string} draftId 
     * @param {DraftStateCreate} [draftStateCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DesignDraftsApi
     */
    public draftStatesCreate(draftId: string, draftStateCreate?: DraftStateCreate, options?: RawAxiosRequestConfig) {
        return DesignDraftsApiFp(this.configuration).draftStatesCreate(draftId, draftStateCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a draft state
     * @param {string} draftId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DesignDraftsApi
     */
    public draftStatesDelete(draftId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return DesignDraftsApiFp(this.configuration).draftStatesDelete(draftId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List draft states
     * @param {string} draftId 
     * @param {string} [uuid] 
     * @param {boolean} [published] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {DraftStatesListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {DraftStatesListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DesignDraftsApi
     */
    public draftStatesList(draftId: string, uuid?: string, published?: boolean, offset?: number, limit?: number, search?: string, sortBy?: DraftStatesListSortByEnum, sort?: DraftStatesListSortEnum, options?: RawAxiosRequestConfig) {
        return DesignDraftsApiFp(this.configuration).draftStatesList(draftId, uuid, published, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a draft state
     * @param {string} draftId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DesignDraftsApi
     */
    public draftStatesRetrieve(draftId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return DesignDraftsApiFp(this.configuration).draftStatesRetrieve(draftId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a draft
     * @param {DraftCreate} [draftCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DesignDraftsApi
     */
    public draftsCreate(draftCreate?: DraftCreate, options?: RawAxiosRequestConfig) {
        return DesignDraftsApiFp(this.configuration).draftsCreate(draftCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a draft
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DesignDraftsApi
     */
    public draftsDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return DesignDraftsApiFp(this.configuration).draftsDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List drafts
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {DraftsListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {DraftsListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DesignDraftsApi
     */
    public draftsList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: DraftsListSortByEnum, sort?: DraftsListSortEnum, options?: RawAxiosRequestConfig) {
        return DesignDraftsApiFp(this.configuration).draftsList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a draft
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DesignDraftsApi
     */
    public draftsRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return DesignDraftsApiFp(this.configuration).draftsRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a draft
     * @param {string} uuid 
     * @param {DraftUpdate} [draftUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DesignDraftsApi
     */
    public draftsUpdate(uuid: string, draftUpdate?: DraftUpdate, options?: RawAxiosRequestConfig) {
        return DesignDraftsApiFp(this.configuration).draftsUpdate(uuid, draftUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DraftStatesListSortByEnum = {
    DateCreated: 'dateCreated',
    Version: 'version'
} as const;
export type DraftStatesListSortByEnum = typeof DraftStatesListSortByEnum[keyof typeof DraftStatesListSortByEnum];
/**
 * @export
 */
export const DraftStatesListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type DraftStatesListSortEnum = typeof DraftStatesListSortEnum[keyof typeof DraftStatesListSortEnum];
/**
 * @export
 */
export const DraftsListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author'
} as const;
export type DraftsListSortByEnum = typeof DraftsListSortByEnum[keyof typeof DraftsListSortByEnum];
/**
 * @export
 */
export const DraftsListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type DraftsListSortEnum = typeof DraftsListSortEnum[keyof typeof DraftsListSortEnum];


/**
 * GuacamoleApi - axios parameter creator
 * @export
 */
export const GuacamoleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a Guacamole User.
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {GuacamoleUserApi} [guacamoleUserApi] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guacamoleUsersCreateGuacamoleUser: async (rangeId: string, scenarioId: string, guacamoleUserApi?: GuacamoleUserApi, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('guacamoleUsersCreateGuacamoleUser', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('guacamoleUsersCreateGuacamoleUser', 'scenarioId', scenarioId)
            const localVarPath = `/v1/guacamole/{rangeId}/{scenarioId}/guacamole-users`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(guacamoleUserApi, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a guacamole user
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guacamoleUsersDeleteGuacamoleUser: async (rangeId: string, scenarioId: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('guacamoleUsersDeleteGuacamoleUser', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('guacamoleUsersDeleteGuacamoleUser', 'scenarioId', scenarioId)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('guacamoleUsersDeleteGuacamoleUser', 'name', name)
            const localVarPath = `/v1/guacamole/{rangeId}/{scenarioId}/guacamole-users/{name}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a Guacamole User from a specified scenario.
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guacamoleUsersRetrieveGuacamoleUser: async (rangeId: string, scenarioId: string, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('guacamoleUsersRetrieveGuacamoleUser', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('guacamoleUsersRetrieveGuacamoleUser', 'scenarioId', scenarioId)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('guacamoleUsersRetrieveGuacamoleUser', 'name', name)
            const localVarPath = `/v1/guacamole/{rangeId}/{scenarioId}/guacamole-users/{name}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GuacamoleApi - functional programming interface
 * @export
 */
export const GuacamoleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GuacamoleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a Guacamole User.
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {GuacamoleUserApi} [guacamoleUserApi] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async guacamoleUsersCreateGuacamoleUser(rangeId: string, scenarioId: string, guacamoleUserApi?: GuacamoleUserApi, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuacamoleUserApi>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.guacamoleUsersCreateGuacamoleUser(rangeId, scenarioId, guacamoleUserApi, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GuacamoleApi.guacamoleUsersCreateGuacamoleUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a guacamole user
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async guacamoleUsersDeleteGuacamoleUser(rangeId: string, scenarioId: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.guacamoleUsersDeleteGuacamoleUser(rangeId, scenarioId, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GuacamoleApi.guacamoleUsersDeleteGuacamoleUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a Guacamole User from a specified scenario.
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async guacamoleUsersRetrieveGuacamoleUser(rangeId: string, scenarioId: string, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuacamoleUserApi>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.guacamoleUsersRetrieveGuacamoleUser(rangeId, scenarioId, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GuacamoleApi.guacamoleUsersRetrieveGuacamoleUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GuacamoleApi - factory interface
 * @export
 */
export const GuacamoleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GuacamoleApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a Guacamole User.
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {GuacamoleUserApi} [guacamoleUserApi] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guacamoleUsersCreateGuacamoleUser(rangeId: string, scenarioId: string, guacamoleUserApi?: GuacamoleUserApi, options?: RawAxiosRequestConfig): AxiosPromise<GuacamoleUserApi> {
            return localVarFp.guacamoleUsersCreateGuacamoleUser(rangeId, scenarioId, guacamoleUserApi, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a guacamole user
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guacamoleUsersDeleteGuacamoleUser(rangeId: string, scenarioId: string, name: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.guacamoleUsersDeleteGuacamoleUser(rangeId, scenarioId, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a Guacamole User from a specified scenario.
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        guacamoleUsersRetrieveGuacamoleUser(rangeId: string, scenarioId: string, name: string, options?: RawAxiosRequestConfig): AxiosPromise<GuacamoleUserApi> {
            return localVarFp.guacamoleUsersRetrieveGuacamoleUser(rangeId, scenarioId, name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GuacamoleApi - object-oriented interface
 * @export
 * @class GuacamoleApi
 * @extends {BaseAPI}
 */
export class GuacamoleApi extends BaseAPI {
    /**
     * 
     * @summary Create a Guacamole User.
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {GuacamoleUserApi} [guacamoleUserApi] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuacamoleApi
     */
    public guacamoleUsersCreateGuacamoleUser(rangeId: string, scenarioId: string, guacamoleUserApi?: GuacamoleUserApi, options?: RawAxiosRequestConfig) {
        return GuacamoleApiFp(this.configuration).guacamoleUsersCreateGuacamoleUser(rangeId, scenarioId, guacamoleUserApi, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a guacamole user
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuacamoleApi
     */
    public guacamoleUsersDeleteGuacamoleUser(rangeId: string, scenarioId: string, name: string, options?: RawAxiosRequestConfig) {
        return GuacamoleApiFp(this.configuration).guacamoleUsersDeleteGuacamoleUser(rangeId, scenarioId, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a Guacamole User from a specified scenario.
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GuacamoleApi
     */
    public guacamoleUsersRetrieveGuacamoleUser(rangeId: string, scenarioId: string, name: string, options?: RawAxiosRequestConfig) {
        return GuacamoleApiFp(this.configuration).guacamoleUsersRetrieveGuacamoleUser(rangeId, scenarioId, name, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InfrastructureContentEnvironmentAWSCredentialsApi - axios parameter creator
 * @export
 */
export const InfrastructureContentEnvironmentAWSCredentialsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an AWS environment credential
         * @param {EnvironmentCredentialAwsCreate} [environmentCredentialAwsCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentAwsCredentialCreate: async (environmentCredentialAwsCreate?: EnvironmentCredentialAwsCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/infrastructure/environment-credentials/aws`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentCredentialAwsCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an AWS environment credential
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentAwsCredentialDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('environmentAwsCredentialDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/infrastructure/environment-credentials/aws/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing AWS environment credentials
         * @param {string} [name] 
         * @param {string} [author] 
         * @param {string} [description] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {EnvironmentAwsCredentialListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {EnvironmentAwsCredentialListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentAwsCredentialList: async (name?: string, author?: string, description?: string, offset?: number, limit?: number, search?: string, sortBy?: EnvironmentAwsCredentialListSortByEnum, sort?: EnvironmentAwsCredentialListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/infrastructure/environment-credentials/aws`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an AWS environment credential
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentAwsCredentialRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('environmentAwsCredentialRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/infrastructure/environment-credentials/aws/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an AWS environment credential
         * @param {string} uuid 
         * @param {EnvironmentCredentialAwsUpdate} [environmentCredentialAwsUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentAwsCredentialUpdate: async (uuid: string, environmentCredentialAwsUpdate?: EnvironmentCredentialAwsUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('environmentAwsCredentialUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/infrastructure/environment-credentials/aws/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentCredentialAwsUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InfrastructureContentEnvironmentAWSCredentialsApi - functional programming interface
 * @export
 */
export const InfrastructureContentEnvironmentAWSCredentialsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InfrastructureContentEnvironmentAWSCredentialsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create an AWS environment credential
         * @param {EnvironmentCredentialAwsCreate} [environmentCredentialAwsCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentAwsCredentialCreate(environmentCredentialAwsCreate?: EnvironmentCredentialAwsCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentCredentialAws>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentAwsCredentialCreate(environmentCredentialAwsCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfrastructureContentEnvironmentAWSCredentialsApi.environmentAwsCredentialCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an AWS environment credential
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentAwsCredentialDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentAwsCredentialDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfrastructureContentEnvironmentAWSCredentialsApi.environmentAwsCredentialDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing AWS environment credentials
         * @param {string} [name] 
         * @param {string} [author] 
         * @param {string} [description] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {EnvironmentAwsCredentialListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {EnvironmentAwsCredentialListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentAwsCredentialList(name?: string, author?: string, description?: string, offset?: number, limit?: number, search?: string, sortBy?: EnvironmentAwsCredentialListSortByEnum, sort?: EnvironmentAwsCredentialListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentAwsCredentialList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentAwsCredentialList(name, author, description, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfrastructureContentEnvironmentAWSCredentialsApi.environmentAwsCredentialList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an AWS environment credential
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentAwsCredentialRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentCredentialAws>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentAwsCredentialRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfrastructureContentEnvironmentAWSCredentialsApi.environmentAwsCredentialRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an AWS environment credential
         * @param {string} uuid 
         * @param {EnvironmentCredentialAwsUpdate} [environmentCredentialAwsUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentAwsCredentialUpdate(uuid: string, environmentCredentialAwsUpdate?: EnvironmentCredentialAwsUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentCredentialAws>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentAwsCredentialUpdate(uuid, environmentCredentialAwsUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfrastructureContentEnvironmentAWSCredentialsApi.environmentAwsCredentialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InfrastructureContentEnvironmentAWSCredentialsApi - factory interface
 * @export
 */
export const InfrastructureContentEnvironmentAWSCredentialsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InfrastructureContentEnvironmentAWSCredentialsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create an AWS environment credential
         * @param {EnvironmentCredentialAwsCreate} [environmentCredentialAwsCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentAwsCredentialCreate(environmentCredentialAwsCreate?: EnvironmentCredentialAwsCreate, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentCredentialAws> {
            return localVarFp.environmentAwsCredentialCreate(environmentCredentialAwsCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an AWS environment credential
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentAwsCredentialDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.environmentAwsCredentialDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing AWS environment credentials
         * @param {string} [name] 
         * @param {string} [author] 
         * @param {string} [description] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {EnvironmentAwsCredentialListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {EnvironmentAwsCredentialListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentAwsCredentialList(name?: string, author?: string, description?: string, offset?: number, limit?: number, search?: string, sortBy?: EnvironmentAwsCredentialListSortByEnum, sort?: EnvironmentAwsCredentialListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentAwsCredentialList200Response> {
            return localVarFp.environmentAwsCredentialList(name, author, description, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an AWS environment credential
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentAwsCredentialRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentCredentialAws> {
            return localVarFp.environmentAwsCredentialRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an AWS environment credential
         * @param {string} uuid 
         * @param {EnvironmentCredentialAwsUpdate} [environmentCredentialAwsUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentAwsCredentialUpdate(uuid: string, environmentCredentialAwsUpdate?: EnvironmentCredentialAwsUpdate, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentCredentialAws> {
            return localVarFp.environmentAwsCredentialUpdate(uuid, environmentCredentialAwsUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InfrastructureContentEnvironmentAWSCredentialsApi - object-oriented interface
 * @export
 * @class InfrastructureContentEnvironmentAWSCredentialsApi
 * @extends {BaseAPI}
 */
export class InfrastructureContentEnvironmentAWSCredentialsApi extends BaseAPI {
    /**
     * 
     * @summary Create an AWS environment credential
     * @param {EnvironmentCredentialAwsCreate} [environmentCredentialAwsCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfrastructureContentEnvironmentAWSCredentialsApi
     */
    public environmentAwsCredentialCreate(environmentCredentialAwsCreate?: EnvironmentCredentialAwsCreate, options?: RawAxiosRequestConfig) {
        return InfrastructureContentEnvironmentAWSCredentialsApiFp(this.configuration).environmentAwsCredentialCreate(environmentCredentialAwsCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an AWS environment credential
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfrastructureContentEnvironmentAWSCredentialsApi
     */
    public environmentAwsCredentialDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return InfrastructureContentEnvironmentAWSCredentialsApiFp(this.configuration).environmentAwsCredentialDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing AWS environment credentials
     * @param {string} [name] 
     * @param {string} [author] 
     * @param {string} [description] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {EnvironmentAwsCredentialListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {EnvironmentAwsCredentialListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfrastructureContentEnvironmentAWSCredentialsApi
     */
    public environmentAwsCredentialList(name?: string, author?: string, description?: string, offset?: number, limit?: number, search?: string, sortBy?: EnvironmentAwsCredentialListSortByEnum, sort?: EnvironmentAwsCredentialListSortEnum, options?: RawAxiosRequestConfig) {
        return InfrastructureContentEnvironmentAWSCredentialsApiFp(this.configuration).environmentAwsCredentialList(name, author, description, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an AWS environment credential
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfrastructureContentEnvironmentAWSCredentialsApi
     */
    public environmentAwsCredentialRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return InfrastructureContentEnvironmentAWSCredentialsApiFp(this.configuration).environmentAwsCredentialRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an AWS environment credential
     * @param {string} uuid 
     * @param {EnvironmentCredentialAwsUpdate} [environmentCredentialAwsUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfrastructureContentEnvironmentAWSCredentialsApi
     */
    public environmentAwsCredentialUpdate(uuid: string, environmentCredentialAwsUpdate?: EnvironmentCredentialAwsUpdate, options?: RawAxiosRequestConfig) {
        return InfrastructureContentEnvironmentAWSCredentialsApiFp(this.configuration).environmentAwsCredentialUpdate(uuid, environmentCredentialAwsUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const EnvironmentAwsCredentialListSortByEnum = {
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Name: 'name',
    Author: 'author'
} as const;
export type EnvironmentAwsCredentialListSortByEnum = typeof EnvironmentAwsCredentialListSortByEnum[keyof typeof EnvironmentAwsCredentialListSortByEnum];
/**
 * @export
 */
export const EnvironmentAwsCredentialListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type EnvironmentAwsCredentialListSortEnum = typeof EnvironmentAwsCredentialListSortEnum[keyof typeof EnvironmentAwsCredentialListSortEnum];


/**
 * InfrastructureContentEnvironmentAWSSpecificationsApi - axios parameter creator
 * @export
 */
export const InfrastructureContentEnvironmentAWSSpecificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an AWS environment specification
         * @param {EnvironmentSpecificationAwsCreate} [environmentSpecificationAwsCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentAwsSpecificationCreate: async (environmentSpecificationAwsCreate?: EnvironmentSpecificationAwsCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/infrastructure/environment-specifications/aws`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentSpecificationAwsCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an AWS environment specification
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentAwsSpecificationDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('environmentAwsSpecificationDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/infrastructure/environment-specifications/aws/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing AWS environment specifications
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [awsAvailabilityZone] 
         * @param {string} [awsRegion] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {EnvironmentAwsSpecificationListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {EnvironmentAwsSpecificationListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentAwsSpecificationList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, awsAvailabilityZone?: string, awsRegion?: string, offset?: number, limit?: number, search?: string, sortBy?: EnvironmentAwsSpecificationListSortByEnum, sort?: EnvironmentAwsSpecificationListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/infrastructure/environment-specifications/aws`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (awsAvailabilityZone !== undefined) {
                localVarQueryParameter['awsAvailabilityZone'] = awsAvailabilityZone;
            }

            if (awsRegion !== undefined) {
                localVarQueryParameter['awsRegion'] = awsRegion;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an AWS environment specification
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentAwsSpecificationRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('environmentAwsSpecificationRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/infrastructure/environment-specifications/aws/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an AWS environment specification
         * @param {string} uuid 
         * @param {EnvironmentSpecificationAwsUpdate} [environmentSpecificationAwsUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentAwsSpecificationUpdate: async (uuid: string, environmentSpecificationAwsUpdate?: EnvironmentSpecificationAwsUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('environmentAwsSpecificationUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/infrastructure/environment-specifications/aws/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentSpecificationAwsUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InfrastructureContentEnvironmentAWSSpecificationsApi - functional programming interface
 * @export
 */
export const InfrastructureContentEnvironmentAWSSpecificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InfrastructureContentEnvironmentAWSSpecificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create an AWS environment specification
         * @param {EnvironmentSpecificationAwsCreate} [environmentSpecificationAwsCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentAwsSpecificationCreate(environmentSpecificationAwsCreate?: EnvironmentSpecificationAwsCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentSpecificationAws>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentAwsSpecificationCreate(environmentSpecificationAwsCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfrastructureContentEnvironmentAWSSpecificationsApi.environmentAwsSpecificationCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an AWS environment specification
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentAwsSpecificationDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentAwsSpecificationDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfrastructureContentEnvironmentAWSSpecificationsApi.environmentAwsSpecificationDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing AWS environment specifications
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [awsAvailabilityZone] 
         * @param {string} [awsRegion] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {EnvironmentAwsSpecificationListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {EnvironmentAwsSpecificationListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentAwsSpecificationList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, awsAvailabilityZone?: string, awsRegion?: string, offset?: number, limit?: number, search?: string, sortBy?: EnvironmentAwsSpecificationListSortByEnum, sort?: EnvironmentAwsSpecificationListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentAwsSpecificationList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentAwsSpecificationList(uuid, name, description, author, metadata, awsAvailabilityZone, awsRegion, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfrastructureContentEnvironmentAWSSpecificationsApi.environmentAwsSpecificationList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an AWS environment specification
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentAwsSpecificationRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentSpecificationAws>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentAwsSpecificationRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfrastructureContentEnvironmentAWSSpecificationsApi.environmentAwsSpecificationRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an AWS environment specification
         * @param {string} uuid 
         * @param {EnvironmentSpecificationAwsUpdate} [environmentSpecificationAwsUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentAwsSpecificationUpdate(uuid: string, environmentSpecificationAwsUpdate?: EnvironmentSpecificationAwsUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentSpecificationAws>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentAwsSpecificationUpdate(uuid, environmentSpecificationAwsUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfrastructureContentEnvironmentAWSSpecificationsApi.environmentAwsSpecificationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InfrastructureContentEnvironmentAWSSpecificationsApi - factory interface
 * @export
 */
export const InfrastructureContentEnvironmentAWSSpecificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InfrastructureContentEnvironmentAWSSpecificationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create an AWS environment specification
         * @param {EnvironmentSpecificationAwsCreate} [environmentSpecificationAwsCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentAwsSpecificationCreate(environmentSpecificationAwsCreate?: EnvironmentSpecificationAwsCreate, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentSpecificationAws> {
            return localVarFp.environmentAwsSpecificationCreate(environmentSpecificationAwsCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an AWS environment specification
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentAwsSpecificationDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.environmentAwsSpecificationDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing AWS environment specifications
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [awsAvailabilityZone] 
         * @param {string} [awsRegion] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {EnvironmentAwsSpecificationListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {EnvironmentAwsSpecificationListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentAwsSpecificationList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, awsAvailabilityZone?: string, awsRegion?: string, offset?: number, limit?: number, search?: string, sortBy?: EnvironmentAwsSpecificationListSortByEnum, sort?: EnvironmentAwsSpecificationListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentAwsSpecificationList200Response> {
            return localVarFp.environmentAwsSpecificationList(uuid, name, description, author, metadata, awsAvailabilityZone, awsRegion, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an AWS environment specification
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentAwsSpecificationRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentSpecificationAws> {
            return localVarFp.environmentAwsSpecificationRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an AWS environment specification
         * @param {string} uuid 
         * @param {EnvironmentSpecificationAwsUpdate} [environmentSpecificationAwsUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentAwsSpecificationUpdate(uuid: string, environmentSpecificationAwsUpdate?: EnvironmentSpecificationAwsUpdate, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentSpecificationAws> {
            return localVarFp.environmentAwsSpecificationUpdate(uuid, environmentSpecificationAwsUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InfrastructureContentEnvironmentAWSSpecificationsApi - object-oriented interface
 * @export
 * @class InfrastructureContentEnvironmentAWSSpecificationsApi
 * @extends {BaseAPI}
 */
export class InfrastructureContentEnvironmentAWSSpecificationsApi extends BaseAPI {
    /**
     * 
     * @summary Create an AWS environment specification
     * @param {EnvironmentSpecificationAwsCreate} [environmentSpecificationAwsCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfrastructureContentEnvironmentAWSSpecificationsApi
     */
    public environmentAwsSpecificationCreate(environmentSpecificationAwsCreate?: EnvironmentSpecificationAwsCreate, options?: RawAxiosRequestConfig) {
        return InfrastructureContentEnvironmentAWSSpecificationsApiFp(this.configuration).environmentAwsSpecificationCreate(environmentSpecificationAwsCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an AWS environment specification
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfrastructureContentEnvironmentAWSSpecificationsApi
     */
    public environmentAwsSpecificationDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return InfrastructureContentEnvironmentAWSSpecificationsApiFp(this.configuration).environmentAwsSpecificationDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing AWS environment specifications
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {string} [awsAvailabilityZone] 
     * @param {string} [awsRegion] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {EnvironmentAwsSpecificationListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {EnvironmentAwsSpecificationListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfrastructureContentEnvironmentAWSSpecificationsApi
     */
    public environmentAwsSpecificationList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, awsAvailabilityZone?: string, awsRegion?: string, offset?: number, limit?: number, search?: string, sortBy?: EnvironmentAwsSpecificationListSortByEnum, sort?: EnvironmentAwsSpecificationListSortEnum, options?: RawAxiosRequestConfig) {
        return InfrastructureContentEnvironmentAWSSpecificationsApiFp(this.configuration).environmentAwsSpecificationList(uuid, name, description, author, metadata, awsAvailabilityZone, awsRegion, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an AWS environment specification
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfrastructureContentEnvironmentAWSSpecificationsApi
     */
    public environmentAwsSpecificationRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return InfrastructureContentEnvironmentAWSSpecificationsApiFp(this.configuration).environmentAwsSpecificationRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an AWS environment specification
     * @param {string} uuid 
     * @param {EnvironmentSpecificationAwsUpdate} [environmentSpecificationAwsUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfrastructureContentEnvironmentAWSSpecificationsApi
     */
    public environmentAwsSpecificationUpdate(uuid: string, environmentSpecificationAwsUpdate?: EnvironmentSpecificationAwsUpdate, options?: RawAxiosRequestConfig) {
        return InfrastructureContentEnvironmentAWSSpecificationsApiFp(this.configuration).environmentAwsSpecificationUpdate(uuid, environmentSpecificationAwsUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const EnvironmentAwsSpecificationListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author',
    AwsAvailabilityZone: 'awsAvailabilityZone',
    AwsRegion: 'awsRegion'
} as const;
export type EnvironmentAwsSpecificationListSortByEnum = typeof EnvironmentAwsSpecificationListSortByEnum[keyof typeof EnvironmentAwsSpecificationListSortByEnum];
/**
 * @export
 */
export const EnvironmentAwsSpecificationListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type EnvironmentAwsSpecificationListSortEnum = typeof EnvironmentAwsSpecificationListSortEnum[keyof typeof EnvironmentAwsSpecificationListSortEnum];


/**
 * InfrastructureContentEnvironmentRancherCredentialsApi - axios parameter creator
 * @export
 */
export const InfrastructureContentEnvironmentRancherCredentialsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a Rancher environment credential
         * @param {EnvironmentCredentialRancherCreate} [environmentCredentialRancherCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentRancherCredentialCreate: async (environmentCredentialRancherCreate?: EnvironmentCredentialRancherCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/infrastructure/environment-credentials/rancher`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentCredentialRancherCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Rancher environment credential
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentRancherCredentialDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('environmentRancherCredentialDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/infrastructure/environment-credentials/rancher/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing Rancher environment credentials
         * @param {string} [name] 
         * @param {string} [author] 
         * @param {string} [description] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {EnvironmentRancherCredentialListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {EnvironmentRancherCredentialListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentRancherCredentialList: async (name?: string, author?: string, description?: string, offset?: number, limit?: number, search?: string, sortBy?: EnvironmentRancherCredentialListSortByEnum, sort?: EnvironmentRancherCredentialListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/infrastructure/environment-credentials/rancher`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a Rancher environment credential
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentRancherCredentialRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('environmentRancherCredentialRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/infrastructure/environment-credentials/rancher/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Rancher environment credential
         * @param {string} uuid 
         * @param {EnvironmentCredentialRancherUpdate} [environmentCredentialRancherUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentRancherCredentialUpdate: async (uuid: string, environmentCredentialRancherUpdate?: EnvironmentCredentialRancherUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('environmentRancherCredentialUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/infrastructure/environment-credentials/rancher/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentCredentialRancherUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InfrastructureContentEnvironmentRancherCredentialsApi - functional programming interface
 * @export
 */
export const InfrastructureContentEnvironmentRancherCredentialsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InfrastructureContentEnvironmentRancherCredentialsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a Rancher environment credential
         * @param {EnvironmentCredentialRancherCreate} [environmentCredentialRancherCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentRancherCredentialCreate(environmentCredentialRancherCreate?: EnvironmentCredentialRancherCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentCredentialRancher>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentRancherCredentialCreate(environmentCredentialRancherCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfrastructureContentEnvironmentRancherCredentialsApi.environmentRancherCredentialCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a Rancher environment credential
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentRancherCredentialDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentRancherCredentialDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfrastructureContentEnvironmentRancherCredentialsApi.environmentRancherCredentialDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing Rancher environment credentials
         * @param {string} [name] 
         * @param {string} [author] 
         * @param {string} [description] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {EnvironmentRancherCredentialListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {EnvironmentRancherCredentialListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentRancherCredentialList(name?: string, author?: string, description?: string, offset?: number, limit?: number, search?: string, sortBy?: EnvironmentRancherCredentialListSortByEnum, sort?: EnvironmentRancherCredentialListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentRancherCredentialList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentRancherCredentialList(name, author, description, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfrastructureContentEnvironmentRancherCredentialsApi.environmentRancherCredentialList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a Rancher environment credential
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentRancherCredentialRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentCredentialRancher>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentRancherCredentialRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfrastructureContentEnvironmentRancherCredentialsApi.environmentRancherCredentialRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a Rancher environment credential
         * @param {string} uuid 
         * @param {EnvironmentCredentialRancherUpdate} [environmentCredentialRancherUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentRancherCredentialUpdate(uuid: string, environmentCredentialRancherUpdate?: EnvironmentCredentialRancherUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentCredentialRancher>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentRancherCredentialUpdate(uuid, environmentCredentialRancherUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfrastructureContentEnvironmentRancherCredentialsApi.environmentRancherCredentialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InfrastructureContentEnvironmentRancherCredentialsApi - factory interface
 * @export
 */
export const InfrastructureContentEnvironmentRancherCredentialsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InfrastructureContentEnvironmentRancherCredentialsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a Rancher environment credential
         * @param {EnvironmentCredentialRancherCreate} [environmentCredentialRancherCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentRancherCredentialCreate(environmentCredentialRancherCreate?: EnvironmentCredentialRancherCreate, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentCredentialRancher> {
            return localVarFp.environmentRancherCredentialCreate(environmentCredentialRancherCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Rancher environment credential
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentRancherCredentialDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.environmentRancherCredentialDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing Rancher environment credentials
         * @param {string} [name] 
         * @param {string} [author] 
         * @param {string} [description] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {EnvironmentRancherCredentialListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {EnvironmentRancherCredentialListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentRancherCredentialList(name?: string, author?: string, description?: string, offset?: number, limit?: number, search?: string, sortBy?: EnvironmentRancherCredentialListSortByEnum, sort?: EnvironmentRancherCredentialListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentRancherCredentialList200Response> {
            return localVarFp.environmentRancherCredentialList(name, author, description, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a Rancher environment credential
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentRancherCredentialRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentCredentialRancher> {
            return localVarFp.environmentRancherCredentialRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Rancher environment credential
         * @param {string} uuid 
         * @param {EnvironmentCredentialRancherUpdate} [environmentCredentialRancherUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentRancherCredentialUpdate(uuid: string, environmentCredentialRancherUpdate?: EnvironmentCredentialRancherUpdate, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentCredentialRancher> {
            return localVarFp.environmentRancherCredentialUpdate(uuid, environmentCredentialRancherUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InfrastructureContentEnvironmentRancherCredentialsApi - object-oriented interface
 * @export
 * @class InfrastructureContentEnvironmentRancherCredentialsApi
 * @extends {BaseAPI}
 */
export class InfrastructureContentEnvironmentRancherCredentialsApi extends BaseAPI {
    /**
     * 
     * @summary Create a Rancher environment credential
     * @param {EnvironmentCredentialRancherCreate} [environmentCredentialRancherCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfrastructureContentEnvironmentRancherCredentialsApi
     */
    public environmentRancherCredentialCreate(environmentCredentialRancherCreate?: EnvironmentCredentialRancherCreate, options?: RawAxiosRequestConfig) {
        return InfrastructureContentEnvironmentRancherCredentialsApiFp(this.configuration).environmentRancherCredentialCreate(environmentCredentialRancherCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Rancher environment credential
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfrastructureContentEnvironmentRancherCredentialsApi
     */
    public environmentRancherCredentialDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return InfrastructureContentEnvironmentRancherCredentialsApiFp(this.configuration).environmentRancherCredentialDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing Rancher environment credentials
     * @param {string} [name] 
     * @param {string} [author] 
     * @param {string} [description] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {EnvironmentRancherCredentialListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {EnvironmentRancherCredentialListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfrastructureContentEnvironmentRancherCredentialsApi
     */
    public environmentRancherCredentialList(name?: string, author?: string, description?: string, offset?: number, limit?: number, search?: string, sortBy?: EnvironmentRancherCredentialListSortByEnum, sort?: EnvironmentRancherCredentialListSortEnum, options?: RawAxiosRequestConfig) {
        return InfrastructureContentEnvironmentRancherCredentialsApiFp(this.configuration).environmentRancherCredentialList(name, author, description, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a Rancher environment credential
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfrastructureContentEnvironmentRancherCredentialsApi
     */
    public environmentRancherCredentialRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return InfrastructureContentEnvironmentRancherCredentialsApiFp(this.configuration).environmentRancherCredentialRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Rancher environment credential
     * @param {string} uuid 
     * @param {EnvironmentCredentialRancherUpdate} [environmentCredentialRancherUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfrastructureContentEnvironmentRancherCredentialsApi
     */
    public environmentRancherCredentialUpdate(uuid: string, environmentCredentialRancherUpdate?: EnvironmentCredentialRancherUpdate, options?: RawAxiosRequestConfig) {
        return InfrastructureContentEnvironmentRancherCredentialsApiFp(this.configuration).environmentRancherCredentialUpdate(uuid, environmentCredentialRancherUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const EnvironmentRancherCredentialListSortByEnum = {
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Name: 'name',
    Author: 'author'
} as const;
export type EnvironmentRancherCredentialListSortByEnum = typeof EnvironmentRancherCredentialListSortByEnum[keyof typeof EnvironmentRancherCredentialListSortByEnum];
/**
 * @export
 */
export const EnvironmentRancherCredentialListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type EnvironmentRancherCredentialListSortEnum = typeof EnvironmentRancherCredentialListSortEnum[keyof typeof EnvironmentRancherCredentialListSortEnum];


/**
 * InfrastructureContentEnvironmentVsphereCredentialsApi - axios parameter creator
 * @export
 */
export const InfrastructureContentEnvironmentVsphereCredentialsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a Vsphere environment credential
         * @param {EnvironmentCredentialVsphereCreate} [environmentCredentialVsphereCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentVsphereCredentialCreate: async (environmentCredentialVsphereCreate?: EnvironmentCredentialVsphereCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/infrastructure/environment-credentials/vsphere`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentCredentialVsphereCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Vsphere environment credential
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentVsphereCredentialDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('environmentVsphereCredentialDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/infrastructure/environment-credentials/vsphere/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing Vsphere environment credentials
         * @param {string} [name] 
         * @param {string} [author] 
         * @param {string} [description] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {EnvironmentVsphereCredentialListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {EnvironmentVsphereCredentialListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentVsphereCredentialList: async (name?: string, author?: string, description?: string, offset?: number, limit?: number, search?: string, sortBy?: EnvironmentVsphereCredentialListSortByEnum, sort?: EnvironmentVsphereCredentialListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/infrastructure/environment-credentials/vsphere`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a Vsphere environment credential
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentVsphereCredentialRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('environmentVsphereCredentialRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/infrastructure/environment-credentials/vsphere/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Vsphere environment credential
         * @param {string} uuid 
         * @param {EnvironmentCredentialVsphereUpdate} [environmentCredentialVsphereUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentVsphereCredentialUpdate: async (uuid: string, environmentCredentialVsphereUpdate?: EnvironmentCredentialVsphereUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('environmentVsphereCredentialUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/infrastructure/environment-credentials/vsphere/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentCredentialVsphereUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InfrastructureContentEnvironmentVsphereCredentialsApi - functional programming interface
 * @export
 */
export const InfrastructureContentEnvironmentVsphereCredentialsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InfrastructureContentEnvironmentVsphereCredentialsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a Vsphere environment credential
         * @param {EnvironmentCredentialVsphereCreate} [environmentCredentialVsphereCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentVsphereCredentialCreate(environmentCredentialVsphereCreate?: EnvironmentCredentialVsphereCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentCredentialVsphere>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentVsphereCredentialCreate(environmentCredentialVsphereCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfrastructureContentEnvironmentVsphereCredentialsApi.environmentVsphereCredentialCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a Vsphere environment credential
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentVsphereCredentialDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentVsphereCredentialDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfrastructureContentEnvironmentVsphereCredentialsApi.environmentVsphereCredentialDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing Vsphere environment credentials
         * @param {string} [name] 
         * @param {string} [author] 
         * @param {string} [description] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {EnvironmentVsphereCredentialListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {EnvironmentVsphereCredentialListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentVsphereCredentialList(name?: string, author?: string, description?: string, offset?: number, limit?: number, search?: string, sortBy?: EnvironmentVsphereCredentialListSortByEnum, sort?: EnvironmentVsphereCredentialListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentVsphereCredentialList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentVsphereCredentialList(name, author, description, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfrastructureContentEnvironmentVsphereCredentialsApi.environmentVsphereCredentialList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a Vsphere environment credential
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentVsphereCredentialRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentCredentialVsphere>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentVsphereCredentialRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfrastructureContentEnvironmentVsphereCredentialsApi.environmentVsphereCredentialRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a Vsphere environment credential
         * @param {string} uuid 
         * @param {EnvironmentCredentialVsphereUpdate} [environmentCredentialVsphereUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentVsphereCredentialUpdate(uuid: string, environmentCredentialVsphereUpdate?: EnvironmentCredentialVsphereUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentCredentialVsphere>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentVsphereCredentialUpdate(uuid, environmentCredentialVsphereUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfrastructureContentEnvironmentVsphereCredentialsApi.environmentVsphereCredentialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InfrastructureContentEnvironmentVsphereCredentialsApi - factory interface
 * @export
 */
export const InfrastructureContentEnvironmentVsphereCredentialsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InfrastructureContentEnvironmentVsphereCredentialsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a Vsphere environment credential
         * @param {EnvironmentCredentialVsphereCreate} [environmentCredentialVsphereCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentVsphereCredentialCreate(environmentCredentialVsphereCreate?: EnvironmentCredentialVsphereCreate, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentCredentialVsphere> {
            return localVarFp.environmentVsphereCredentialCreate(environmentCredentialVsphereCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Vsphere environment credential
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentVsphereCredentialDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.environmentVsphereCredentialDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing Vsphere environment credentials
         * @param {string} [name] 
         * @param {string} [author] 
         * @param {string} [description] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {EnvironmentVsphereCredentialListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {EnvironmentVsphereCredentialListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentVsphereCredentialList(name?: string, author?: string, description?: string, offset?: number, limit?: number, search?: string, sortBy?: EnvironmentVsphereCredentialListSortByEnum, sort?: EnvironmentVsphereCredentialListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentVsphereCredentialList200Response> {
            return localVarFp.environmentVsphereCredentialList(name, author, description, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a Vsphere environment credential
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentVsphereCredentialRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentCredentialVsphere> {
            return localVarFp.environmentVsphereCredentialRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Vsphere environment credential
         * @param {string} uuid 
         * @param {EnvironmentCredentialVsphereUpdate} [environmentCredentialVsphereUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentVsphereCredentialUpdate(uuid: string, environmentCredentialVsphereUpdate?: EnvironmentCredentialVsphereUpdate, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentCredentialVsphere> {
            return localVarFp.environmentVsphereCredentialUpdate(uuid, environmentCredentialVsphereUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InfrastructureContentEnvironmentVsphereCredentialsApi - object-oriented interface
 * @export
 * @class InfrastructureContentEnvironmentVsphereCredentialsApi
 * @extends {BaseAPI}
 */
export class InfrastructureContentEnvironmentVsphereCredentialsApi extends BaseAPI {
    /**
     * 
     * @summary Create a Vsphere environment credential
     * @param {EnvironmentCredentialVsphereCreate} [environmentCredentialVsphereCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfrastructureContentEnvironmentVsphereCredentialsApi
     */
    public environmentVsphereCredentialCreate(environmentCredentialVsphereCreate?: EnvironmentCredentialVsphereCreate, options?: RawAxiosRequestConfig) {
        return InfrastructureContentEnvironmentVsphereCredentialsApiFp(this.configuration).environmentVsphereCredentialCreate(environmentCredentialVsphereCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Vsphere environment credential
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfrastructureContentEnvironmentVsphereCredentialsApi
     */
    public environmentVsphereCredentialDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return InfrastructureContentEnvironmentVsphereCredentialsApiFp(this.configuration).environmentVsphereCredentialDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing Vsphere environment credentials
     * @param {string} [name] 
     * @param {string} [author] 
     * @param {string} [description] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {EnvironmentVsphereCredentialListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {EnvironmentVsphereCredentialListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfrastructureContentEnvironmentVsphereCredentialsApi
     */
    public environmentVsphereCredentialList(name?: string, author?: string, description?: string, offset?: number, limit?: number, search?: string, sortBy?: EnvironmentVsphereCredentialListSortByEnum, sort?: EnvironmentVsphereCredentialListSortEnum, options?: RawAxiosRequestConfig) {
        return InfrastructureContentEnvironmentVsphereCredentialsApiFp(this.configuration).environmentVsphereCredentialList(name, author, description, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a Vsphere environment credential
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfrastructureContentEnvironmentVsphereCredentialsApi
     */
    public environmentVsphereCredentialRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return InfrastructureContentEnvironmentVsphereCredentialsApiFp(this.configuration).environmentVsphereCredentialRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Vsphere environment credential
     * @param {string} uuid 
     * @param {EnvironmentCredentialVsphereUpdate} [environmentCredentialVsphereUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfrastructureContentEnvironmentVsphereCredentialsApi
     */
    public environmentVsphereCredentialUpdate(uuid: string, environmentCredentialVsphereUpdate?: EnvironmentCredentialVsphereUpdate, options?: RawAxiosRequestConfig) {
        return InfrastructureContentEnvironmentVsphereCredentialsApiFp(this.configuration).environmentVsphereCredentialUpdate(uuid, environmentCredentialVsphereUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const EnvironmentVsphereCredentialListSortByEnum = {
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Name: 'name',
    Author: 'author'
} as const;
export type EnvironmentVsphereCredentialListSortByEnum = typeof EnvironmentVsphereCredentialListSortByEnum[keyof typeof EnvironmentVsphereCredentialListSortByEnum];
/**
 * @export
 */
export const EnvironmentVsphereCredentialListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type EnvironmentVsphereCredentialListSortEnum = typeof EnvironmentVsphereCredentialListSortEnum[keyof typeof EnvironmentVsphereCredentialListSortEnum];


/**
 * InfrastructureContentRangeAWSSpecificationsApi - axios parameter creator
 * @export
 */
export const InfrastructureContentRangeAWSSpecificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an AWS range specification
         * @param {RangeSpecificationAwsCreate} [rangeSpecificationAwsCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeAwsSpecificationCreate: async (rangeSpecificationAwsCreate?: RangeSpecificationAwsCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/infrastructure/range-specifications/aws`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeSpecificationAwsCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an AWS range specification
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeAwsSpecificationDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeAwsSpecificationDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/infrastructure/range-specifications/aws/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing AWS range specifications
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeAwsSpecificationListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeAwsSpecificationListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeAwsSpecificationList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: RangeAwsSpecificationListSortByEnum, sort?: RangeAwsSpecificationListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/infrastructure/range-specifications/aws`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an AWS range specification
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeAwsSpecificationRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeAwsSpecificationRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/infrastructure/range-specifications/aws/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an AWS range specification
         * @param {string} uuid 
         * @param {RangeSpecificationAwsUpdate} [rangeSpecificationAwsUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeAwsSpecificationUpdate: async (uuid: string, rangeSpecificationAwsUpdate?: RangeSpecificationAwsUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeAwsSpecificationUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/infrastructure/range-specifications/aws/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeSpecificationAwsUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InfrastructureContentRangeAWSSpecificationsApi - functional programming interface
 * @export
 */
export const InfrastructureContentRangeAWSSpecificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InfrastructureContentRangeAWSSpecificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create an AWS range specification
         * @param {RangeSpecificationAwsCreate} [rangeSpecificationAwsCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeAwsSpecificationCreate(rangeSpecificationAwsCreate?: RangeSpecificationAwsCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeSpecificationAws>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeAwsSpecificationCreate(rangeSpecificationAwsCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfrastructureContentRangeAWSSpecificationsApi.rangeAwsSpecificationCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an AWS range specification
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeAwsSpecificationDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeAwsSpecificationDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfrastructureContentRangeAWSSpecificationsApi.rangeAwsSpecificationDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing AWS range specifications
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeAwsSpecificationListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeAwsSpecificationListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeAwsSpecificationList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: RangeAwsSpecificationListSortByEnum, sort?: RangeAwsSpecificationListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeAwsSpecificationList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeAwsSpecificationList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfrastructureContentRangeAWSSpecificationsApi.rangeAwsSpecificationList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an AWS range specification
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeAwsSpecificationRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeSpecificationAws>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeAwsSpecificationRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfrastructureContentRangeAWSSpecificationsApi.rangeAwsSpecificationRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an AWS range specification
         * @param {string} uuid 
         * @param {RangeSpecificationAwsUpdate} [rangeSpecificationAwsUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeAwsSpecificationUpdate(uuid: string, rangeSpecificationAwsUpdate?: RangeSpecificationAwsUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeSpecificationAws>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeAwsSpecificationUpdate(uuid, rangeSpecificationAwsUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfrastructureContentRangeAWSSpecificationsApi.rangeAwsSpecificationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InfrastructureContentRangeAWSSpecificationsApi - factory interface
 * @export
 */
export const InfrastructureContentRangeAWSSpecificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InfrastructureContentRangeAWSSpecificationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create an AWS range specification
         * @param {RangeSpecificationAwsCreate} [rangeSpecificationAwsCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeAwsSpecificationCreate(rangeSpecificationAwsCreate?: RangeSpecificationAwsCreate, options?: RawAxiosRequestConfig): AxiosPromise<RangeSpecificationAws> {
            return localVarFp.rangeAwsSpecificationCreate(rangeSpecificationAwsCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an AWS range specification
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeAwsSpecificationDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rangeAwsSpecificationDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing AWS range specifications
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeAwsSpecificationListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeAwsSpecificationListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeAwsSpecificationList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: RangeAwsSpecificationListSortByEnum, sort?: RangeAwsSpecificationListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<RangeAwsSpecificationList200Response> {
            return localVarFp.rangeAwsSpecificationList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an AWS range specification
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeAwsSpecificationRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<RangeSpecificationAws> {
            return localVarFp.rangeAwsSpecificationRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an AWS range specification
         * @param {string} uuid 
         * @param {RangeSpecificationAwsUpdate} [rangeSpecificationAwsUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeAwsSpecificationUpdate(uuid: string, rangeSpecificationAwsUpdate?: RangeSpecificationAwsUpdate, options?: RawAxiosRequestConfig): AxiosPromise<RangeSpecificationAws> {
            return localVarFp.rangeAwsSpecificationUpdate(uuid, rangeSpecificationAwsUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InfrastructureContentRangeAWSSpecificationsApi - object-oriented interface
 * @export
 * @class InfrastructureContentRangeAWSSpecificationsApi
 * @extends {BaseAPI}
 */
export class InfrastructureContentRangeAWSSpecificationsApi extends BaseAPI {
    /**
     * 
     * @summary Create an AWS range specification
     * @param {RangeSpecificationAwsCreate} [rangeSpecificationAwsCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfrastructureContentRangeAWSSpecificationsApi
     */
    public rangeAwsSpecificationCreate(rangeSpecificationAwsCreate?: RangeSpecificationAwsCreate, options?: RawAxiosRequestConfig) {
        return InfrastructureContentRangeAWSSpecificationsApiFp(this.configuration).rangeAwsSpecificationCreate(rangeSpecificationAwsCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an AWS range specification
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfrastructureContentRangeAWSSpecificationsApi
     */
    public rangeAwsSpecificationDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return InfrastructureContentRangeAWSSpecificationsApiFp(this.configuration).rangeAwsSpecificationDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing AWS range specifications
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {RangeAwsSpecificationListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {RangeAwsSpecificationListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfrastructureContentRangeAWSSpecificationsApi
     */
    public rangeAwsSpecificationList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: RangeAwsSpecificationListSortByEnum, sort?: RangeAwsSpecificationListSortEnum, options?: RawAxiosRequestConfig) {
        return InfrastructureContentRangeAWSSpecificationsApiFp(this.configuration).rangeAwsSpecificationList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an AWS range specification
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfrastructureContentRangeAWSSpecificationsApi
     */
    public rangeAwsSpecificationRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return InfrastructureContentRangeAWSSpecificationsApiFp(this.configuration).rangeAwsSpecificationRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an AWS range specification
     * @param {string} uuid 
     * @param {RangeSpecificationAwsUpdate} [rangeSpecificationAwsUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfrastructureContentRangeAWSSpecificationsApi
     */
    public rangeAwsSpecificationUpdate(uuid: string, rangeSpecificationAwsUpdate?: RangeSpecificationAwsUpdate, options?: RawAxiosRequestConfig) {
        return InfrastructureContentRangeAWSSpecificationsApiFp(this.configuration).rangeAwsSpecificationUpdate(uuid, rangeSpecificationAwsUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RangeAwsSpecificationListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author'
} as const;
export type RangeAwsSpecificationListSortByEnum = typeof RangeAwsSpecificationListSortByEnum[keyof typeof RangeAwsSpecificationListSortByEnum];
/**
 * @export
 */
export const RangeAwsSpecificationListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type RangeAwsSpecificationListSortEnum = typeof RangeAwsSpecificationListSortEnum[keyof typeof RangeAwsSpecificationListSortEnum];


/**
 * InfrastructureContentRangeVsphereSpecificationsApi - axios parameter creator
 * @export
 */
export const InfrastructureContentRangeVsphereSpecificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a Vsphere range specification
         * @param {RangeSpecificationVsphereCreate} [rangeSpecificationVsphereCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeVsphereSpecificationCreate: async (rangeSpecificationVsphereCreate?: RangeSpecificationVsphereCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/infrastructure/range-specifications/vsphere`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeSpecificationVsphereCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Vsphere range specification
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeVsphereSpecificationDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeVsphereSpecificationDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/infrastructure/range-specifications/vsphere/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing Vsphere range specifications
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeVsphereSpecificationListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeVsphereSpecificationListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeVsphereSpecificationList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: RangeVsphereSpecificationListSortByEnum, sort?: RangeVsphereSpecificationListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/infrastructure/range-specifications/vsphere`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a Vsphere range specification
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeVsphereSpecificationRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeVsphereSpecificationRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/infrastructure/range-specifications/vsphere/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Vsphere range specification
         * @param {string} uuid 
         * @param {RangeSpecificationVsphereUpdate} [rangeSpecificationVsphereUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeVsphereSpecificationUpdate: async (uuid: string, rangeSpecificationVsphereUpdate?: RangeSpecificationVsphereUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeVsphereSpecificationUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/infrastructure/range-specifications/vsphere/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeSpecificationVsphereUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InfrastructureContentRangeVsphereSpecificationsApi - functional programming interface
 * @export
 */
export const InfrastructureContentRangeVsphereSpecificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InfrastructureContentRangeVsphereSpecificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a Vsphere range specification
         * @param {RangeSpecificationVsphereCreate} [rangeSpecificationVsphereCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeVsphereSpecificationCreate(rangeSpecificationVsphereCreate?: RangeSpecificationVsphereCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeSpecificationVsphere>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeVsphereSpecificationCreate(rangeSpecificationVsphereCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfrastructureContentRangeVsphereSpecificationsApi.rangeVsphereSpecificationCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a Vsphere range specification
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeVsphereSpecificationDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeVsphereSpecificationDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfrastructureContentRangeVsphereSpecificationsApi.rangeVsphereSpecificationDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing Vsphere range specifications
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeVsphereSpecificationListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeVsphereSpecificationListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeVsphereSpecificationList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: RangeVsphereSpecificationListSortByEnum, sort?: RangeVsphereSpecificationListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeVsphereSpecificationList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeVsphereSpecificationList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfrastructureContentRangeVsphereSpecificationsApi.rangeVsphereSpecificationList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a Vsphere range specification
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeVsphereSpecificationRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeSpecificationVsphere>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeVsphereSpecificationRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfrastructureContentRangeVsphereSpecificationsApi.rangeVsphereSpecificationRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a Vsphere range specification
         * @param {string} uuid 
         * @param {RangeSpecificationVsphereUpdate} [rangeSpecificationVsphereUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeVsphereSpecificationUpdate(uuid: string, rangeSpecificationVsphereUpdate?: RangeSpecificationVsphereUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeSpecificationVsphere>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeVsphereSpecificationUpdate(uuid, rangeSpecificationVsphereUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfrastructureContentRangeVsphereSpecificationsApi.rangeVsphereSpecificationUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InfrastructureContentRangeVsphereSpecificationsApi - factory interface
 * @export
 */
export const InfrastructureContentRangeVsphereSpecificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InfrastructureContentRangeVsphereSpecificationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a Vsphere range specification
         * @param {RangeSpecificationVsphereCreate} [rangeSpecificationVsphereCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeVsphereSpecificationCreate(rangeSpecificationVsphereCreate?: RangeSpecificationVsphereCreate, options?: RawAxiosRequestConfig): AxiosPromise<RangeSpecificationVsphere> {
            return localVarFp.rangeVsphereSpecificationCreate(rangeSpecificationVsphereCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Vsphere range specification
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeVsphereSpecificationDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rangeVsphereSpecificationDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing Vsphere range specifications
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeVsphereSpecificationListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeVsphereSpecificationListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeVsphereSpecificationList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: RangeVsphereSpecificationListSortByEnum, sort?: RangeVsphereSpecificationListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<RangeVsphereSpecificationList200Response> {
            return localVarFp.rangeVsphereSpecificationList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a Vsphere range specification
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeVsphereSpecificationRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<RangeSpecificationVsphere> {
            return localVarFp.rangeVsphereSpecificationRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Vsphere range specification
         * @param {string} uuid 
         * @param {RangeSpecificationVsphereUpdate} [rangeSpecificationVsphereUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeVsphereSpecificationUpdate(uuid: string, rangeSpecificationVsphereUpdate?: RangeSpecificationVsphereUpdate, options?: RawAxiosRequestConfig): AxiosPromise<RangeSpecificationVsphere> {
            return localVarFp.rangeVsphereSpecificationUpdate(uuid, rangeSpecificationVsphereUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InfrastructureContentRangeVsphereSpecificationsApi - object-oriented interface
 * @export
 * @class InfrastructureContentRangeVsphereSpecificationsApi
 * @extends {BaseAPI}
 */
export class InfrastructureContentRangeVsphereSpecificationsApi extends BaseAPI {
    /**
     * 
     * @summary Create a Vsphere range specification
     * @param {RangeSpecificationVsphereCreate} [rangeSpecificationVsphereCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfrastructureContentRangeVsphereSpecificationsApi
     */
    public rangeVsphereSpecificationCreate(rangeSpecificationVsphereCreate?: RangeSpecificationVsphereCreate, options?: RawAxiosRequestConfig) {
        return InfrastructureContentRangeVsphereSpecificationsApiFp(this.configuration).rangeVsphereSpecificationCreate(rangeSpecificationVsphereCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Vsphere range specification
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfrastructureContentRangeVsphereSpecificationsApi
     */
    public rangeVsphereSpecificationDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return InfrastructureContentRangeVsphereSpecificationsApiFp(this.configuration).rangeVsphereSpecificationDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing Vsphere range specifications
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {RangeVsphereSpecificationListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {RangeVsphereSpecificationListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfrastructureContentRangeVsphereSpecificationsApi
     */
    public rangeVsphereSpecificationList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: RangeVsphereSpecificationListSortByEnum, sort?: RangeVsphereSpecificationListSortEnum, options?: RawAxiosRequestConfig) {
        return InfrastructureContentRangeVsphereSpecificationsApiFp(this.configuration).rangeVsphereSpecificationList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a Vsphere range specification
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfrastructureContentRangeVsphereSpecificationsApi
     */
    public rangeVsphereSpecificationRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return InfrastructureContentRangeVsphereSpecificationsApiFp(this.configuration).rangeVsphereSpecificationRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Vsphere range specification
     * @param {string} uuid 
     * @param {RangeSpecificationVsphereUpdate} [rangeSpecificationVsphereUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfrastructureContentRangeVsphereSpecificationsApi
     */
    public rangeVsphereSpecificationUpdate(uuid: string, rangeSpecificationVsphereUpdate?: RangeSpecificationVsphereUpdate, options?: RawAxiosRequestConfig) {
        return InfrastructureContentRangeVsphereSpecificationsApiFp(this.configuration).rangeVsphereSpecificationUpdate(uuid, rangeSpecificationVsphereUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RangeVsphereSpecificationListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author'
} as const;
export type RangeVsphereSpecificationListSortByEnum = typeof RangeVsphereSpecificationListSortByEnum[keyof typeof RangeVsphereSpecificationListSortByEnum];
/**
 * @export
 */
export const RangeVsphereSpecificationListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type RangeVsphereSpecificationListSortEnum = typeof RangeVsphereSpecificationListSortEnum[keyof typeof RangeVsphereSpecificationListSortEnum];


/**
 * KeycloakApi - axios parameter creator
 * @export
 */
export const KeycloakApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List of existing groups in keycloak
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {KeycloakListAllKeycloakGroupsSortByEnum} [sortBy] Key used to sort the collection by
         * @param {KeycloakListAllKeycloakGroupsSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keycloakListAllKeycloakGroups: async (offset?: number, limit?: number, search?: string, sortBy?: KeycloakListAllKeycloakGroupsSortByEnum, sort?: KeycloakListAllKeycloakGroupsSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/keycloak/keycloak-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of existing usernames in keycloak
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {KeycloakListAllKeycloakUsersSortByEnum} [sortBy] Key used to sort the collection by
         * @param {KeycloakListAllKeycloakUsersSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keycloakListAllKeycloakUsers: async (offset?: number, limit?: number, search?: string, sortBy?: KeycloakListAllKeycloakUsersSortByEnum, sort?: KeycloakListAllKeycloakUsersSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/keycloak/keycloak-users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a keycloak group
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keycloakRetrieveKeycloakGroup: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('keycloakRetrieveKeycloakGroup', 'groupId', groupId)
            const localVarPath = `/v1/keycloak/keycloak-groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a keycloak user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keycloakRetrieveKeycloakUser: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('keycloakRetrieveKeycloakUser', 'userId', userId)
            const localVarPath = `/v1/keycloak/keycloak-users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KeycloakApi - functional programming interface
 * @export
 */
export const KeycloakApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = KeycloakApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List of existing groups in keycloak
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {KeycloakListAllKeycloakGroupsSortByEnum} [sortBy] Key used to sort the collection by
         * @param {KeycloakListAllKeycloakGroupsSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keycloakListAllKeycloakGroups(offset?: number, limit?: number, search?: string, sortBy?: KeycloakListAllKeycloakGroupsSortByEnum, sort?: KeycloakListAllKeycloakGroupsSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeycloakListAllKeycloakGroups200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keycloakListAllKeycloakGroups(offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KeycloakApi.keycloakListAllKeycloakGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List of existing usernames in keycloak
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {KeycloakListAllKeycloakUsersSortByEnum} [sortBy] Key used to sort the collection by
         * @param {KeycloakListAllKeycloakUsersSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keycloakListAllKeycloakUsers(offset?: number, limit?: number, search?: string, sortBy?: KeycloakListAllKeycloakUsersSortByEnum, sort?: KeycloakListAllKeycloakUsersSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeycloakListAllKeycloakUsers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keycloakListAllKeycloakUsers(offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KeycloakApi.keycloakListAllKeycloakUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a keycloak group
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keycloakRetrieveKeycloakGroup(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keycloakRetrieveKeycloakGroup(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KeycloakApi.keycloakRetrieveKeycloakGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a keycloak user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keycloakRetrieveKeycloakUser(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keycloakRetrieveKeycloakUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KeycloakApi.keycloakRetrieveKeycloakUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * KeycloakApi - factory interface
 * @export
 */
export const KeycloakApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = KeycloakApiFp(configuration)
    return {
        /**
         * 
         * @summary List of existing groups in keycloak
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {KeycloakListAllKeycloakGroupsSortByEnum} [sortBy] Key used to sort the collection by
         * @param {KeycloakListAllKeycloakGroupsSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keycloakListAllKeycloakGroups(offset?: number, limit?: number, search?: string, sortBy?: KeycloakListAllKeycloakGroupsSortByEnum, sort?: KeycloakListAllKeycloakGroupsSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<KeycloakListAllKeycloakGroups200Response> {
            return localVarFp.keycloakListAllKeycloakGroups(offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List of existing usernames in keycloak
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {KeycloakListAllKeycloakUsersSortByEnum} [sortBy] Key used to sort the collection by
         * @param {KeycloakListAllKeycloakUsersSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keycloakListAllKeycloakUsers(offset?: number, limit?: number, search?: string, sortBy?: KeycloakListAllKeycloakUsersSortByEnum, sort?: KeycloakListAllKeycloakUsersSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<KeycloakListAllKeycloakUsers200Response> {
            return localVarFp.keycloakListAllKeycloakUsers(offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a keycloak group
         * @param {string} groupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keycloakRetrieveKeycloakGroup(groupId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.keycloakRetrieveKeycloakGroup(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a keycloak user
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keycloakRetrieveKeycloakUser(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.keycloakRetrieveKeycloakUser(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KeycloakApi - object-oriented interface
 * @export
 * @class KeycloakApi
 * @extends {BaseAPI}
 */
export class KeycloakApi extends BaseAPI {
    /**
     * 
     * @summary List of existing groups in keycloak
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {KeycloakListAllKeycloakGroupsSortByEnum} [sortBy] Key used to sort the collection by
     * @param {KeycloakListAllKeycloakGroupsSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeycloakApi
     */
    public keycloakListAllKeycloakGroups(offset?: number, limit?: number, search?: string, sortBy?: KeycloakListAllKeycloakGroupsSortByEnum, sort?: KeycloakListAllKeycloakGroupsSortEnum, options?: RawAxiosRequestConfig) {
        return KeycloakApiFp(this.configuration).keycloakListAllKeycloakGroups(offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List of existing usernames in keycloak
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {KeycloakListAllKeycloakUsersSortByEnum} [sortBy] Key used to sort the collection by
     * @param {KeycloakListAllKeycloakUsersSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeycloakApi
     */
    public keycloakListAllKeycloakUsers(offset?: number, limit?: number, search?: string, sortBy?: KeycloakListAllKeycloakUsersSortByEnum, sort?: KeycloakListAllKeycloakUsersSortEnum, options?: RawAxiosRequestConfig) {
        return KeycloakApiFp(this.configuration).keycloakListAllKeycloakUsers(offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a keycloak group
     * @param {string} groupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeycloakApi
     */
    public keycloakRetrieveKeycloakGroup(groupId: string, options?: RawAxiosRequestConfig) {
        return KeycloakApiFp(this.configuration).keycloakRetrieveKeycloakGroup(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a keycloak user
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeycloakApi
     */
    public keycloakRetrieveKeycloakUser(userId: string, options?: RawAxiosRequestConfig) {
        return KeycloakApiFp(this.configuration).keycloakRetrieveKeycloakUser(userId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const KeycloakListAllKeycloakGroupsSortByEnum = {
    Id: 'id',
    Name: 'name',
    Path: 'path'
} as const;
export type KeycloakListAllKeycloakGroupsSortByEnum = typeof KeycloakListAllKeycloakGroupsSortByEnum[keyof typeof KeycloakListAllKeycloakGroupsSortByEnum];
/**
 * @export
 */
export const KeycloakListAllKeycloakGroupsSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type KeycloakListAllKeycloakGroupsSortEnum = typeof KeycloakListAllKeycloakGroupsSortEnum[keyof typeof KeycloakListAllKeycloakGroupsSortEnum];
/**
 * @export
 */
export const KeycloakListAllKeycloakUsersSortByEnum = {
    Id: 'id',
    Username: 'username',
    Email: 'email',
    FirstName: 'firstName',
    LastName: 'lastName',
    CreatedTimestamp: 'createdTimestamp'
} as const;
export type KeycloakListAllKeycloakUsersSortByEnum = typeof KeycloakListAllKeycloakUsersSortByEnum[keyof typeof KeycloakListAllKeycloakUsersSortByEnum];
/**
 * @export
 */
export const KeycloakListAllKeycloakUsersSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type KeycloakListAllKeycloakUsersSortEnum = typeof KeycloakListAllKeycloakUsersSortEnum[keyof typeof KeycloakListAllKeycloakUsersSortEnum];


/**
 * LTICourseMappingApi - axios parameter creator
 * @export
 */
export const LTICourseMappingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a Course Mapping
         * @param {CourseMappingCreate} [courseMappingCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseMappingCreate: async (courseMappingCreate?: CourseMappingCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/lti/courseMapping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(courseMappingCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Course Mapping
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseMappingDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('courseMappingDelete', 'uuid', uuid)
            const localVarPath = `/v1/lti/courseMapping/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve list of Course Mappings
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [scenarioId] 
         * @param {string} [courseId] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {CourseMappingListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {CourseMappingListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseMappingList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, scenarioId?: string, courseId?: string, offset?: number, limit?: number, search?: string, sortBy?: CourseMappingListSortByEnum, sort?: CourseMappingListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/lti/courseMapping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (scenarioId !== undefined) {
                localVarQueryParameter['scenarioId'] = scenarioId;
            }

            if (courseId !== undefined) {
                localVarQueryParameter['courseId'] = courseId;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a Course Mapping
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseMappingRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('courseMappingRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/lti/courseMapping/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Course Mapping
         * @param {string} uuid 
         * @param {CourseMappingUpdate} [courseMappingUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseMappingUpdate: async (uuid: string, courseMappingUpdate?: CourseMappingUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('courseMappingUpdate', 'uuid', uuid)
            const localVarPath = `/v1/lti/courseMapping/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(courseMappingUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LTICourseMappingApi - functional programming interface
 * @export
 */
export const LTICourseMappingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LTICourseMappingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a Course Mapping
         * @param {CourseMappingCreate} [courseMappingCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseMappingCreate(courseMappingCreate?: CourseMappingCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseMapping>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseMappingCreate(courseMappingCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LTICourseMappingApi.courseMappingCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a Course Mapping
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseMappingDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseMappingDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LTICourseMappingApi.courseMappingDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve list of Course Mappings
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [scenarioId] 
         * @param {string} [courseId] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {CourseMappingListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {CourseMappingListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseMappingList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, scenarioId?: string, courseId?: string, offset?: number, limit?: number, search?: string, sortBy?: CourseMappingListSortByEnum, sort?: CourseMappingListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseMappingList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseMappingList(uuid, name, description, author, metadata, scenarioId, courseId, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LTICourseMappingApi.courseMappingList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a Course Mapping
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseMappingRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseMapping>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseMappingRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LTICourseMappingApi.courseMappingRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a Course Mapping
         * @param {string} uuid 
         * @param {CourseMappingUpdate} [courseMappingUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async courseMappingUpdate(uuid: string, courseMappingUpdate?: CourseMappingUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CourseMapping>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.courseMappingUpdate(uuid, courseMappingUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LTICourseMappingApi.courseMappingUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LTICourseMappingApi - factory interface
 * @export
 */
export const LTICourseMappingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LTICourseMappingApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a Course Mapping
         * @param {CourseMappingCreate} [courseMappingCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseMappingCreate(courseMappingCreate?: CourseMappingCreate, options?: RawAxiosRequestConfig): AxiosPromise<CourseMapping> {
            return localVarFp.courseMappingCreate(courseMappingCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Course Mapping
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseMappingDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.courseMappingDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve list of Course Mappings
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [scenarioId] 
         * @param {string} [courseId] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {CourseMappingListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {CourseMappingListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseMappingList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, scenarioId?: string, courseId?: string, offset?: number, limit?: number, search?: string, sortBy?: CourseMappingListSortByEnum, sort?: CourseMappingListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<CourseMappingList200Response> {
            return localVarFp.courseMappingList(uuid, name, description, author, metadata, scenarioId, courseId, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a Course Mapping
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseMappingRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<CourseMapping> {
            return localVarFp.courseMappingRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Course Mapping
         * @param {string} uuid 
         * @param {CourseMappingUpdate} [courseMappingUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseMappingUpdate(uuid: string, courseMappingUpdate?: CourseMappingUpdate, options?: RawAxiosRequestConfig): AxiosPromise<CourseMapping> {
            return localVarFp.courseMappingUpdate(uuid, courseMappingUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LTICourseMappingApi - object-oriented interface
 * @export
 * @class LTICourseMappingApi
 * @extends {BaseAPI}
 */
export class LTICourseMappingApi extends BaseAPI {
    /**
     * 
     * @summary Create a Course Mapping
     * @param {CourseMappingCreate} [courseMappingCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTICourseMappingApi
     */
    public courseMappingCreate(courseMappingCreate?: CourseMappingCreate, options?: RawAxiosRequestConfig) {
        return LTICourseMappingApiFp(this.configuration).courseMappingCreate(courseMappingCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Course Mapping
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTICourseMappingApi
     */
    public courseMappingDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return LTICourseMappingApiFp(this.configuration).courseMappingDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve list of Course Mappings
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {string} [scenarioId] 
     * @param {string} [courseId] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {CourseMappingListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {CourseMappingListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTICourseMappingApi
     */
    public courseMappingList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, scenarioId?: string, courseId?: string, offset?: number, limit?: number, search?: string, sortBy?: CourseMappingListSortByEnum, sort?: CourseMappingListSortEnum, options?: RawAxiosRequestConfig) {
        return LTICourseMappingApiFp(this.configuration).courseMappingList(uuid, name, description, author, metadata, scenarioId, courseId, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a Course Mapping
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTICourseMappingApi
     */
    public courseMappingRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return LTICourseMappingApiFp(this.configuration).courseMappingRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Course Mapping
     * @param {string} uuid 
     * @param {CourseMappingUpdate} [courseMappingUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LTICourseMappingApi
     */
    public courseMappingUpdate(uuid: string, courseMappingUpdate?: CourseMappingUpdate, options?: RawAxiosRequestConfig) {
        return LTICourseMappingApiFp(this.configuration).courseMappingUpdate(uuid, courseMappingUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const CourseMappingListSortByEnum = {
    CourseId: 'courseId',
    ScenarioId: 'scenarioId'
} as const;
export type CourseMappingListSortByEnum = typeof CourseMappingListSortByEnum[keyof typeof CourseMappingListSortByEnum];
/**
 * @export
 */
export const CourseMappingListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type CourseMappingListSortEnum = typeof CourseMappingListSortEnum[keyof typeof CourseMappingListSortEnum];


/**
 * ManageInfrastructureResourcesEnvironmentAWSApi - axios parameter creator
 * @export
 */
export const ManageInfrastructureResourcesEnvironmentAWSApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an AWS environment
         * @param {EnvironmentAwsCreate} [environmentAwsCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentAwsCreate: async (environmentAwsCreate?: EnvironmentAwsCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/manage/infrastructure/environments/aws`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentAwsCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an AWS environment
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentAwsDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('environmentAwsDelete', 'uuid', uuid)
            const localVarPath = `/v1/manage/infrastructure/environments/aws/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of AWS regions and associated zones
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentAwsGetRegions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/manage/infrastructure/environments/aws/regions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing AWS environment
         * @param {string} [name] 
         * @param {string} [awsAvailabilityZone] 
         * @param {string} [awsRegion] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {EnvironmentAwsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {EnvironmentAwsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentAwsList: async (name?: string, awsAvailabilityZone?: string, awsRegion?: string, offset?: number, limit?: number, search?: string, sortBy?: EnvironmentAwsListSortByEnum, sort?: EnvironmentAwsListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/manage/infrastructure/environments/aws`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (awsAvailabilityZone !== undefined) {
                localVarQueryParameter['awsAvailabilityZone'] = awsAvailabilityZone;
            }

            if (awsRegion !== undefined) {
                localVarQueryParameter['awsRegion'] = awsRegion;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an AWS environment
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentAwsRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('environmentAwsRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/manage/infrastructure/environments/aws/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an AWS environment
         * @param {string} uuid 
         * @param {EnvironmentAwsUpdate} [environmentAwsUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentAwsUpdate: async (uuid: string, environmentAwsUpdate?: EnvironmentAwsUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('environmentAwsUpdate', 'uuid', uuid)
            const localVarPath = `/v1/manage/infrastructure/environments/aws/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(environmentAwsUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageInfrastructureResourcesEnvironmentAWSApi - functional programming interface
 * @export
 */
export const ManageInfrastructureResourcesEnvironmentAWSApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageInfrastructureResourcesEnvironmentAWSApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create an AWS environment
         * @param {EnvironmentAwsCreate} [environmentAwsCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentAwsCreate(environmentAwsCreate?: EnvironmentAwsCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentAws>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentAwsCreate(environmentAwsCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageInfrastructureResourcesEnvironmentAWSApi.environmentAwsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an AWS environment
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentAwsDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentAwsDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageInfrastructureResourcesEnvironmentAWSApi.environmentAwsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a list of AWS regions and associated zones
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentAwsGetRegions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EnvironmentAwsRegion>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentAwsGetRegions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageInfrastructureResourcesEnvironmentAWSApi.environmentAwsGetRegions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing AWS environment
         * @param {string} [name] 
         * @param {string} [awsAvailabilityZone] 
         * @param {string} [awsRegion] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {EnvironmentAwsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {EnvironmentAwsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentAwsList(name?: string, awsAvailabilityZone?: string, awsRegion?: string, offset?: number, limit?: number, search?: string, sortBy?: EnvironmentAwsListSortByEnum, sort?: EnvironmentAwsListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentAwsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentAwsList(name, awsAvailabilityZone, awsRegion, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageInfrastructureResourcesEnvironmentAWSApi.environmentAwsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an AWS environment
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentAwsRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentAws>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentAwsRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageInfrastructureResourcesEnvironmentAWSApi.environmentAwsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an AWS environment
         * @param {string} uuid 
         * @param {EnvironmentAwsUpdate} [environmentAwsUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async environmentAwsUpdate(uuid: string, environmentAwsUpdate?: EnvironmentAwsUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnvironmentAws>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.environmentAwsUpdate(uuid, environmentAwsUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageInfrastructureResourcesEnvironmentAWSApi.environmentAwsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageInfrastructureResourcesEnvironmentAWSApi - factory interface
 * @export
 */
export const ManageInfrastructureResourcesEnvironmentAWSApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageInfrastructureResourcesEnvironmentAWSApiFp(configuration)
    return {
        /**
         * 
         * @summary Create an AWS environment
         * @param {EnvironmentAwsCreate} [environmentAwsCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentAwsCreate(environmentAwsCreate?: EnvironmentAwsCreate, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentAws> {
            return localVarFp.environmentAwsCreate(environmentAwsCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an AWS environment
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentAwsDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.environmentAwsDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of AWS regions and associated zones
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentAwsGetRegions(options?: RawAxiosRequestConfig): AxiosPromise<Array<EnvironmentAwsRegion>> {
            return localVarFp.environmentAwsGetRegions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing AWS environment
         * @param {string} [name] 
         * @param {string} [awsAvailabilityZone] 
         * @param {string} [awsRegion] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {EnvironmentAwsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {EnvironmentAwsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentAwsList(name?: string, awsAvailabilityZone?: string, awsRegion?: string, offset?: number, limit?: number, search?: string, sortBy?: EnvironmentAwsListSortByEnum, sort?: EnvironmentAwsListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentAwsList200Response> {
            return localVarFp.environmentAwsList(name, awsAvailabilityZone, awsRegion, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an AWS environment
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentAwsRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentAws> {
            return localVarFp.environmentAwsRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an AWS environment
         * @param {string} uuid 
         * @param {EnvironmentAwsUpdate} [environmentAwsUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        environmentAwsUpdate(uuid: string, environmentAwsUpdate?: EnvironmentAwsUpdate, options?: RawAxiosRequestConfig): AxiosPromise<EnvironmentAws> {
            return localVarFp.environmentAwsUpdate(uuid, environmentAwsUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageInfrastructureResourcesEnvironmentAWSApi - object-oriented interface
 * @export
 * @class ManageInfrastructureResourcesEnvironmentAWSApi
 * @extends {BaseAPI}
 */
export class ManageInfrastructureResourcesEnvironmentAWSApi extends BaseAPI {
    /**
     * 
     * @summary Create an AWS environment
     * @param {EnvironmentAwsCreate} [environmentAwsCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageInfrastructureResourcesEnvironmentAWSApi
     */
    public environmentAwsCreate(environmentAwsCreate?: EnvironmentAwsCreate, options?: RawAxiosRequestConfig) {
        return ManageInfrastructureResourcesEnvironmentAWSApiFp(this.configuration).environmentAwsCreate(environmentAwsCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an AWS environment
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageInfrastructureResourcesEnvironmentAWSApi
     */
    public environmentAwsDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return ManageInfrastructureResourcesEnvironmentAWSApiFp(this.configuration).environmentAwsDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of AWS regions and associated zones
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageInfrastructureResourcesEnvironmentAWSApi
     */
    public environmentAwsGetRegions(options?: RawAxiosRequestConfig) {
        return ManageInfrastructureResourcesEnvironmentAWSApiFp(this.configuration).environmentAwsGetRegions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing AWS environment
     * @param {string} [name] 
     * @param {string} [awsAvailabilityZone] 
     * @param {string} [awsRegion] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {EnvironmentAwsListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {EnvironmentAwsListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageInfrastructureResourcesEnvironmentAWSApi
     */
    public environmentAwsList(name?: string, awsAvailabilityZone?: string, awsRegion?: string, offset?: number, limit?: number, search?: string, sortBy?: EnvironmentAwsListSortByEnum, sort?: EnvironmentAwsListSortEnum, options?: RawAxiosRequestConfig) {
        return ManageInfrastructureResourcesEnvironmentAWSApiFp(this.configuration).environmentAwsList(name, awsAvailabilityZone, awsRegion, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an AWS environment
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageInfrastructureResourcesEnvironmentAWSApi
     */
    public environmentAwsRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return ManageInfrastructureResourcesEnvironmentAWSApiFp(this.configuration).environmentAwsRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an AWS environment
     * @param {string} uuid 
     * @param {EnvironmentAwsUpdate} [environmentAwsUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageInfrastructureResourcesEnvironmentAWSApi
     */
    public environmentAwsUpdate(uuid: string, environmentAwsUpdate?: EnvironmentAwsUpdate, options?: RawAxiosRequestConfig) {
        return ManageInfrastructureResourcesEnvironmentAWSApiFp(this.configuration).environmentAwsUpdate(uuid, environmentAwsUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const EnvironmentAwsListSortByEnum = {
    AwsAvailabilityZone: 'awsAvailabilityZone',
    AwsRegion: 'awsRegion',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Name: 'name',
    Author: 'author'
} as const;
export type EnvironmentAwsListSortByEnum = typeof EnvironmentAwsListSortByEnum[keyof typeof EnvironmentAwsListSortByEnum];
/**
 * @export
 */
export const EnvironmentAwsListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type EnvironmentAwsListSortEnum = typeof EnvironmentAwsListSortEnum[keyof typeof EnvironmentAwsListSortEnum];


/**
 * ManageInfrastructureResourcesNodesApi - axios parameter creator
 * @export
 */
export const ManageInfrastructureResourcesNodesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all range nodes
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nodesList: async (offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/manage/infrastructure/nodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageInfrastructureResourcesNodesApi - functional programming interface
 * @export
 */
export const ManageInfrastructureResourcesNodesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageInfrastructureResourcesNodesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all range nodes
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nodesList(offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NodesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nodesList(offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageInfrastructureResourcesNodesApi.nodesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageInfrastructureResourcesNodesApi - factory interface
 * @export
 */
export const ManageInfrastructureResourcesNodesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageInfrastructureResourcesNodesApiFp(configuration)
    return {
        /**
         * 
         * @summary List all range nodes
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nodesList(offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<NodesList200Response> {
            return localVarFp.nodesList(offset, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageInfrastructureResourcesNodesApi - object-oriented interface
 * @export
 * @class ManageInfrastructureResourcesNodesApi
 * @extends {BaseAPI}
 */
export class ManageInfrastructureResourcesNodesApi extends BaseAPI {
    /**
     * 
     * @summary List all range nodes
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageInfrastructureResourcesNodesApi
     */
    public nodesList(offset?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return ManageInfrastructureResourcesNodesApiFp(this.configuration).nodesList(offset, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ManageInfrastructureResourcesRangesApi - axios parameter creator
 * @export
 */
export const ManageInfrastructureResourcesRangesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a range
         * @param {RangeCreate} [rangeCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeCreate: async (rangeCreate?: RangeCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/manage/infrastructure/ranges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates range ACLs
         * @param {string} uuid 
         * @param {AclRangeCreate} [aclRangeCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeCreateAcl: async (uuid: string, aclRangeCreate?: AclRangeCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeCreateAcl', 'uuid', uuid)
            const localVarPath = `/v1/manage/infrastructure/ranges/{uuid}/acls`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aclRangeCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a range
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeDelete', 'uuid', uuid)
            const localVarPath = `/v1/manage/infrastructure/ranges/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing ranges
         * @param {string} [author] 
         * @param {string} [name] 
         * @param {string} [specification] 
         * @param {string} [uuid] 
         * @param {RangeListStatusEnum} [status] 
         * @param {string} [message] 
         * @param {string} [cmi5Key] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeList: async (author?: string, name?: string, specification?: string, uuid?: string, status?: RangeListStatusEnum, message?: string, cmi5Key?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeListSortByEnum, sort?: RangeListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/manage/infrastructure/ranges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (specification !== undefined) {
                localVarQueryParameter['specification'] = specification;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (message !== undefined) {
                localVarQueryParameter['message'] = message;
            }

            if (cmi5Key !== undefined) {
                localVarQueryParameter['cmi5Key'] = cmi5Key;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the price of a deployed range
         * @summary Get price of a range
         * @param {string} uuid 
         * @param {RangeRangeBillingRequest} [rangeRangeBillingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeRangeBilling: async (uuid: string, rangeRangeBillingRequest?: RangeRangeBillingRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeRangeBilling', 'uuid', uuid)
            const localVarPath = `/v1/manage/infrastructure/ranges/{uuid}/billing`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeRangeBillingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List range resources
         * @param {string} uuid 
         * @param {string} [kind] 
         * @param {string} [name] 
         * @param {RangeResourcesListStatusEnum} [status] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeResourcesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeResourcesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeResourcesList: async (uuid: string, kind?: string, name?: string, status?: RangeResourcesListStatusEnum, offset?: number, limit?: number, search?: string, sortBy?: RangeResourcesListSortByEnum, sort?: RangeResourcesListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeResourcesList', 'uuid', uuid)
            const localVarPath = `/v1/manage/infrastructure/ranges/{uuid}/resources`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (kind !== undefined) {
                localVarQueryParameter['kind'] = kind;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a range
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/manage/infrastructure/ranges/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves range ACLs
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeRetrieveAcl: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeRetrieveAcl', 'uuid', uuid)
            const localVarPath = `/v1/manage/infrastructure/ranges/{uuid}/acls`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a range
         * @param {string} uuid 
         * @param {RangeUpdate} [rangeUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeUpdate: async (uuid: string, rangeUpdate?: RangeUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeUpdate', 'uuid', uuid)
            const localVarPath = `/v1/manage/infrastructure/ranges/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageInfrastructureResourcesRangesApi - functional programming interface
 * @export
 */
export const ManageInfrastructureResourcesRangesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageInfrastructureResourcesRangesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a range
         * @param {RangeCreate} [rangeCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeCreate(rangeCreate?: RangeCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Range>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeCreate(rangeCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageInfrastructureResourcesRangesApi.rangeCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates range ACLs
         * @param {string} uuid 
         * @param {AclRangeCreate} [aclRangeCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeCreateAcl(uuid: string, aclRangeCreate?: AclRangeCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AclRange>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeCreateAcl(uuid, aclRangeCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageInfrastructureResourcesRangesApi.rangeCreateAcl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a range
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageInfrastructureResourcesRangesApi.rangeDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing ranges
         * @param {string} [author] 
         * @param {string} [name] 
         * @param {string} [specification] 
         * @param {string} [uuid] 
         * @param {RangeListStatusEnum} [status] 
         * @param {string} [message] 
         * @param {string} [cmi5Key] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeList(author?: string, name?: string, specification?: string, uuid?: string, status?: RangeListStatusEnum, message?: string, cmi5Key?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeListSortByEnum, sort?: RangeListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeList(author, name, specification, uuid, status, message, cmi5Key, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageInfrastructureResourcesRangesApi.rangeList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the price of a deployed range
         * @summary Get price of a range
         * @param {string} uuid 
         * @param {RangeRangeBillingRequest} [rangeRangeBillingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeRangeBilling(uuid: string, rangeRangeBillingRequest?: RangeRangeBillingRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeBilling>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeRangeBilling(uuid, rangeRangeBillingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageInfrastructureResourcesRangesApi.rangeRangeBilling']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List range resources
         * @param {string} uuid 
         * @param {string} [kind] 
         * @param {string} [name] 
         * @param {RangeResourcesListStatusEnum} [status] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeResourcesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeResourcesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeResourcesList(uuid: string, kind?: string, name?: string, status?: RangeResourcesListStatusEnum, offset?: number, limit?: number, search?: string, sortBy?: RangeResourcesListSortByEnum, sort?: RangeResourcesListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeResourcesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeResourcesList(uuid, kind, name, status, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageInfrastructureResourcesRangesApi.rangeResourcesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a range
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Range>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageInfrastructureResourcesRangesApi.rangeRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves range ACLs
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeRetrieveAcl(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AclRange>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeRetrieveAcl(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageInfrastructureResourcesRangesApi.rangeRetrieveAcl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a range
         * @param {string} uuid 
         * @param {RangeUpdate} [rangeUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeUpdate(uuid: string, rangeUpdate?: RangeUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Range>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeUpdate(uuid, rangeUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageInfrastructureResourcesRangesApi.rangeUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageInfrastructureResourcesRangesApi - factory interface
 * @export
 */
export const ManageInfrastructureResourcesRangesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageInfrastructureResourcesRangesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a range
         * @param {RangeCreate} [rangeCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeCreate(rangeCreate?: RangeCreate, options?: RawAxiosRequestConfig): AxiosPromise<Range> {
            return localVarFp.rangeCreate(rangeCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates range ACLs
         * @param {string} uuid 
         * @param {AclRangeCreate} [aclRangeCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeCreateAcl(uuid: string, aclRangeCreate?: AclRangeCreate, options?: RawAxiosRequestConfig): AxiosPromise<AclRange> {
            return localVarFp.rangeCreateAcl(uuid, aclRangeCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a range
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rangeDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing ranges
         * @param {string} [author] 
         * @param {string} [name] 
         * @param {string} [specification] 
         * @param {string} [uuid] 
         * @param {RangeListStatusEnum} [status] 
         * @param {string} [message] 
         * @param {string} [cmi5Key] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeList(author?: string, name?: string, specification?: string, uuid?: string, status?: RangeListStatusEnum, message?: string, cmi5Key?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeListSortByEnum, sort?: RangeListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<RangeList200Response> {
            return localVarFp.rangeList(author, name, specification, uuid, status, message, cmi5Key, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the price of a deployed range
         * @summary Get price of a range
         * @param {string} uuid 
         * @param {RangeRangeBillingRequest} [rangeRangeBillingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeRangeBilling(uuid: string, rangeRangeBillingRequest?: RangeRangeBillingRequest, options?: RawAxiosRequestConfig): AxiosPromise<RangeBilling> {
            return localVarFp.rangeRangeBilling(uuid, rangeRangeBillingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List range resources
         * @param {string} uuid 
         * @param {string} [kind] 
         * @param {string} [name] 
         * @param {RangeResourcesListStatusEnum} [status] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeResourcesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeResourcesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeResourcesList(uuid: string, kind?: string, name?: string, status?: RangeResourcesListStatusEnum, offset?: number, limit?: number, search?: string, sortBy?: RangeResourcesListSortByEnum, sort?: RangeResourcesListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<RangeResourcesList200Response> {
            return localVarFp.rangeResourcesList(uuid, kind, name, status, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a range
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<Range> {
            return localVarFp.rangeRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves range ACLs
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeRetrieveAcl(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<AclRange> {
            return localVarFp.rangeRetrieveAcl(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a range
         * @param {string} uuid 
         * @param {RangeUpdate} [rangeUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeUpdate(uuid: string, rangeUpdate?: RangeUpdate, options?: RawAxiosRequestConfig): AxiosPromise<Range> {
            return localVarFp.rangeUpdate(uuid, rangeUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageInfrastructureResourcesRangesApi - object-oriented interface
 * @export
 * @class ManageInfrastructureResourcesRangesApi
 * @extends {BaseAPI}
 */
export class ManageInfrastructureResourcesRangesApi extends BaseAPI {
    /**
     * 
     * @summary Create a range
     * @param {RangeCreate} [rangeCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageInfrastructureResourcesRangesApi
     */
    public rangeCreate(rangeCreate?: RangeCreate, options?: RawAxiosRequestConfig) {
        return ManageInfrastructureResourcesRangesApiFp(this.configuration).rangeCreate(rangeCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates range ACLs
     * @param {string} uuid 
     * @param {AclRangeCreate} [aclRangeCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageInfrastructureResourcesRangesApi
     */
    public rangeCreateAcl(uuid: string, aclRangeCreate?: AclRangeCreate, options?: RawAxiosRequestConfig) {
        return ManageInfrastructureResourcesRangesApiFp(this.configuration).rangeCreateAcl(uuid, aclRangeCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a range
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageInfrastructureResourcesRangesApi
     */
    public rangeDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return ManageInfrastructureResourcesRangesApiFp(this.configuration).rangeDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing ranges
     * @param {string} [author] 
     * @param {string} [name] 
     * @param {string} [specification] 
     * @param {string} [uuid] 
     * @param {RangeListStatusEnum} [status] 
     * @param {string} [message] 
     * @param {string} [cmi5Key] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {RangeListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {RangeListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageInfrastructureResourcesRangesApi
     */
    public rangeList(author?: string, name?: string, specification?: string, uuid?: string, status?: RangeListStatusEnum, message?: string, cmi5Key?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeListSortByEnum, sort?: RangeListSortEnum, options?: RawAxiosRequestConfig) {
        return ManageInfrastructureResourcesRangesApiFp(this.configuration).rangeList(author, name, specification, uuid, status, message, cmi5Key, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the price of a deployed range
     * @summary Get price of a range
     * @param {string} uuid 
     * @param {RangeRangeBillingRequest} [rangeRangeBillingRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageInfrastructureResourcesRangesApi
     */
    public rangeRangeBilling(uuid: string, rangeRangeBillingRequest?: RangeRangeBillingRequest, options?: RawAxiosRequestConfig) {
        return ManageInfrastructureResourcesRangesApiFp(this.configuration).rangeRangeBilling(uuid, rangeRangeBillingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List range resources
     * @param {string} uuid 
     * @param {string} [kind] 
     * @param {string} [name] 
     * @param {RangeResourcesListStatusEnum} [status] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {RangeResourcesListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {RangeResourcesListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageInfrastructureResourcesRangesApi
     */
    public rangeResourcesList(uuid: string, kind?: string, name?: string, status?: RangeResourcesListStatusEnum, offset?: number, limit?: number, search?: string, sortBy?: RangeResourcesListSortByEnum, sort?: RangeResourcesListSortEnum, options?: RawAxiosRequestConfig) {
        return ManageInfrastructureResourcesRangesApiFp(this.configuration).rangeResourcesList(uuid, kind, name, status, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a range
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageInfrastructureResourcesRangesApi
     */
    public rangeRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return ManageInfrastructureResourcesRangesApiFp(this.configuration).rangeRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves range ACLs
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageInfrastructureResourcesRangesApi
     */
    public rangeRetrieveAcl(uuid: string, options?: RawAxiosRequestConfig) {
        return ManageInfrastructureResourcesRangesApiFp(this.configuration).rangeRetrieveAcl(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a range
     * @param {string} uuid 
     * @param {RangeUpdate} [rangeUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageInfrastructureResourcesRangesApi
     */
    public rangeUpdate(uuid: string, rangeUpdate?: RangeUpdate, options?: RawAxiosRequestConfig) {
        return ManageInfrastructureResourcesRangesApiFp(this.configuration).rangeUpdate(uuid, rangeUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RangeListStatusEnum = {
    Unknown: 'Unknown',
    Ready: 'Ready',
    NotReady: 'NotReady',
    Creating: 'Creating',
    Error: 'Error',
    Deleting: 'Deleting',
    Stopped: 'Stopped'
} as const;
export type RangeListStatusEnum = typeof RangeListStatusEnum[keyof typeof RangeListStatusEnum];
/**
 * @export
 */
export const RangeListSortByEnum = {
    Author: 'author',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Name: 'name',
    Uuid: 'uuid',
    Specification: 'specification',
    Status: 'status',
    Message: 'message'
} as const;
export type RangeListSortByEnum = typeof RangeListSortByEnum[keyof typeof RangeListSortByEnum];
/**
 * @export
 */
export const RangeListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type RangeListSortEnum = typeof RangeListSortEnum[keyof typeof RangeListSortEnum];
/**
 * @export
 */
export const RangeResourcesListStatusEnum = {
    Unknown: 'Unknown',
    Ready: 'Ready',
    NotReady: 'NotReady',
    Creating: 'Creating',
    Error: 'Error',
    Deleting: 'Deleting',
    Stopped: 'Stopped'
} as const;
export type RangeResourcesListStatusEnum = typeof RangeResourcesListStatusEnum[keyof typeof RangeResourcesListStatusEnum];
/**
 * @export
 */
export const RangeResourcesListSortByEnum = {
    Kind: 'kind',
    Name: 'name',
    Status: 'status'
} as const;
export type RangeResourcesListSortByEnum = typeof RangeResourcesListSortByEnum[keyof typeof RangeResourcesListSortByEnum];
/**
 * @export
 */
export const RangeResourcesListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type RangeResourcesListSortEnum = typeof RangeResourcesListSortEnum[keyof typeof RangeResourcesListSortEnum];


/**
 * ManageRangeResourcesAnsiblePlaybookApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesAnsiblePlaybookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes an Ansible Playbook from an in-range scenario
         * @summary Deletes an Ansible Playbook
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeAnsiblePlaybooksDelete: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeAnsiblePlaybooksDelete', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeAnsiblePlaybooksDelete', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeAnsiblePlaybooksDelete', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/ansible-playbook/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing Ansible Playbooks
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [author] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [uuid] 
         * @param {boolean} [schema] 
         * @param {boolean} [ready] 
         * @param {string} [status] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeAnsiblePlaybooksListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeAnsiblePlaybooksListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeAnsiblePlaybooksList: async (rangeId: string, scenarioId: string, author?: string, name?: string, description?: string, uuid?: string, schema?: boolean, ready?: boolean, status?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeAnsiblePlaybooksListSortByEnum, sort?: DeployedRangeAnsiblePlaybooksListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeAnsiblePlaybooksList', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeAnsiblePlaybooksList', 'scenarioId', scenarioId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/ansible-playbook`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (schema !== undefined) {
                localVarQueryParameter['schema'] = schema;
            }

            if (ready !== undefined) {
                localVarQueryParameter['ready'] = ready;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing Ansible Playbook
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeAnsiblePlaybooksRetrieve: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeAnsiblePlaybooksRetrieve', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeAnsiblePlaybooksRetrieve', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeAnsiblePlaybooksRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/ansible-playbook/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesAnsiblePlaybookApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesAnsiblePlaybookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesAnsiblePlaybookApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes an Ansible Playbook from an in-range scenario
         * @summary Deletes an Ansible Playbook
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeAnsiblePlaybooksDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeAnsiblePlaybooksDelete(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesAnsiblePlaybookApi.deployedRangeAnsiblePlaybooksDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing Ansible Playbooks
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [author] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [uuid] 
         * @param {boolean} [schema] 
         * @param {boolean} [ready] 
         * @param {string} [status] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeAnsiblePlaybooksListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeAnsiblePlaybooksListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeAnsiblePlaybooksList(rangeId: string, scenarioId: string, author?: string, name?: string, description?: string, uuid?: string, schema?: boolean, ready?: boolean, status?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeAnsiblePlaybooksListSortByEnum, sort?: DeployedRangeAnsiblePlaybooksListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedRangeAnsiblePlaybooksList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeAnsiblePlaybooksList(rangeId, scenarioId, author, name, description, uuid, schema, ready, status, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesAnsiblePlaybookApi.deployedRangeAnsiblePlaybooksList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an existing Ansible Playbook
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeAnsiblePlaybooksRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedAnsiblePlaybook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeAnsiblePlaybooksRetrieve(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesAnsiblePlaybookApi.deployedRangeAnsiblePlaybooksRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesAnsiblePlaybookApi - factory interface
 * @export
 */
export const ManageRangeResourcesAnsiblePlaybookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesAnsiblePlaybookApiFp(configuration)
    return {
        /**
         * Deletes an Ansible Playbook from an in-range scenario
         * @summary Deletes an Ansible Playbook
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeAnsiblePlaybooksDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedRangeAnsiblePlaybooksDelete(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing Ansible Playbooks
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [author] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [uuid] 
         * @param {boolean} [schema] 
         * @param {boolean} [ready] 
         * @param {string} [status] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeAnsiblePlaybooksListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeAnsiblePlaybooksListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeAnsiblePlaybooksList(rangeId: string, scenarioId: string, author?: string, name?: string, description?: string, uuid?: string, schema?: boolean, ready?: boolean, status?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeAnsiblePlaybooksListSortByEnum, sort?: DeployedRangeAnsiblePlaybooksListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<DeployedRangeAnsiblePlaybooksList200Response> {
            return localVarFp.deployedRangeAnsiblePlaybooksList(rangeId, scenarioId, author, name, description, uuid, schema, ready, status, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing Ansible Playbook
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeAnsiblePlaybooksRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<DeployedAnsiblePlaybook> {
            return localVarFp.deployedRangeAnsiblePlaybooksRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesAnsiblePlaybookApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesAnsiblePlaybookApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesAnsiblePlaybookApi extends BaseAPI {
    /**
     * Deletes an Ansible Playbook from an in-range scenario
     * @summary Deletes an Ansible Playbook
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesAnsiblePlaybookApi
     */
    public deployedRangeAnsiblePlaybooksDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesAnsiblePlaybookApiFp(this.configuration).deployedRangeAnsiblePlaybooksDelete(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing Ansible Playbooks
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} [author] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [uuid] 
     * @param {boolean} [schema] 
     * @param {boolean} [ready] 
     * @param {string} [status] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {DeployedRangeAnsiblePlaybooksListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {DeployedRangeAnsiblePlaybooksListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesAnsiblePlaybookApi
     */
    public deployedRangeAnsiblePlaybooksList(rangeId: string, scenarioId: string, author?: string, name?: string, description?: string, uuid?: string, schema?: boolean, ready?: boolean, status?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeAnsiblePlaybooksListSortByEnum, sort?: DeployedRangeAnsiblePlaybooksListSortEnum, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesAnsiblePlaybookApiFp(this.configuration).deployedRangeAnsiblePlaybooksList(rangeId, scenarioId, author, name, description, uuid, schema, ready, status, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing Ansible Playbook
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesAnsiblePlaybookApi
     */
    public deployedRangeAnsiblePlaybooksRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesAnsiblePlaybookApiFp(this.configuration).deployedRangeAnsiblePlaybooksRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeployedRangeAnsiblePlaybooksListSortByEnum = {
    Author: 'author',
    Name: 'name',
    Description: 'description',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Uuid: 'uuid',
    Ready: 'ready',
    Status: 'status'
} as const;
export type DeployedRangeAnsiblePlaybooksListSortByEnum = typeof DeployedRangeAnsiblePlaybooksListSortByEnum[keyof typeof DeployedRangeAnsiblePlaybooksListSortByEnum];
/**
 * @export
 */
export const DeployedRangeAnsiblePlaybooksListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type DeployedRangeAnsiblePlaybooksListSortEnum = typeof DeployedRangeAnsiblePlaybooksListSortEnum[keyof typeof DeployedRangeAnsiblePlaybooksListSortEnum];


/**
 * ManageRangeResourcesClusterRangeNetworksApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesClusterRangeNetworksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a cluster range network from a range
         * @summary Deletes a cluster range network
         * @param {string} rangeId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterRangeNetworksDeleteByRangeIdUuid: async (rangeId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('clusterRangeNetworksDeleteByRangeIdUuid', 'rangeId', rangeId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('clusterRangeNetworksDeleteByRangeIdUuid', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/cluster-range-networks/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List existing in-range cluster range networks
         * @summary List cluster range networks
         * @param {string} rangeId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {ClusterRangeNetworksListByRangeIdSortByEnum} [sortBy] Key used to sort the collection by
         * @param {ClusterRangeNetworksListByRangeIdSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterRangeNetworksListByRangeId: async (rangeId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: ClusterRangeNetworksListByRangeIdSortByEnum, sort?: ClusterRangeNetworksListByRangeIdSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('clusterRangeNetworksListByRangeId', 'rangeId', rangeId)
            const localVarPath = `/v1/manage/range/{rangeId}/cluster-range-networks`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an existing in-range cluster range network
         * @summary Retrieve a cluster range network
         * @param {string} rangeId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterRangeNetworksRetrieveByRangeIdUuid: async (rangeId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('clusterRangeNetworksRetrieveByRangeIdUuid', 'rangeId', rangeId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('clusterRangeNetworksRetrieveByRangeIdUuid', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/cluster-range-networks/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesClusterRangeNetworksApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesClusterRangeNetworksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesClusterRangeNetworksApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a cluster range network from a range
         * @summary Deletes a cluster range network
         * @param {string} rangeId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clusterRangeNetworksDeleteByRangeIdUuid(rangeId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clusterRangeNetworksDeleteByRangeIdUuid(rangeId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesClusterRangeNetworksApi.clusterRangeNetworksDeleteByRangeIdUuid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List existing in-range cluster range networks
         * @summary List cluster range networks
         * @param {string} rangeId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {ClusterRangeNetworksListByRangeIdSortByEnum} [sortBy] Key used to sort the collection by
         * @param {ClusterRangeNetworksListByRangeIdSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clusterRangeNetworksListByRangeId(rangeId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: ClusterRangeNetworksListByRangeIdSortByEnum, sort?: ClusterRangeNetworksListByRangeIdSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterRangeNetworksListByRangeId200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clusterRangeNetworksListByRangeId(rangeId, uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesClusterRangeNetworksApi.clusterRangeNetworksListByRangeId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an existing in-range cluster range network
         * @summary Retrieve a cluster range network
         * @param {string} rangeId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clusterRangeNetworksRetrieveByRangeIdUuid(rangeId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedClusterRangeNetwork>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clusterRangeNetworksRetrieveByRangeIdUuid(rangeId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesClusterRangeNetworksApi.clusterRangeNetworksRetrieveByRangeIdUuid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesClusterRangeNetworksApi - factory interface
 * @export
 */
export const ManageRangeResourcesClusterRangeNetworksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesClusterRangeNetworksApiFp(configuration)
    return {
        /**
         * Deletes a cluster range network from a range
         * @summary Deletes a cluster range network
         * @param {string} rangeId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterRangeNetworksDeleteByRangeIdUuid(rangeId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.clusterRangeNetworksDeleteByRangeIdUuid(rangeId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * List existing in-range cluster range networks
         * @summary List cluster range networks
         * @param {string} rangeId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {ClusterRangeNetworksListByRangeIdSortByEnum} [sortBy] Key used to sort the collection by
         * @param {ClusterRangeNetworksListByRangeIdSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterRangeNetworksListByRangeId(rangeId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: ClusterRangeNetworksListByRangeIdSortByEnum, sort?: ClusterRangeNetworksListByRangeIdSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<ClusterRangeNetworksListByRangeId200Response> {
            return localVarFp.clusterRangeNetworksListByRangeId(rangeId, uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an existing in-range cluster range network
         * @summary Retrieve a cluster range network
         * @param {string} rangeId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterRangeNetworksRetrieveByRangeIdUuid(rangeId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<DeployedClusterRangeNetwork> {
            return localVarFp.clusterRangeNetworksRetrieveByRangeIdUuid(rangeId, uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesClusterRangeNetworksApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesClusterRangeNetworksApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesClusterRangeNetworksApi extends BaseAPI {
    /**
     * Deletes a cluster range network from a range
     * @summary Deletes a cluster range network
     * @param {string} rangeId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesClusterRangeNetworksApi
     */
    public clusterRangeNetworksDeleteByRangeIdUuid(rangeId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesClusterRangeNetworksApiFp(this.configuration).clusterRangeNetworksDeleteByRangeIdUuid(rangeId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List existing in-range cluster range networks
     * @summary List cluster range networks
     * @param {string} rangeId 
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {ClusterRangeNetworksListByRangeIdSortByEnum} [sortBy] Key used to sort the collection by
     * @param {ClusterRangeNetworksListByRangeIdSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesClusterRangeNetworksApi
     */
    public clusterRangeNetworksListByRangeId(rangeId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: ClusterRangeNetworksListByRangeIdSortByEnum, sort?: ClusterRangeNetworksListByRangeIdSortEnum, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesClusterRangeNetworksApiFp(this.configuration).clusterRangeNetworksListByRangeId(rangeId, uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an existing in-range cluster range network
     * @summary Retrieve a cluster range network
     * @param {string} rangeId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesClusterRangeNetworksApi
     */
    public clusterRangeNetworksRetrieveByRangeIdUuid(rangeId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesClusterRangeNetworksApiFp(this.configuration).clusterRangeNetworksRetrieveByRangeIdUuid(rangeId, uuid, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ClusterRangeNetworksListByRangeIdSortByEnum = {
    Author: 'author',
    Description: 'description',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Name: 'name'
} as const;
export type ClusterRangeNetworksListByRangeIdSortByEnum = typeof ClusterRangeNetworksListByRangeIdSortByEnum[keyof typeof ClusterRangeNetworksListByRangeIdSortByEnum];
/**
 * @export
 */
export const ClusterRangeNetworksListByRangeIdSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ClusterRangeNetworksListByRangeIdSortEnum = typeof ClusterRangeNetworksListByRangeIdSortEnum[keyof typeof ClusterRangeNetworksListByRangeIdSortEnum];


/**
 * ManageRangeResourcesEventsApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesEventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Activate an event
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedEventsActivate: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedEventsActivate', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedEventsActivate', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedEventsActivate', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/events/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deactivates an event by deleting it from the scenario
         * @summary Deactivate an event
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedEventsDeactivate: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedEventsDeactivate', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedEventsDeactivate', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedEventsDeactivate', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/events/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List active events
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedEventsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedEventsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedEventsList: async (rangeId: string, scenarioId: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedEventsListSortByEnum, sort?: DeployedEventsListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedEventsList', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedEventsList', 'scenarioId', scenarioId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/events`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesEventsApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesEventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesEventsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Activate an event
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedEventsActivate(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedEventsActivate(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesEventsApi.deployedEventsActivate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deactivates an event by deleting it from the scenario
         * @summary Deactivate an event
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedEventsDeactivate(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedEventsDeactivate(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesEventsApi.deployedEventsDeactivate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List active events
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedEventsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedEventsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedEventsList(rangeId: string, scenarioId: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedEventsListSortByEnum, sort?: DeployedEventsListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedEventsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedEventsList(rangeId, scenarioId, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesEventsApi.deployedEventsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesEventsApi - factory interface
 * @export
 */
export const ManageRangeResourcesEventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesEventsApiFp(configuration)
    return {
        /**
         * 
         * @summary Activate an event
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedEventsActivate(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedEventsActivate(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Deactivates an event by deleting it from the scenario
         * @summary Deactivate an event
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedEventsDeactivate(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedEventsDeactivate(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List active events
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedEventsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedEventsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedEventsList(rangeId: string, scenarioId: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedEventsListSortByEnum, sort?: DeployedEventsListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<DeployedEventsList200Response> {
            return localVarFp.deployedEventsList(rangeId, scenarioId, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesEventsApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesEventsApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesEventsApi extends BaseAPI {
    /**
     * 
     * @summary Activate an event
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesEventsApi
     */
    public deployedEventsActivate(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesEventsApiFp(this.configuration).deployedEventsActivate(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deactivates an event by deleting it from the scenario
     * @summary Deactivate an event
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesEventsApi
     */
    public deployedEventsDeactivate(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesEventsApiFp(this.configuration).deployedEventsDeactivate(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List active events
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {DeployedEventsListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {DeployedEventsListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesEventsApi
     */
    public deployedEventsList(rangeId: string, scenarioId: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedEventsListSortByEnum, sort?: DeployedEventsListSortEnum, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesEventsApiFp(this.configuration).deployedEventsList(rangeId, scenarioId, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeployedEventsListSortByEnum = {
    Name: 'name',
    Description: 'description'
} as const;
export type DeployedEventsListSortByEnum = typeof DeployedEventsListSortByEnum[keyof typeof DeployedEventsListSortByEnum];
/**
 * @export
 */
export const DeployedEventsListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type DeployedEventsListSortEnum = typeof DeployedEventsListSortEnum[keyof typeof DeployedEventsListSortEnum];


/**
 * ManageRangeResourcesGhostAgentsApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesGhostAgentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a ghost agent from an in-range scenario
         * @summary Deletes a ghost agent
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedGhostAgentsDelete: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedGhostAgentsDelete', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedGhostAgentsDelete', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedGhostAgentsDelete', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/ghost-agents/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing ghost agents
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedGhostAgentsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedGhostAgentsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedGhostAgentsList: async (rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: DeployedGhostAgentsListSortByEnum, sort?: DeployedGhostAgentsListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedGhostAgentsList', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedGhostAgentsList', 'scenarioId', scenarioId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/ghost-agents`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing ghost agent
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedGhostAgentsRetrieve: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedGhostAgentsRetrieve', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedGhostAgentsRetrieve', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedGhostAgentsRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/ghost-agents/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesGhostAgentsApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesGhostAgentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesGhostAgentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a ghost agent from an in-range scenario
         * @summary Deletes a ghost agent
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedGhostAgentsDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedGhostAgentsDelete(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesGhostAgentsApi.deployedGhostAgentsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing ghost agents
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedGhostAgentsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedGhostAgentsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedGhostAgentsList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: DeployedGhostAgentsListSortByEnum, sort?: DeployedGhostAgentsListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedGhostAgentsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedGhostAgentsList(rangeId, scenarioId, uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesGhostAgentsApi.deployedGhostAgentsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an existing ghost agent
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedGhostAgentsRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedGhostAgent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedGhostAgentsRetrieve(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesGhostAgentsApi.deployedGhostAgentsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesGhostAgentsApi - factory interface
 * @export
 */
export const ManageRangeResourcesGhostAgentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesGhostAgentsApiFp(configuration)
    return {
        /**
         * Deletes a ghost agent from an in-range scenario
         * @summary Deletes a ghost agent
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedGhostAgentsDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedGhostAgentsDelete(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing ghost agents
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedGhostAgentsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedGhostAgentsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedGhostAgentsList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: DeployedGhostAgentsListSortByEnum, sort?: DeployedGhostAgentsListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<DeployedGhostAgentsList200Response> {
            return localVarFp.deployedGhostAgentsList(rangeId, scenarioId, uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing ghost agent
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedGhostAgentsRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<DeployedGhostAgent> {
            return localVarFp.deployedGhostAgentsRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesGhostAgentsApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesGhostAgentsApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesGhostAgentsApi extends BaseAPI {
    /**
     * Deletes a ghost agent from an in-range scenario
     * @summary Deletes a ghost agent
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesGhostAgentsApi
     */
    public deployedGhostAgentsDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesGhostAgentsApiFp(this.configuration).deployedGhostAgentsDelete(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing ghost agents
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {DeployedGhostAgentsListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {DeployedGhostAgentsListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesGhostAgentsApi
     */
    public deployedGhostAgentsList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: DeployedGhostAgentsListSortByEnum, sort?: DeployedGhostAgentsListSortEnum, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesGhostAgentsApiFp(this.configuration).deployedGhostAgentsList(rangeId, scenarioId, uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing ghost agent
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesGhostAgentsApi
     */
    public deployedGhostAgentsRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesGhostAgentsApiFp(this.configuration).deployedGhostAgentsRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeployedGhostAgentsListSortByEnum = {
    Author: 'author',
    Description: 'description',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Name: 'name'
} as const;
export type DeployedGhostAgentsListSortByEnum = typeof DeployedGhostAgentsListSortByEnum[keyof typeof DeployedGhostAgentsListSortByEnum];
/**
 * @export
 */
export const DeployedGhostAgentsListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type DeployedGhostAgentsListSortEnum = typeof DeployedGhostAgentsListSortEnum[keyof typeof DeployedGhostAgentsListSortEnum];


/**
 * ManageRangeResourcesGhostC2ServersApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesGhostC2ServersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a ghost C2 server from an in-range scenario
         * @summary Deletes a ghost C2 server
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedGhostC2ServersDelete: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedGhostC2ServersDelete', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedGhostC2ServersDelete', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedGhostC2ServersDelete', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/ghost-c2-servers/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing ghost C2 servers
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedGhostC2ServersListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedGhostC2ServersListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedGhostC2ServersList: async (rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: DeployedGhostC2ServersListSortByEnum, sort?: DeployedGhostC2ServersListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedGhostC2ServersList', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedGhostC2ServersList', 'scenarioId', scenarioId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/ghost-c2-servers`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing ghost C2 server
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedGhostC2ServersRetrieve: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedGhostC2ServersRetrieve', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedGhostC2ServersRetrieve', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedGhostC2ServersRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/ghost-c2-servers/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesGhostC2ServersApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesGhostC2ServersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesGhostC2ServersApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a ghost C2 server from an in-range scenario
         * @summary Deletes a ghost C2 server
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedGhostC2ServersDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedGhostC2ServersDelete(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesGhostC2ServersApi.deployedGhostC2ServersDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing ghost C2 servers
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedGhostC2ServersListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedGhostC2ServersListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedGhostC2ServersList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: DeployedGhostC2ServersListSortByEnum, sort?: DeployedGhostC2ServersListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedGhostC2ServersList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedGhostC2ServersList(rangeId, scenarioId, uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesGhostC2ServersApi.deployedGhostC2ServersList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an existing ghost C2 server
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedGhostC2ServersRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedGhostC2Server>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedGhostC2ServersRetrieve(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesGhostC2ServersApi.deployedGhostC2ServersRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesGhostC2ServersApi - factory interface
 * @export
 */
export const ManageRangeResourcesGhostC2ServersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesGhostC2ServersApiFp(configuration)
    return {
        /**
         * Deletes a ghost C2 server from an in-range scenario
         * @summary Deletes a ghost C2 server
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedGhostC2ServersDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedGhostC2ServersDelete(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing ghost C2 servers
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedGhostC2ServersListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedGhostC2ServersListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedGhostC2ServersList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: DeployedGhostC2ServersListSortByEnum, sort?: DeployedGhostC2ServersListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<DeployedGhostC2ServersList200Response> {
            return localVarFp.deployedGhostC2ServersList(rangeId, scenarioId, uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing ghost C2 server
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedGhostC2ServersRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<DeployedGhostC2Server> {
            return localVarFp.deployedGhostC2ServersRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesGhostC2ServersApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesGhostC2ServersApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesGhostC2ServersApi extends BaseAPI {
    /**
     * Deletes a ghost C2 server from an in-range scenario
     * @summary Deletes a ghost C2 server
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesGhostC2ServersApi
     */
    public deployedGhostC2ServersDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesGhostC2ServersApiFp(this.configuration).deployedGhostC2ServersDelete(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing ghost C2 servers
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {DeployedGhostC2ServersListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {DeployedGhostC2ServersListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesGhostC2ServersApi
     */
    public deployedGhostC2ServersList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: DeployedGhostC2ServersListSortByEnum, sort?: DeployedGhostC2ServersListSortEnum, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesGhostC2ServersApiFp(this.configuration).deployedGhostC2ServersList(rangeId, scenarioId, uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing ghost C2 server
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesGhostC2ServersApi
     */
    public deployedGhostC2ServersRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesGhostC2ServersApiFp(this.configuration).deployedGhostC2ServersRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeployedGhostC2ServersListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author'
} as const;
export type DeployedGhostC2ServersListSortByEnum = typeof DeployedGhostC2ServersListSortByEnum[keyof typeof DeployedGhostC2ServersListSortByEnum];
/**
 * @export
 */
export const DeployedGhostC2ServersListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type DeployedGhostC2ServersListSortEnum = typeof DeployedGhostC2ServersListSortEnum[keyof typeof DeployedGhostC2ServersListSortEnum];


/**
 * ManageRangeResourcesGhostClientsApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesGhostClientsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a ghost client from an in-range scenario
         * @summary Deletes a ghost client
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedGhostClientsDelete: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedGhostClientsDelete', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedGhostClientsDelete', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedGhostClientsDelete', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/ghost-clients/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing ghost clients
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedGhostClientsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedGhostClientsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedGhostClientsList: async (rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: DeployedGhostClientsListSortByEnum, sort?: DeployedGhostClientsListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedGhostClientsList', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedGhostClientsList', 'scenarioId', scenarioId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/ghost-clients`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing ghost client
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedGhostClientsRetrieve: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedGhostClientsRetrieve', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedGhostClientsRetrieve', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedGhostClientsRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/ghost-clients/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesGhostClientsApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesGhostClientsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesGhostClientsApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a ghost client from an in-range scenario
         * @summary Deletes a ghost client
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedGhostClientsDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedGhostClientsDelete(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesGhostClientsApi.deployedGhostClientsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing ghost clients
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedGhostClientsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedGhostClientsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedGhostClientsList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: DeployedGhostClientsListSortByEnum, sort?: DeployedGhostClientsListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedGhostClientsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedGhostClientsList(rangeId, scenarioId, uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesGhostClientsApi.deployedGhostClientsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an existing ghost client
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedGhostClientsRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedGhostClient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedGhostClientsRetrieve(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesGhostClientsApi.deployedGhostClientsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesGhostClientsApi - factory interface
 * @export
 */
export const ManageRangeResourcesGhostClientsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesGhostClientsApiFp(configuration)
    return {
        /**
         * Deletes a ghost client from an in-range scenario
         * @summary Deletes a ghost client
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedGhostClientsDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedGhostClientsDelete(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing ghost clients
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedGhostClientsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedGhostClientsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedGhostClientsList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: DeployedGhostClientsListSortByEnum, sort?: DeployedGhostClientsListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<DeployedGhostClientsList200Response> {
            return localVarFp.deployedGhostClientsList(rangeId, scenarioId, uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing ghost client
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedGhostClientsRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<DeployedGhostClient> {
            return localVarFp.deployedGhostClientsRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesGhostClientsApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesGhostClientsApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesGhostClientsApi extends BaseAPI {
    /**
     * Deletes a ghost client from an in-range scenario
     * @summary Deletes a ghost client
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesGhostClientsApi
     */
    public deployedGhostClientsDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesGhostClientsApiFp(this.configuration).deployedGhostClientsDelete(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing ghost clients
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {DeployedGhostClientsListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {DeployedGhostClientsListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesGhostClientsApi
     */
    public deployedGhostClientsList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: DeployedGhostClientsListSortByEnum, sort?: DeployedGhostClientsListSortEnum, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesGhostClientsApiFp(this.configuration).deployedGhostClientsList(rangeId, scenarioId, uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing ghost client
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesGhostClientsApi
     */
    public deployedGhostClientsRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesGhostClientsApiFp(this.configuration).deployedGhostClientsRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeployedGhostClientsListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author'
} as const;
export type DeployedGhostClientsListSortByEnum = typeof DeployedGhostClientsListSortByEnum[keyof typeof DeployedGhostClientsListSortByEnum];
/**
 * @export
 */
export const DeployedGhostClientsListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type DeployedGhostClientsListSortEnum = typeof DeployedGhostClientsListSortEnum[keyof typeof DeployedGhostClientsListSortEnum];


/**
 * ManageRangeResourcesGhostMachinesApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesGhostMachinesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List existing ghost machines
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedGhostMachinesList: async (rangeId: string, scenarioId: string, offset?: number, limit?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedGhostMachinesList', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedGhostMachinesList', 'scenarioId', scenarioId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/ghost-machines`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Publishes a traffic profile to a ghost machine
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {DeployedGhostMachinesPublishTrafficProfileRequest} deployedGhostMachinesPublishTrafficProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedGhostMachinesPublishTrafficProfile: async (rangeId: string, scenarioId: string, uuid: string, deployedGhostMachinesPublishTrafficProfileRequest: DeployedGhostMachinesPublishTrafficProfileRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedGhostMachinesPublishTrafficProfile', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedGhostMachinesPublishTrafficProfile', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedGhostMachinesPublishTrafficProfile', 'uuid', uuid)
            // verify required parameter 'deployedGhostMachinesPublishTrafficProfileRequest' is not null or undefined
            assertParamExists('deployedGhostMachinesPublishTrafficProfile', 'deployedGhostMachinesPublishTrafficProfileRequest', deployedGhostMachinesPublishTrafficProfileRequest)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/ghost-machines/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deployedGhostMachinesPublishTrafficProfileRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing ghost machine
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedGhostMachinesRetrieve: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedGhostMachinesRetrieve', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedGhostMachinesRetrieve', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedGhostMachinesRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/ghost-machines/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Persists a machine update request that will take effect on the next periodic update of the ghost machine.
         * @summary Starts executing the current traffic profile
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedGhostMachinesStartMachine: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedGhostMachinesStartMachine', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedGhostMachinesStartMachine', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedGhostMachinesStartMachine', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/ghost-machines/{uuid}/start`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Persists a machine update request that will take effect on the next periodic update of the ghost machine.
         * @summary Stops executing the current traffic profile
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedGhostMachinesStopMachine: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedGhostMachinesStopMachine', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedGhostMachinesStopMachine', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedGhostMachinesStopMachine', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/ghost-machines/{uuid}/stop`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesGhostMachinesApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesGhostMachinesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesGhostMachinesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List existing ghost machines
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedGhostMachinesList(rangeId: string, scenarioId: string, offset?: number, limit?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedGhostMachinesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedGhostMachinesList(rangeId, scenarioId, offset, limit, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesGhostMachinesApi.deployedGhostMachinesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Publishes a traffic profile to a ghost machine
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {DeployedGhostMachinesPublishTrafficProfileRequest} deployedGhostMachinesPublishTrafficProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedGhostMachinesPublishTrafficProfile(rangeId: string, scenarioId: string, uuid: string, deployedGhostMachinesPublishTrafficProfileRequest: DeployedGhostMachinesPublishTrafficProfileRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedGhostMachinesPublishTrafficProfile(rangeId, scenarioId, uuid, deployedGhostMachinesPublishTrafficProfileRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesGhostMachinesApi.deployedGhostMachinesPublishTrafficProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an existing ghost machine
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedGhostMachinesRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GhostMachine>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedGhostMachinesRetrieve(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesGhostMachinesApi.deployedGhostMachinesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Persists a machine update request that will take effect on the next periodic update of the ghost machine.
         * @summary Starts executing the current traffic profile
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedGhostMachinesStartMachine(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedGhostMachinesStartMachine(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesGhostMachinesApi.deployedGhostMachinesStartMachine']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Persists a machine update request that will take effect on the next periodic update of the ghost machine.
         * @summary Stops executing the current traffic profile
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedGhostMachinesStopMachine(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedGhostMachinesStopMachine(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesGhostMachinesApi.deployedGhostMachinesStopMachine']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesGhostMachinesApi - factory interface
 * @export
 */
export const ManageRangeResourcesGhostMachinesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesGhostMachinesApiFp(configuration)
    return {
        /**
         * 
         * @summary List existing ghost machines
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedGhostMachinesList(rangeId: string, scenarioId: string, offset?: number, limit?: number, search?: string, options?: RawAxiosRequestConfig): AxiosPromise<DeployedGhostMachinesList200Response> {
            return localVarFp.deployedGhostMachinesList(rangeId, scenarioId, offset, limit, search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Publishes a traffic profile to a ghost machine
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {DeployedGhostMachinesPublishTrafficProfileRequest} deployedGhostMachinesPublishTrafficProfileRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedGhostMachinesPublishTrafficProfile(rangeId: string, scenarioId: string, uuid: string, deployedGhostMachinesPublishTrafficProfileRequest: DeployedGhostMachinesPublishTrafficProfileRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedGhostMachinesPublishTrafficProfile(rangeId, scenarioId, uuid, deployedGhostMachinesPublishTrafficProfileRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing ghost machine
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedGhostMachinesRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<GhostMachine> {
            return localVarFp.deployedGhostMachinesRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Persists a machine update request that will take effect on the next periodic update of the ghost machine.
         * @summary Starts executing the current traffic profile
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedGhostMachinesStartMachine(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedGhostMachinesStartMachine(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Persists a machine update request that will take effect on the next periodic update of the ghost machine.
         * @summary Stops executing the current traffic profile
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedGhostMachinesStopMachine(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedGhostMachinesStopMachine(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesGhostMachinesApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesGhostMachinesApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesGhostMachinesApi extends BaseAPI {
    /**
     * 
     * @summary List existing ghost machines
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesGhostMachinesApi
     */
    public deployedGhostMachinesList(rangeId: string, scenarioId: string, offset?: number, limit?: number, search?: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesGhostMachinesApiFp(this.configuration).deployedGhostMachinesList(rangeId, scenarioId, offset, limit, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Publishes a traffic profile to a ghost machine
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {DeployedGhostMachinesPublishTrafficProfileRequest} deployedGhostMachinesPublishTrafficProfileRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesGhostMachinesApi
     */
    public deployedGhostMachinesPublishTrafficProfile(rangeId: string, scenarioId: string, uuid: string, deployedGhostMachinesPublishTrafficProfileRequest: DeployedGhostMachinesPublishTrafficProfileRequest, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesGhostMachinesApiFp(this.configuration).deployedGhostMachinesPublishTrafficProfile(rangeId, scenarioId, uuid, deployedGhostMachinesPublishTrafficProfileRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing ghost machine
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesGhostMachinesApi
     */
    public deployedGhostMachinesRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesGhostMachinesApiFp(this.configuration).deployedGhostMachinesRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Persists a machine update request that will take effect on the next periodic update of the ghost machine.
     * @summary Starts executing the current traffic profile
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesGhostMachinesApi
     */
    public deployedGhostMachinesStartMachine(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesGhostMachinesApiFp(this.configuration).deployedGhostMachinesStartMachine(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Persists a machine update request that will take effect on the next periodic update of the ghost machine.
     * @summary Stops executing the current traffic profile
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesGhostMachinesApi
     */
    public deployedGhostMachinesStopMachine(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesGhostMachinesApiFp(this.configuration).deployedGhostMachinesStopMachine(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ManageRangeResourcesGhostTrafficProfilesApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesGhostTrafficProfilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a ghost traffic profile from an in-range scenario
         * @summary Deletes a ghost traffic profile
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedGhostTrafficProfilesDelete: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedGhostTrafficProfilesDelete', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedGhostTrafficProfilesDelete', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedGhostTrafficProfilesDelete', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/ghost-traffic-profiles/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing ghost traffic profiles
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedGhostTrafficProfilesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedGhostTrafficProfilesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedGhostTrafficProfilesList: async (rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: DeployedGhostTrafficProfilesListSortByEnum, sort?: DeployedGhostTrafficProfilesListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedGhostTrafficProfilesList', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedGhostTrafficProfilesList', 'scenarioId', scenarioId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/ghost-traffic-profiles`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing ghost traffic profile
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedGhostTrafficProfilesRetrieve: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedGhostTrafficProfilesRetrieve', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedGhostTrafficProfilesRetrieve', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedGhostTrafficProfilesRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/ghost-traffic-profiles/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesGhostTrafficProfilesApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesGhostTrafficProfilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesGhostTrafficProfilesApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a ghost traffic profile from an in-range scenario
         * @summary Deletes a ghost traffic profile
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedGhostTrafficProfilesDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedGhostTrafficProfilesDelete(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesGhostTrafficProfilesApi.deployedGhostTrafficProfilesDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing ghost traffic profiles
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedGhostTrafficProfilesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedGhostTrafficProfilesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedGhostTrafficProfilesList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: DeployedGhostTrafficProfilesListSortByEnum, sort?: DeployedGhostTrafficProfilesListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedGhostTrafficProfilesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedGhostTrafficProfilesList(rangeId, scenarioId, uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesGhostTrafficProfilesApi.deployedGhostTrafficProfilesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an existing ghost traffic profile
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedGhostTrafficProfilesRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedGhostTrafficProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedGhostTrafficProfilesRetrieve(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesGhostTrafficProfilesApi.deployedGhostTrafficProfilesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesGhostTrafficProfilesApi - factory interface
 * @export
 */
export const ManageRangeResourcesGhostTrafficProfilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesGhostTrafficProfilesApiFp(configuration)
    return {
        /**
         * Deletes a ghost traffic profile from an in-range scenario
         * @summary Deletes a ghost traffic profile
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedGhostTrafficProfilesDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedGhostTrafficProfilesDelete(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing ghost traffic profiles
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedGhostTrafficProfilesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedGhostTrafficProfilesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedGhostTrafficProfilesList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: DeployedGhostTrafficProfilesListSortByEnum, sort?: DeployedGhostTrafficProfilesListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<DeployedGhostTrafficProfilesList200Response> {
            return localVarFp.deployedGhostTrafficProfilesList(rangeId, scenarioId, uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing ghost traffic profile
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedGhostTrafficProfilesRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<DeployedGhostTrafficProfile> {
            return localVarFp.deployedGhostTrafficProfilesRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesGhostTrafficProfilesApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesGhostTrafficProfilesApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesGhostTrafficProfilesApi extends BaseAPI {
    /**
     * Deletes a ghost traffic profile from an in-range scenario
     * @summary Deletes a ghost traffic profile
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesGhostTrafficProfilesApi
     */
    public deployedGhostTrafficProfilesDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesGhostTrafficProfilesApiFp(this.configuration).deployedGhostTrafficProfilesDelete(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing ghost traffic profiles
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {DeployedGhostTrafficProfilesListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {DeployedGhostTrafficProfilesListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesGhostTrafficProfilesApi
     */
    public deployedGhostTrafficProfilesList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: DeployedGhostTrafficProfilesListSortByEnum, sort?: DeployedGhostTrafficProfilesListSortEnum, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesGhostTrafficProfilesApiFp(this.configuration).deployedGhostTrafficProfilesList(rangeId, scenarioId, uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing ghost traffic profile
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesGhostTrafficProfilesApi
     */
    public deployedGhostTrafficProfilesRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesGhostTrafficProfilesApiFp(this.configuration).deployedGhostTrafficProfilesRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeployedGhostTrafficProfilesListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author'
} as const;
export type DeployedGhostTrafficProfilesListSortByEnum = typeof DeployedGhostTrafficProfilesListSortByEnum[keyof typeof DeployedGhostTrafficProfilesListSortByEnum];
/**
 * @export
 */
export const DeployedGhostTrafficProfilesListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type DeployedGhostTrafficProfilesListSortEnum = typeof DeployedGhostTrafficProfilesListSortEnum[keyof typeof DeployedGhostTrafficProfilesListSortEnum];


/**
 * ManageRangeResourcesHardwareDevicesApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesHardwareDevicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a network device
         * @param {string} rangeId 
         * @param {NetworkDeviceCreate} [networkDeviceCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nodesCreate: async (rangeId: string, networkDeviceCreate?: NetworkDeviceCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('nodesCreate', 'rangeId', rangeId)
            const localVarPath = `/v1/manage/range/{rangeId}/hardware-devices/network`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkDeviceCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a network device
         * @param {string} rangeId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nodesDelete: async (rangeId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('nodesDelete', 'rangeId', rangeId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('nodesDelete', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/hardware-devices/network/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List network devices
         * @param {string} rangeId 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nodesList1: async (rangeId: string, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('nodesList1', 'rangeId', rangeId)
            const localVarPath = `/v1/manage/range/{rangeId}/hardware-devices/network`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a network device
         * @param {string} rangeId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nodesRetrieve: async (rangeId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('nodesRetrieve', 'rangeId', rangeId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('nodesRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/hardware-devices/network/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a network device
         * @param {string} rangeId 
         * @param {string} uuid 
         * @param {NetworkDeviceUpdate} [networkDeviceUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nodesUpdate: async (rangeId: string, uuid: string, networkDeviceUpdate?: NetworkDeviceUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('nodesUpdate', 'rangeId', rangeId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('nodesUpdate', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/hardware-devices/network/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkDeviceUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesHardwareDevicesApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesHardwareDevicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesHardwareDevicesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a network device
         * @param {string} rangeId 
         * @param {NetworkDeviceCreate} [networkDeviceCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nodesCreate(rangeId: string, networkDeviceCreate?: NetworkDeviceCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nodesCreate(rangeId, networkDeviceCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesHardwareDevicesApi.nodesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a network device
         * @param {string} rangeId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nodesDelete(rangeId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nodesDelete(rangeId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesHardwareDevicesApi.nodesDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List network devices
         * @param {string} rangeId 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nodesList1(rangeId: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NodesList1200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nodesList1(rangeId, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesHardwareDevicesApi.nodesList1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a network device
         * @param {string} rangeId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nodesRetrieve(rangeId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nodesRetrieve(rangeId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesHardwareDevicesApi.nodesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a network device
         * @param {string} rangeId 
         * @param {string} uuid 
         * @param {NetworkDeviceUpdate} [networkDeviceUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nodesUpdate(rangeId: string, uuid: string, networkDeviceUpdate?: NetworkDeviceUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nodesUpdate(rangeId, uuid, networkDeviceUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesHardwareDevicesApi.nodesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesHardwareDevicesApi - factory interface
 * @export
 */
export const ManageRangeResourcesHardwareDevicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesHardwareDevicesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a network device
         * @param {string} rangeId 
         * @param {NetworkDeviceCreate} [networkDeviceCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nodesCreate(rangeId: string, networkDeviceCreate?: NetworkDeviceCreate, options?: RawAxiosRequestConfig): AxiosPromise<NetworkDevice> {
            return localVarFp.nodesCreate(rangeId, networkDeviceCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a network device
         * @param {string} rangeId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nodesDelete(rangeId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.nodesDelete(rangeId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List network devices
         * @param {string} rangeId 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nodesList1(rangeId: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<NodesList1200Response> {
            return localVarFp.nodesList1(rangeId, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a network device
         * @param {string} rangeId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nodesRetrieve(rangeId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<NetworkDevice> {
            return localVarFp.nodesRetrieve(rangeId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a network device
         * @param {string} rangeId 
         * @param {string} uuid 
         * @param {NetworkDeviceUpdate} [networkDeviceUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nodesUpdate(rangeId: string, uuid: string, networkDeviceUpdate?: NetworkDeviceUpdate, options?: RawAxiosRequestConfig): AxiosPromise<NetworkDevice> {
            return localVarFp.nodesUpdate(rangeId, uuid, networkDeviceUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesHardwareDevicesApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesHardwareDevicesApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesHardwareDevicesApi extends BaseAPI {
    /**
     * 
     * @summary Create a network device
     * @param {string} rangeId 
     * @param {NetworkDeviceCreate} [networkDeviceCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesHardwareDevicesApi
     */
    public nodesCreate(rangeId: string, networkDeviceCreate?: NetworkDeviceCreate, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesHardwareDevicesApiFp(this.configuration).nodesCreate(rangeId, networkDeviceCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a network device
     * @param {string} rangeId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesHardwareDevicesApi
     */
    public nodesDelete(rangeId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesHardwareDevicesApiFp(this.configuration).nodesDelete(rangeId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List network devices
     * @param {string} rangeId 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesHardwareDevicesApi
     */
    public nodesList1(rangeId: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesHardwareDevicesApiFp(this.configuration).nodesList1(rangeId, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a network device
     * @param {string} rangeId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesHardwareDevicesApi
     */
    public nodesRetrieve(rangeId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesHardwareDevicesApiFp(this.configuration).nodesRetrieve(rangeId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a network device
     * @param {string} rangeId 
     * @param {string} uuid 
     * @param {NetworkDeviceUpdate} [networkDeviceUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesHardwareDevicesApi
     */
    public nodesUpdate(rangeId: string, uuid: string, networkDeviceUpdate?: NetworkDeviceUpdate, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesHardwareDevicesApiFp(this.configuration).nodesUpdate(rangeId, uuid, networkDeviceUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ManageRangeResourcesInternetGatewaysApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesInternetGatewaysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes an internet gateway from an in-range scenario
         * @summary Deletes an internet gateway
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedInternetGatewaysDelete: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedInternetGatewaysDelete', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedInternetGatewaysDelete', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedInternetGatewaysDelete', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/internet-gateways/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing internet gateways
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedInternetGatewaysListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedInternetGatewaysListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedInternetGatewaysList: async (rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: DeployedInternetGatewaysListSortByEnum, sort?: DeployedInternetGatewaysListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedInternetGatewaysList', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedInternetGatewaysList', 'scenarioId', scenarioId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/internet-gateways`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing internet gateway
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedInternetGatewaysRetrieve: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedInternetGatewaysRetrieve', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedInternetGatewaysRetrieve', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedInternetGatewaysRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/internet-gateways/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesInternetGatewaysApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesInternetGatewaysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesInternetGatewaysApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes an internet gateway from an in-range scenario
         * @summary Deletes an internet gateway
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedInternetGatewaysDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedInternetGatewaysDelete(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesInternetGatewaysApi.deployedInternetGatewaysDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing internet gateways
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedInternetGatewaysListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedInternetGatewaysListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedInternetGatewaysList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: DeployedInternetGatewaysListSortByEnum, sort?: DeployedInternetGatewaysListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedInternetGatewaysList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedInternetGatewaysList(rangeId, scenarioId, uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesInternetGatewaysApi.deployedInternetGatewaysList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an existing internet gateway
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedInternetGatewaysRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedInternetGateway>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedInternetGatewaysRetrieve(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesInternetGatewaysApi.deployedInternetGatewaysRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesInternetGatewaysApi - factory interface
 * @export
 */
export const ManageRangeResourcesInternetGatewaysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesInternetGatewaysApiFp(configuration)
    return {
        /**
         * Deletes an internet gateway from an in-range scenario
         * @summary Deletes an internet gateway
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedInternetGatewaysDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedInternetGatewaysDelete(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing internet gateways
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedInternetGatewaysListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedInternetGatewaysListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedInternetGatewaysList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: DeployedInternetGatewaysListSortByEnum, sort?: DeployedInternetGatewaysListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<DeployedInternetGatewaysList200Response> {
            return localVarFp.deployedInternetGatewaysList(rangeId, scenarioId, uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing internet gateway
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedInternetGatewaysRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<DeployedInternetGateway> {
            return localVarFp.deployedInternetGatewaysRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesInternetGatewaysApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesInternetGatewaysApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesInternetGatewaysApi extends BaseAPI {
    /**
     * Deletes an internet gateway from an in-range scenario
     * @summary Deletes an internet gateway
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesInternetGatewaysApi
     */
    public deployedInternetGatewaysDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesInternetGatewaysApiFp(this.configuration).deployedInternetGatewaysDelete(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing internet gateways
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {DeployedInternetGatewaysListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {DeployedInternetGatewaysListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesInternetGatewaysApi
     */
    public deployedInternetGatewaysList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: DeployedInternetGatewaysListSortByEnum, sort?: DeployedInternetGatewaysListSortEnum, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesInternetGatewaysApiFp(this.configuration).deployedInternetGatewaysList(rangeId, scenarioId, uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing internet gateway
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesInternetGatewaysApi
     */
    public deployedInternetGatewaysRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesInternetGatewaysApiFp(this.configuration).deployedInternetGatewaysRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeployedInternetGatewaysListSortByEnum = {
    Author: 'author',
    Description: 'description',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Name: 'name'
} as const;
export type DeployedInternetGatewaysListSortByEnum = typeof DeployedInternetGatewaysListSortByEnum[keyof typeof DeployedInternetGatewaysListSortByEnum];
/**
 * @export
 */
export const DeployedInternetGatewaysListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type DeployedInternetGatewaysListSortEnum = typeof DeployedInternetGatewaysListSortEnum[keyof typeof DeployedInternetGatewaysListSortEnum];


/**
 * ManageRangeResourcesNodesApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesNodesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List range nodes
         * @param {string} rangeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nodesListByRangeId: async (rangeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('nodesListByRangeId', 'rangeId', rangeId)
            const localVarPath = `/v1/manage/range/{rangeId}/nodes`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesNodesApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesNodesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesNodesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List range nodes
         * @param {string} rangeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async nodesListByRangeId(rangeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Node>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.nodesListByRangeId(rangeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesNodesApi.nodesListByRangeId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesNodesApi - factory interface
 * @export
 */
export const ManageRangeResourcesNodesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesNodesApiFp(configuration)
    return {
        /**
         * 
         * @summary List range nodes
         * @param {string} rangeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        nodesListByRangeId(rangeId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Node>> {
            return localVarFp.nodesListByRangeId(rangeId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesNodesApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesNodesApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesNodesApi extends BaseAPI {
    /**
     * 
     * @summary List range nodes
     * @param {string} rangeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesNodesApi
     */
    public nodesListByRangeId(rangeId: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesNodesApiFp(this.configuration).nodesListByRangeId(rangeId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ManageRangeResourcesPackagesApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesPackagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a package from a range
         * @summary Deletes a package
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedPackagesDelete: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedPackagesDelete', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedPackagesDelete', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedPackagesDelete', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/packages/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deploys a package to an existing range
         * @summary Deploys a package
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deployedPackagesDeploy: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedPackagesDeploy', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedPackagesDeploy', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedPackagesDeploy', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/packages/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List existing in-range packages
         * @summary List packages
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedPackagesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedPackagesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedPackagesList: async (rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: DeployedPackagesListSortByEnum, sort?: DeployedPackagesListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedPackagesList', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedPackagesList', 'scenarioId', scenarioId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/packages`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an existing in-range package
         * @summary Retrieve a package
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedPackagesRetrieve: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedPackagesRetrieve', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedPackagesRetrieve', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedPackagesRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/packages/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesPackagesApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesPackagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesPackagesApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a package from a range
         * @summary Deletes a package
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedPackagesDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedPackagesDelete(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesPackagesApi.deployedPackagesDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deploys a package to an existing range
         * @summary Deploys a package
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async deployedPackagesDeploy(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedPackagesDeploy(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesPackagesApi.deployedPackagesDeploy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List existing in-range packages
         * @summary List packages
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedPackagesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedPackagesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedPackagesList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: DeployedPackagesListSortByEnum, sort?: DeployedPackagesListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedPackagesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedPackagesList(rangeId, scenarioId, uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesPackagesApi.deployedPackagesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an existing in-range package
         * @summary Retrieve a package
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedPackagesRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedPackageDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedPackagesRetrieve(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesPackagesApi.deployedPackagesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesPackagesApi - factory interface
 * @export
 */
export const ManageRangeResourcesPackagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesPackagesApiFp(configuration)
    return {
        /**
         * Deletes a package from a range
         * @summary Deletes a package
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedPackagesDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedPackagesDelete(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Deploys a package to an existing range
         * @summary Deploys a package
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deployedPackagesDeploy(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedPackagesDeploy(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * List existing in-range packages
         * @summary List packages
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedPackagesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedPackagesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedPackagesList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: DeployedPackagesListSortByEnum, sort?: DeployedPackagesListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<DeployedPackagesList200Response> {
            return localVarFp.deployedPackagesList(rangeId, scenarioId, uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an existing in-range package
         * @summary Retrieve a package
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedPackagesRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<DeployedPackageDetail> {
            return localVarFp.deployedPackagesRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesPackagesApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesPackagesApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesPackagesApi extends BaseAPI {
    /**
     * Deletes a package from a range
     * @summary Deletes a package
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesPackagesApi
     */
    public deployedPackagesDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesPackagesApiFp(this.configuration).deployedPackagesDelete(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deploys a package to an existing range
     * @summary Deploys a package
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesPackagesApi
     */
    public deployedPackagesDeploy(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesPackagesApiFp(this.configuration).deployedPackagesDeploy(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List existing in-range packages
     * @summary List packages
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {DeployedPackagesListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {DeployedPackagesListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesPackagesApi
     */
    public deployedPackagesList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: DeployedPackagesListSortByEnum, sort?: DeployedPackagesListSortEnum, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesPackagesApiFp(this.configuration).deployedPackagesList(rangeId, scenarioId, uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an existing in-range package
     * @summary Retrieve a package
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesPackagesApi
     */
    public deployedPackagesRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesPackagesApiFp(this.configuration).deployedPackagesRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeployedPackagesListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author'
} as const;
export type DeployedPackagesListSortByEnum = typeof DeployedPackagesListSortByEnum[keyof typeof DeployedPackagesListSortByEnum];
/**
 * @export
 */
export const DeployedPackagesListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type DeployedPackagesListSortEnum = typeof DeployedPackagesListSortEnum[keyof typeof DeployedPackagesListSortEnum];


/**
 * ManageRangeResourcesRangeAutoGradersApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesRangeAutoGradersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List all AutoGraders associated with a deployed scenario
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [telemetryAgent] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedAutoGradersListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedAutoGradersListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedAutoGradersList: async (rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, telemetryAgent?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedAutoGradersListSortByEnum, sort?: DeployedAutoGradersListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedAutoGradersList', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedAutoGradersList', 'scenarioId', scenarioId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/auto-graders`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (telemetryAgent !== undefined) {
                localVarQueryParameter['telemetryAgent'] = telemetryAgent;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesRangeAutoGradersApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesRangeAutoGradersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesRangeAutoGradersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List all AutoGraders associated with a deployed scenario
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [telemetryAgent] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedAutoGradersListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedAutoGradersListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedAutoGradersList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, telemetryAgent?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedAutoGradersListSortByEnum, sort?: DeployedAutoGradersListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoGradersList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedAutoGradersList(rangeId, scenarioId, uuid, name, description, author, metadata, telemetryAgent, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeAutoGradersApi.deployedAutoGradersList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesRangeAutoGradersApi - factory interface
 * @export
 */
export const ManageRangeResourcesRangeAutoGradersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesRangeAutoGradersApiFp(configuration)
    return {
        /**
         * 
         * @summary List all AutoGraders associated with a deployed scenario
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [telemetryAgent] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedAutoGradersListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedAutoGradersListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedAutoGradersList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, telemetryAgent?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedAutoGradersListSortByEnum, sort?: DeployedAutoGradersListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<AutoGradersList200Response> {
            return localVarFp.deployedAutoGradersList(rangeId, scenarioId, uuid, name, description, author, metadata, telemetryAgent, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesRangeAutoGradersApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesRangeAutoGradersApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesRangeAutoGradersApi extends BaseAPI {
    /**
     * 
     * @summary List all AutoGraders associated with a deployed scenario
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {string} [telemetryAgent] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {DeployedAutoGradersListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {DeployedAutoGradersListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeAutoGradersApi
     */
    public deployedAutoGradersList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, telemetryAgent?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedAutoGradersListSortByEnum, sort?: DeployedAutoGradersListSortEnum, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeAutoGradersApiFp(this.configuration).deployedAutoGradersList(rangeId, scenarioId, uuid, name, description, author, metadata, telemetryAgent, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeployedAutoGradersListSortByEnum = {
    Author: 'author',
    Description: 'description',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Name: 'name'
} as const;
export type DeployedAutoGradersListSortByEnum = typeof DeployedAutoGradersListSortByEnum[keyof typeof DeployedAutoGradersListSortByEnum];
/**
 * @export
 */
export const DeployedAutoGradersListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type DeployedAutoGradersListSortEnum = typeof DeployedAutoGradersListSortEnum[keyof typeof DeployedAutoGradersListSortEnum];


/**
 * ManageRangeResourcesRangeAutoIPsApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesRangeAutoIPsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a range IP from an in-range scenario
         * @summary Deletes a range auto IP
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeAutoIPsDelete: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeAutoIPsDelete', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeAutoIPsDelete', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeAutoIPsDelete', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-auto-ips/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing range auto IPs
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [address] 
         * @param {string} [countryCode] 
         * @param {string} [cidr] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeAutoIPsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeAutoIPsListSortOrderEnum} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeAutoIPsList: async (rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, address?: string, countryCode?: string, cidr?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeAutoIPsListSortByEnum, sortOrder?: DeployedRangeAutoIPsListSortOrderEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeAutoIPsList', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeAutoIPsList', 'scenarioId', scenarioId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-auto-ips`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (countryCode !== undefined) {
                localVarQueryParameter['countryCode'] = countryCode;
            }

            if (cidr !== undefined) {
                localVarQueryParameter['cidr'] = cidr;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing range auto IP
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeAutoIPsRetrieve: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeAutoIPsRetrieve', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeAutoIPsRetrieve', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeAutoIPsRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-auto-ips/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesRangeAutoIPsApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesRangeAutoIPsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesRangeAutoIPsApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a range IP from an in-range scenario
         * @summary Deletes a range auto IP
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeAutoIPsDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeAutoIPsDelete(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeAutoIPsApi.deployedRangeAutoIPsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing range auto IPs
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [address] 
         * @param {string} [countryCode] 
         * @param {string} [cidr] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeAutoIPsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeAutoIPsListSortOrderEnum} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeAutoIPsList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, address?: string, countryCode?: string, cidr?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeAutoIPsListSortByEnum, sortOrder?: DeployedRangeAutoIPsListSortOrderEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedRangeAutoIPsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeAutoIPsList(rangeId, scenarioId, uuid, name, description, author, metadata, address, countryCode, cidr, offset, limit, search, sortBy, sortOrder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeAutoIPsApi.deployedRangeAutoIPsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an existing range auto IP
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeAutoIPsRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedRangeAutoIP>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeAutoIPsRetrieve(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeAutoIPsApi.deployedRangeAutoIPsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesRangeAutoIPsApi - factory interface
 * @export
 */
export const ManageRangeResourcesRangeAutoIPsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesRangeAutoIPsApiFp(configuration)
    return {
        /**
         * Deletes a range IP from an in-range scenario
         * @summary Deletes a range auto IP
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeAutoIPsDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedRangeAutoIPsDelete(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing range auto IPs
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [address] 
         * @param {string} [countryCode] 
         * @param {string} [cidr] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeAutoIPsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeAutoIPsListSortOrderEnum} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeAutoIPsList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, address?: string, countryCode?: string, cidr?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeAutoIPsListSortByEnum, sortOrder?: DeployedRangeAutoIPsListSortOrderEnum, options?: RawAxiosRequestConfig): AxiosPromise<DeployedRangeAutoIPsList200Response> {
            return localVarFp.deployedRangeAutoIPsList(rangeId, scenarioId, uuid, name, description, author, metadata, address, countryCode, cidr, offset, limit, search, sortBy, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing range auto IP
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeAutoIPsRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<DeployedRangeAutoIP> {
            return localVarFp.deployedRangeAutoIPsRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesRangeAutoIPsApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesRangeAutoIPsApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesRangeAutoIPsApi extends BaseAPI {
    /**
     * Deletes a range IP from an in-range scenario
     * @summary Deletes a range auto IP
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeAutoIPsApi
     */
    public deployedRangeAutoIPsDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeAutoIPsApiFp(this.configuration).deployedRangeAutoIPsDelete(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing range auto IPs
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {string} [address] 
     * @param {string} [countryCode] 
     * @param {string} [cidr] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {DeployedRangeAutoIPsListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {DeployedRangeAutoIPsListSortOrderEnum} [sortOrder] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeAutoIPsApi
     */
    public deployedRangeAutoIPsList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, address?: string, countryCode?: string, cidr?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeAutoIPsListSortByEnum, sortOrder?: DeployedRangeAutoIPsListSortOrderEnum, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeAutoIPsApiFp(this.configuration).deployedRangeAutoIPsList(rangeId, scenarioId, uuid, name, description, author, metadata, address, countryCode, cidr, offset, limit, search, sortBy, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing range auto IP
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeAutoIPsApi
     */
    public deployedRangeAutoIPsRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeAutoIPsApiFp(this.configuration).deployedRangeAutoIPsRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeployedRangeAutoIPsListSortByEnum = {
    Author: 'author',
    Description: 'description',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Name: 'name',
    Address: 'address',
    CountryCode: 'countryCode'
} as const;
export type DeployedRangeAutoIPsListSortByEnum = typeof DeployedRangeAutoIPsListSortByEnum[keyof typeof DeployedRangeAutoIPsListSortByEnum];
/**
 * @export
 */
export const DeployedRangeAutoIPsListSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type DeployedRangeAutoIPsListSortOrderEnum = typeof DeployedRangeAutoIPsListSortOrderEnum[keyof typeof DeployedRangeAutoIPsListSortOrderEnum];


/**
 * ManageRangeResourcesRangeAutoL3NetworksApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesRangeAutoL3NetworksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete an existing range auto L3 network
         * @summary Delete an existing range auto L3 network
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeAutoL3NetworksDelete: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeAutoL3NetworksDelete', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeAutoL3NetworksDelete', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeAutoL3NetworksDelete', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-auto-l3-networks/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing range auto L3 networks
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [cidr] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeAutoL3NetworksListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeAutoL3NetworksListSortOrderEnum} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeAutoL3NetworksList: async (rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, cidr?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeAutoL3NetworksListSortByEnum, sortOrder?: DeployedRangeAutoL3NetworksListSortOrderEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeAutoL3NetworksList', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeAutoL3NetworksList', 'scenarioId', scenarioId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-auto-l3-networks`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (cidr !== undefined) {
                localVarQueryParameter['cidr'] = cidr;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing range auto L3 network
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeAutoL3NetworksRetrieve: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeAutoL3NetworksRetrieve', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeAutoL3NetworksRetrieve', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeAutoL3NetworksRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-auto-l3-networks/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesRangeAutoL3NetworksApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesRangeAutoL3NetworksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesRangeAutoL3NetworksApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete an existing range auto L3 network
         * @summary Delete an existing range auto L3 network
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeAutoL3NetworksDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeAutoL3NetworksDelete(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeAutoL3NetworksApi.deployedRangeAutoL3NetworksDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing range auto L3 networks
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [cidr] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeAutoL3NetworksListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeAutoL3NetworksListSortOrderEnum} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeAutoL3NetworksList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, cidr?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeAutoL3NetworksListSortByEnum, sortOrder?: DeployedRangeAutoL3NetworksListSortOrderEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedRangeAutoL3NetworksList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeAutoL3NetworksList(rangeId, scenarioId, uuid, name, description, author, metadata, cidr, offset, limit, search, sortBy, sortOrder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeAutoL3NetworksApi.deployedRangeAutoL3NetworksList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an existing range auto L3 network
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeAutoL3NetworksRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedRangeAutoL3Network>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeAutoL3NetworksRetrieve(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeAutoL3NetworksApi.deployedRangeAutoL3NetworksRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesRangeAutoL3NetworksApi - factory interface
 * @export
 */
export const ManageRangeResourcesRangeAutoL3NetworksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesRangeAutoL3NetworksApiFp(configuration)
    return {
        /**
         * Delete an existing range auto L3 network
         * @summary Delete an existing range auto L3 network
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeAutoL3NetworksDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedRangeAutoL3NetworksDelete(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing range auto L3 networks
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [cidr] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeAutoL3NetworksListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeAutoL3NetworksListSortOrderEnum} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeAutoL3NetworksList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, cidr?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeAutoL3NetworksListSortByEnum, sortOrder?: DeployedRangeAutoL3NetworksListSortOrderEnum, options?: RawAxiosRequestConfig): AxiosPromise<DeployedRangeAutoL3NetworksList200Response> {
            return localVarFp.deployedRangeAutoL3NetworksList(rangeId, scenarioId, uuid, name, description, author, metadata, cidr, offset, limit, search, sortBy, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing range auto L3 network
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeAutoL3NetworksRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<DeployedRangeAutoL3Network> {
            return localVarFp.deployedRangeAutoL3NetworksRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesRangeAutoL3NetworksApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesRangeAutoL3NetworksApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesRangeAutoL3NetworksApi extends BaseAPI {
    /**
     * Delete an existing range auto L3 network
     * @summary Delete an existing range auto L3 network
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeAutoL3NetworksApi
     */
    public deployedRangeAutoL3NetworksDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeAutoL3NetworksApiFp(this.configuration).deployedRangeAutoL3NetworksDelete(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing range auto L3 networks
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {string} [cidr] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {DeployedRangeAutoL3NetworksListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {DeployedRangeAutoL3NetworksListSortOrderEnum} [sortOrder] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeAutoL3NetworksApi
     */
    public deployedRangeAutoL3NetworksList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, cidr?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeAutoL3NetworksListSortByEnum, sortOrder?: DeployedRangeAutoL3NetworksListSortOrderEnum, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeAutoL3NetworksApiFp(this.configuration).deployedRangeAutoL3NetworksList(rangeId, scenarioId, uuid, name, description, author, metadata, cidr, offset, limit, search, sortBy, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing range auto L3 network
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeAutoL3NetworksApi
     */
    public deployedRangeAutoL3NetworksRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeAutoL3NetworksApiFp(this.configuration).deployedRangeAutoL3NetworksRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeployedRangeAutoL3NetworksListSortByEnum = {
    Author: 'author',
    Description: 'description',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Name: 'name',
    Cidr: 'cidr'
} as const;
export type DeployedRangeAutoL3NetworksListSortByEnum = typeof DeployedRangeAutoL3NetworksListSortByEnum[keyof typeof DeployedRangeAutoL3NetworksListSortByEnum];
/**
 * @export
 */
export const DeployedRangeAutoL3NetworksListSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type DeployedRangeAutoL3NetworksListSortOrderEnum = typeof DeployedRangeAutoL3NetworksListSortOrderEnum[keyof typeof DeployedRangeAutoL3NetworksListSortOrderEnum];


/**
 * ManageRangeResourcesRangeBGPLinksApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesRangeBGPLinksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a range BGPLink from an in-range scenario
         * @summary Deletes a range BGPLink
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeBgpLinksDelete: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeBgpLinksDelete', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeBgpLinksDelete', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeBgpLinksDelete', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-bgp-links/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing range BGP links
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [node1] 
         * @param {number} [node1ASN] 
         * @param {string} [node2] 
         * @param {number} [node2ASN] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeBgpLinksListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeBgpLinksListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeBgpLinksList: async (rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, node1?: string, node1ASN?: number, node2?: string, node2ASN?: number, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeBgpLinksListSortByEnum, sort?: DeployedRangeBgpLinksListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeBgpLinksList', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeBgpLinksList', 'scenarioId', scenarioId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-bgp-links`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (node1 !== undefined) {
                localVarQueryParameter['node1'] = node1;
            }

            if (node1ASN !== undefined) {
                localVarQueryParameter['node1ASN'] = node1ASN;
            }

            if (node2 !== undefined) {
                localVarQueryParameter['node2'] = node2;
            }

            if (node2ASN !== undefined) {
                localVarQueryParameter['node2ASN'] = node2ASN;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing range BGPLink
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeBgpLinksRetrieve: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeBgpLinksRetrieve', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeBgpLinksRetrieve', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeBgpLinksRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-bgp-links/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesRangeBGPLinksApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesRangeBGPLinksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesRangeBGPLinksApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a range BGPLink from an in-range scenario
         * @summary Deletes a range BGPLink
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeBgpLinksDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeBgpLinksDelete(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeBGPLinksApi.deployedRangeBgpLinksDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing range BGP links
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [node1] 
         * @param {number} [node1ASN] 
         * @param {string} [node2] 
         * @param {number} [node2ASN] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeBgpLinksListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeBgpLinksListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeBgpLinksList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, node1?: string, node1ASN?: number, node2?: string, node2ASN?: number, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeBgpLinksListSortByEnum, sort?: DeployedRangeBgpLinksListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedRangeBgpLinksList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeBgpLinksList(rangeId, scenarioId, uuid, name, description, author, metadata, node1, node1ASN, node2, node2ASN, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeBGPLinksApi.deployedRangeBgpLinksList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an existing range BGPLink
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeBgpLinksRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedRangeBGPLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeBgpLinksRetrieve(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeBGPLinksApi.deployedRangeBgpLinksRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesRangeBGPLinksApi - factory interface
 * @export
 */
export const ManageRangeResourcesRangeBGPLinksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesRangeBGPLinksApiFp(configuration)
    return {
        /**
         * Deletes a range BGPLink from an in-range scenario
         * @summary Deletes a range BGPLink
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeBgpLinksDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedRangeBgpLinksDelete(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing range BGP links
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [node1] 
         * @param {number} [node1ASN] 
         * @param {string} [node2] 
         * @param {number} [node2ASN] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeBgpLinksListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeBgpLinksListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeBgpLinksList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, node1?: string, node1ASN?: number, node2?: string, node2ASN?: number, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeBgpLinksListSortByEnum, sort?: DeployedRangeBgpLinksListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<DeployedRangeBgpLinksList200Response> {
            return localVarFp.deployedRangeBgpLinksList(rangeId, scenarioId, uuid, name, description, author, metadata, node1, node1ASN, node2, node2ASN, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing range BGPLink
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeBgpLinksRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<DeployedRangeBGPLink> {
            return localVarFp.deployedRangeBgpLinksRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesRangeBGPLinksApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesRangeBGPLinksApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesRangeBGPLinksApi extends BaseAPI {
    /**
     * Deletes a range BGPLink from an in-range scenario
     * @summary Deletes a range BGPLink
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeBGPLinksApi
     */
    public deployedRangeBgpLinksDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeBGPLinksApiFp(this.configuration).deployedRangeBgpLinksDelete(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing range BGP links
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {string} [node1] 
     * @param {number} [node1ASN] 
     * @param {string} [node2] 
     * @param {number} [node2ASN] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {DeployedRangeBgpLinksListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {DeployedRangeBgpLinksListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeBGPLinksApi
     */
    public deployedRangeBgpLinksList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, node1?: string, node1ASN?: number, node2?: string, node2ASN?: number, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeBgpLinksListSortByEnum, sort?: DeployedRangeBgpLinksListSortEnum, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeBGPLinksApiFp(this.configuration).deployedRangeBgpLinksList(rangeId, scenarioId, uuid, name, description, author, metadata, node1, node1ASN, node2, node2ASN, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing range BGPLink
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeBGPLinksApi
     */
    public deployedRangeBgpLinksRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeBGPLinksApiFp(this.configuration).deployedRangeBgpLinksRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeployedRangeBgpLinksListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author',
    Node1Asn: 'node1ASN',
    Node2Asn: 'node2ASN'
} as const;
export type DeployedRangeBgpLinksListSortByEnum = typeof DeployedRangeBgpLinksListSortByEnum[keyof typeof DeployedRangeBgpLinksListSortByEnum];
/**
 * @export
 */
export const DeployedRangeBgpLinksListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type DeployedRangeBgpLinksListSortEnum = typeof DeployedRangeBgpLinksListSortEnum[keyof typeof DeployedRangeBgpLinksListSortEnum];


/**
 * ManageRangeResourcesRangeBGPsApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesRangeBGPsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a range BGP from an in-range scenario
         * @summary Deletes a range BGP
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeBgPsDelete: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeBgPsDelete', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeBgPsDelete', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeBgPsDelete', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-bgps/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing range BGPs
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [asn] 
         * @param {string} [rangeRouter] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeBgPsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeBgPsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeBgPsList: async (rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, asn?: number, rangeRouter?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeBgPsListSortByEnum, sort?: DeployedRangeBgPsListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeBgPsList', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeBgPsList', 'scenarioId', scenarioId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-bgps`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (asn !== undefined) {
                localVarQueryParameter['asn'] = asn;
            }

            if (rangeRouter !== undefined) {
                localVarQueryParameter['rangeRouter'] = rangeRouter;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing range BGP
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeBgPsRetrieve: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeBgPsRetrieve', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeBgPsRetrieve', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeBgPsRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-bgps/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesRangeBGPsApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesRangeBGPsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesRangeBGPsApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a range BGP from an in-range scenario
         * @summary Deletes a range BGP
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeBgPsDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeBgPsDelete(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeBGPsApi.deployedRangeBgPsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing range BGPs
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [asn] 
         * @param {string} [rangeRouter] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeBgPsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeBgPsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeBgPsList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, asn?: number, rangeRouter?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeBgPsListSortByEnum, sort?: DeployedRangeBgPsListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedRangeBgPsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeBgPsList(rangeId, scenarioId, uuid, name, description, author, metadata, asn, rangeRouter, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeBGPsApi.deployedRangeBgPsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an existing range BGP
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeBgPsRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedRangeBGP>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeBgPsRetrieve(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeBGPsApi.deployedRangeBgPsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesRangeBGPsApi - factory interface
 * @export
 */
export const ManageRangeResourcesRangeBGPsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesRangeBGPsApiFp(configuration)
    return {
        /**
         * Deletes a range BGP from an in-range scenario
         * @summary Deletes a range BGP
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeBgPsDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedRangeBgPsDelete(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing range BGPs
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [asn] 
         * @param {string} [rangeRouter] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeBgPsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeBgPsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeBgPsList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, asn?: number, rangeRouter?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeBgPsListSortByEnum, sort?: DeployedRangeBgPsListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<DeployedRangeBgPsList200Response> {
            return localVarFp.deployedRangeBgPsList(rangeId, scenarioId, uuid, name, description, author, metadata, asn, rangeRouter, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing range BGP
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeBgPsRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<DeployedRangeBGP> {
            return localVarFp.deployedRangeBgPsRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesRangeBGPsApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesRangeBGPsApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesRangeBGPsApi extends BaseAPI {
    /**
     * Deletes a range BGP from an in-range scenario
     * @summary Deletes a range BGP
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeBGPsApi
     */
    public deployedRangeBgPsDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeBGPsApiFp(this.configuration).deployedRangeBgPsDelete(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing range BGPs
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {number} [asn] 
     * @param {string} [rangeRouter] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {DeployedRangeBgPsListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {DeployedRangeBgPsListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeBGPsApi
     */
    public deployedRangeBgPsList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, asn?: number, rangeRouter?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeBgPsListSortByEnum, sort?: DeployedRangeBgPsListSortEnum, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeBGPsApiFp(this.configuration).deployedRangeBgPsList(rangeId, scenarioId, uuid, name, description, author, metadata, asn, rangeRouter, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing range BGP
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeBGPsApi
     */
    public deployedRangeBgPsRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeBGPsApiFp(this.configuration).deployedRangeBgPsRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeployedRangeBgPsListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author',
    Asn: 'asn'
} as const;
export type DeployedRangeBgPsListSortByEnum = typeof DeployedRangeBgPsListSortByEnum[keyof typeof DeployedRangeBgPsListSortByEnum];
/**
 * @export
 */
export const DeployedRangeBgPsListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type DeployedRangeBgPsListSortEnum = typeof DeployedRangeBgPsListSortEnum[keyof typeof DeployedRangeBgPsListSortEnum];


/**
 * ManageRangeResourcesRangeCertificatesApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesRangeCertificatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deploys a range certificate to an in-range scenario
         * @summary Deploy a range certificate
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deployedRangeCertificatesCreate: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeCertificatesCreate', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeCertificatesCreate', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeCertificatesCreate', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-certificates/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a range certificate from an in-range scenario
         * @summary Deletes a range certificate
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeCertificatesDelete: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeCertificatesDelete', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeCertificatesDelete', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeCertificatesDelete', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-certificates/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing range certificates
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [cn] 
         * @param {string} [host] 
         * @param {string} [profile] 
         * @param {string} [rangePki] 
         * @param {boolean} [ready] 
         * @param {string} [status] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeCertificatesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeCertificatesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeCertificatesList: async (rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, cn?: string, host?: string, profile?: string, rangePki?: string, ready?: boolean, status?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeCertificatesListSortByEnum, sort?: DeployedRangeCertificatesListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeCertificatesList', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeCertificatesList', 'scenarioId', scenarioId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-certificates`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (cn !== undefined) {
                localVarQueryParameter['cn'] = cn;
            }

            if (host !== undefined) {
                localVarQueryParameter['host'] = host;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (rangePki !== undefined) {
                localVarQueryParameter['rangePki'] = rangePki;
            }

            if (ready !== undefined) {
                localVarQueryParameter['ready'] = ready;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing range certificate
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeCertificatesRetrieve: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeCertificatesRetrieve', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeCertificatesRetrieve', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeCertificatesRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-certificates/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesRangeCertificatesApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesRangeCertificatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesRangeCertificatesApiAxiosParamCreator(configuration)
    return {
        /**
         * Deploys a range certificate to an in-range scenario
         * @summary Deploy a range certificate
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async deployedRangeCertificatesCreate(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeCertificatesCreate(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeCertificatesApi.deployedRangeCertificatesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a range certificate from an in-range scenario
         * @summary Deletes a range certificate
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeCertificatesDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeCertificatesDelete(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeCertificatesApi.deployedRangeCertificatesDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing range certificates
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [cn] 
         * @param {string} [host] 
         * @param {string} [profile] 
         * @param {string} [rangePki] 
         * @param {boolean} [ready] 
         * @param {string} [status] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeCertificatesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeCertificatesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeCertificatesList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, cn?: string, host?: string, profile?: string, rangePki?: string, ready?: boolean, status?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeCertificatesListSortByEnum, sort?: DeployedRangeCertificatesListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedRangeCertificatesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeCertificatesList(rangeId, scenarioId, uuid, name, description, author, metadata, cn, host, profile, rangePki, ready, status, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeCertificatesApi.deployedRangeCertificatesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an existing range certificate
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeCertificatesRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedRangeCert>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeCertificatesRetrieve(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeCertificatesApi.deployedRangeCertificatesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesRangeCertificatesApi - factory interface
 * @export
 */
export const ManageRangeResourcesRangeCertificatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesRangeCertificatesApiFp(configuration)
    return {
        /**
         * Deploys a range certificate to an in-range scenario
         * @summary Deploy a range certificate
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deployedRangeCertificatesCreate(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedRangeCertificatesCreate(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a range certificate from an in-range scenario
         * @summary Deletes a range certificate
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeCertificatesDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedRangeCertificatesDelete(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing range certificates
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [cn] 
         * @param {string} [host] 
         * @param {string} [profile] 
         * @param {string} [rangePki] 
         * @param {boolean} [ready] 
         * @param {string} [status] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeCertificatesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeCertificatesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeCertificatesList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, cn?: string, host?: string, profile?: string, rangePki?: string, ready?: boolean, status?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeCertificatesListSortByEnum, sort?: DeployedRangeCertificatesListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<DeployedRangeCertificatesList200Response> {
            return localVarFp.deployedRangeCertificatesList(rangeId, scenarioId, uuid, name, description, author, metadata, cn, host, profile, rangePki, ready, status, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing range certificate
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeCertificatesRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<DeployedRangeCert> {
            return localVarFp.deployedRangeCertificatesRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesRangeCertificatesApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesRangeCertificatesApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesRangeCertificatesApi extends BaseAPI {
    /**
     * Deploys a range certificate to an in-range scenario
     * @summary Deploy a range certificate
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeCertificatesApi
     */
    public deployedRangeCertificatesCreate(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeCertificatesApiFp(this.configuration).deployedRangeCertificatesCreate(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a range certificate from an in-range scenario
     * @summary Deletes a range certificate
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeCertificatesApi
     */
    public deployedRangeCertificatesDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeCertificatesApiFp(this.configuration).deployedRangeCertificatesDelete(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing range certificates
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {string} [cn] 
     * @param {string} [host] 
     * @param {string} [profile] 
     * @param {string} [rangePki] 
     * @param {boolean} [ready] 
     * @param {string} [status] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {DeployedRangeCertificatesListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {DeployedRangeCertificatesListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeCertificatesApi
     */
    public deployedRangeCertificatesList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, cn?: string, host?: string, profile?: string, rangePki?: string, ready?: boolean, status?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeCertificatesListSortByEnum, sort?: DeployedRangeCertificatesListSortEnum, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeCertificatesApiFp(this.configuration).deployedRangeCertificatesList(rangeId, scenarioId, uuid, name, description, author, metadata, cn, host, profile, rangePki, ready, status, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing range certificate
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeCertificatesApi
     */
    public deployedRangeCertificatesRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeCertificatesApiFp(this.configuration).deployedRangeCertificatesRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeployedRangeCertificatesListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author',
    Cn: 'cn',
    RangePki: 'rangePki',
    Profile: 'profile',
    Ready: 'ready',
    Status: 'status'
} as const;
export type DeployedRangeCertificatesListSortByEnum = typeof DeployedRangeCertificatesListSortByEnum[keyof typeof DeployedRangeCertificatesListSortByEnum];
/**
 * @export
 */
export const DeployedRangeCertificatesListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type DeployedRangeCertificatesListSortEnum = typeof DeployedRangeCertificatesListSortEnum[keyof typeof DeployedRangeCertificatesListSortEnum];


/**
 * ManageRangeResourcesRangeConsoleAccountsApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesRangeConsoleAccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Credentials returned can be exchanged for a Guacamole token. A Guacamole token for a user can be used to access consoles. This endpoint requires high level permissions.
         * @summary Gets a guacamole credential pair for a user that can be exchanged for a token
         * @param {string} rangeId 
         * @param {RangeConsoleAccountCreate} [rangeConsoleAccountCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeConsoleAccountsCreate: async (rangeId: string, rangeConsoleAccountCreate?: RangeConsoleAccountCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('rangeConsoleAccountsCreate', 'rangeId', rangeId)
            const localVarPath = `/v1/manage/range/{rangeId}/range-console-accounts`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeConsoleAccountCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesRangeConsoleAccountsApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesRangeConsoleAccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesRangeConsoleAccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Credentials returned can be exchanged for a Guacamole token. A Guacamole token for a user can be used to access consoles. This endpoint requires high level permissions.
         * @summary Gets a guacamole credential pair for a user that can be exchanged for a token
         * @param {string} rangeId 
         * @param {RangeConsoleAccountCreate} [rangeConsoleAccountCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeConsoleAccountsCreate(rangeId: string, rangeConsoleAccountCreate?: RangeConsoleAccountCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeConsoleAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeConsoleAccountsCreate(rangeId, rangeConsoleAccountCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeConsoleAccountsApi.rangeConsoleAccountsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesRangeConsoleAccountsApi - factory interface
 * @export
 */
export const ManageRangeResourcesRangeConsoleAccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesRangeConsoleAccountsApiFp(configuration)
    return {
        /**
         * Credentials returned can be exchanged for a Guacamole token. A Guacamole token for a user can be used to access consoles. This endpoint requires high level permissions.
         * @summary Gets a guacamole credential pair for a user that can be exchanged for a token
         * @param {string} rangeId 
         * @param {RangeConsoleAccountCreate} [rangeConsoleAccountCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeConsoleAccountsCreate(rangeId: string, rangeConsoleAccountCreate?: RangeConsoleAccountCreate, options?: RawAxiosRequestConfig): AxiosPromise<RangeConsoleAccount> {
            return localVarFp.rangeConsoleAccountsCreate(rangeId, rangeConsoleAccountCreate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesRangeConsoleAccountsApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesRangeConsoleAccountsApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesRangeConsoleAccountsApi extends BaseAPI {
    /**
     * Credentials returned can be exchanged for a Guacamole token. A Guacamole token for a user can be used to access consoles. This endpoint requires high level permissions.
     * @summary Gets a guacamole credential pair for a user that can be exchanged for a token
     * @param {string} rangeId 
     * @param {RangeConsoleAccountCreate} [rangeConsoleAccountCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeConsoleAccountsApi
     */
    public rangeConsoleAccountsCreate(rangeId: string, rangeConsoleAccountCreate?: RangeConsoleAccountCreate, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeConsoleAccountsApiFp(this.configuration).rangeConsoleAccountsCreate(rangeId, rangeConsoleAccountCreate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ManageRangeResourcesRangeConsolesApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesRangeConsolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List existing range consoles
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [name] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeConsolesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeConsolesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeConsolesList: async (rangeId: string, scenarioId: string, name?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeConsolesListSortByEnum, sort?: DeployedRangeConsolesListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeConsolesList', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeConsolesList', 'scenarioId', scenarioId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-consoles`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a range console
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeConsolesRetrieve: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeConsolesRetrieve', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeConsolesRetrieve', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeConsolesRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-consoles/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the CRD users and groups for a range console
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {InRangeRangeConsoleUpdate} [inRangeRangeConsoleUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeConsolesUpdateConsoleUserAdjustment: async (rangeId: string, scenarioId: string, uuid: string, inRangeRangeConsoleUpdate?: InRangeRangeConsoleUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeConsolesUpdateConsoleUserAdjustment', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeConsolesUpdateConsoleUserAdjustment', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeConsolesUpdateConsoleUserAdjustment', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-consoles/{uuid}/console-user-adjustment`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inRangeRangeConsoleUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesRangeConsolesApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesRangeConsolesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesRangeConsolesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List existing range consoles
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [name] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeConsolesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeConsolesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeConsolesList(rangeId: string, scenarioId: string, name?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeConsolesListSortByEnum, sort?: DeployedRangeConsolesListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedRangeConsolesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeConsolesList(rangeId, scenarioId, name, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeConsolesApi.deployedRangeConsolesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a range console
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeConsolesRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedRangeConsole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeConsolesRetrieve(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeConsolesApi.deployedRangeConsolesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the CRD users and groups for a range console
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {InRangeRangeConsoleUpdate} [inRangeRangeConsoleUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeConsolesUpdateConsoleUserAdjustment(rangeId: string, scenarioId: string, uuid: string, inRangeRangeConsoleUpdate?: InRangeRangeConsoleUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BackgroundJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeConsolesUpdateConsoleUserAdjustment(rangeId, scenarioId, uuid, inRangeRangeConsoleUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeConsolesApi.deployedRangeConsolesUpdateConsoleUserAdjustment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesRangeConsolesApi - factory interface
 * @export
 */
export const ManageRangeResourcesRangeConsolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesRangeConsolesApiFp(configuration)
    return {
        /**
         * 
         * @summary List existing range consoles
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [name] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeConsolesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeConsolesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeConsolesList(rangeId: string, scenarioId: string, name?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeConsolesListSortByEnum, sort?: DeployedRangeConsolesListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<DeployedRangeConsolesList200Response> {
            return localVarFp.deployedRangeConsolesList(rangeId, scenarioId, name, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a range console
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeConsolesRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<DeployedRangeConsole> {
            return localVarFp.deployedRangeConsolesRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the CRD users and groups for a range console
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {InRangeRangeConsoleUpdate} [inRangeRangeConsoleUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeConsolesUpdateConsoleUserAdjustment(rangeId: string, scenarioId: string, uuid: string, inRangeRangeConsoleUpdate?: InRangeRangeConsoleUpdate, options?: RawAxiosRequestConfig): AxiosPromise<BackgroundJob> {
            return localVarFp.deployedRangeConsolesUpdateConsoleUserAdjustment(rangeId, scenarioId, uuid, inRangeRangeConsoleUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesRangeConsolesApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesRangeConsolesApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesRangeConsolesApi extends BaseAPI {
    /**
     * 
     * @summary List existing range consoles
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} [name] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {DeployedRangeConsolesListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {DeployedRangeConsolesListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeConsolesApi
     */
    public deployedRangeConsolesList(rangeId: string, scenarioId: string, name?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeConsolesListSortByEnum, sort?: DeployedRangeConsolesListSortEnum, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeConsolesApiFp(this.configuration).deployedRangeConsolesList(rangeId, scenarioId, name, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a range console
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeConsolesApi
     */
    public deployedRangeConsolesRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeConsolesApiFp(this.configuration).deployedRangeConsolesRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the CRD users and groups for a range console
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {InRangeRangeConsoleUpdate} [inRangeRangeConsoleUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeConsolesApi
     */
    public deployedRangeConsolesUpdateConsoleUserAdjustment(rangeId: string, scenarioId: string, uuid: string, inRangeRangeConsoleUpdate?: InRangeRangeConsoleUpdate, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeConsolesApiFp(this.configuration).deployedRangeConsolesUpdateConsoleUserAdjustment(rangeId, scenarioId, uuid, inRangeRangeConsoleUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeployedRangeConsolesListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author',
    Url: 'url'
} as const;
export type DeployedRangeConsolesListSortByEnum = typeof DeployedRangeConsolesListSortByEnum[keyof typeof DeployedRangeConsolesListSortByEnum];
/**
 * @export
 */
export const DeployedRangeConsolesListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type DeployedRangeConsolesListSortEnum = typeof DeployedRangeConsolesListSortEnum[keyof typeof DeployedRangeConsolesListSortEnum];


/**
 * ManageRangeResourcesRangeContainersApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesRangeContainersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new range container in a scenario
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        rangeContainersCreate: async (rangeId: string, scenarioId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('rangeContainersCreate', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('rangeContainersCreate', 'scenarioId', scenarioId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-containers`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a range container from an in-range scenario
         * @summary Deletes a range container
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeContainersDelete: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('rangeContainersDelete', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('rangeContainersDelete', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeContainersDelete', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-containers/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing range containers
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [name] 
         * @param {string} [author] 
         * @param {string} [chart] 
         * @param {string} [chartVersion] 
         * @param {string} [status] 
         * @param {string} [containerSpecification] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeContainersListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeContainersListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeContainersList: async (rangeId: string, scenarioId: string, name?: string, author?: string, chart?: string, chartVersion?: string, status?: string, containerSpecification?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeContainersListSortByEnum, sort?: RangeContainersListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('rangeContainersList', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('rangeContainersList', 'scenarioId', scenarioId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-containers`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (chart !== undefined) {
                localVarQueryParameter['chart'] = chart;
            }

            if (chartVersion !== undefined) {
                localVarQueryParameter['chartVersion'] = chartVersion;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (containerSpecification !== undefined) {
                localVarQueryParameter['containerSpecification'] = containerSpecification;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a range container
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeContainersRetrieve: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('rangeContainersRetrieve', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('rangeContainersRetrieve', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeContainersRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-containers/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Scales any associated containers back to their original size
         * @summary Starts a stopped range container
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeContainersStart: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('rangeContainersStart', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('rangeContainersStart', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeContainersStart', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-containers/{uuid}/start`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Scales any associated containers down to 0
         * @summary Stops a range container
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeContainersStop: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('rangeContainersStop', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('rangeContainersStop', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeContainersStop', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-containers/{uuid}/stop`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesRangeContainersApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesRangeContainersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesRangeContainersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates a new range container in a scenario
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async rangeContainersCreate(rangeId: string, scenarioId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeContainersCreate(rangeId, scenarioId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeContainersApi.rangeContainersCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a range container from an in-range scenario
         * @summary Deletes a range container
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeContainersDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeContainersDelete(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeContainersApi.rangeContainersDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing range containers
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [name] 
         * @param {string} [author] 
         * @param {string} [chart] 
         * @param {string} [chartVersion] 
         * @param {string} [status] 
         * @param {string} [containerSpecification] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeContainersListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeContainersListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeContainersList(rangeId: string, scenarioId: string, name?: string, author?: string, chart?: string, chartVersion?: string, status?: string, containerSpecification?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeContainersListSortByEnum, sort?: RangeContainersListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeContainersList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeContainersList(rangeId, scenarioId, name, author, chart, chartVersion, status, containerSpecification, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeContainersApi.rangeContainersList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a range container
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeContainersRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeContainer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeContainersRetrieve(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeContainersApi.rangeContainersRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Scales any associated containers back to their original size
         * @summary Starts a stopped range container
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeContainersStart(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BackgroundJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeContainersStart(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeContainersApi.rangeContainersStart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Scales any associated containers down to 0
         * @summary Stops a range container
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeContainersStop(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BackgroundJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeContainersStop(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeContainersApi.rangeContainersStop']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesRangeContainersApi - factory interface
 * @export
 */
export const ManageRangeResourcesRangeContainersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesRangeContainersApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates a new range container in a scenario
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        rangeContainersCreate(rangeId: string, scenarioId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rangeContainersCreate(rangeId, scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a range container from an in-range scenario
         * @summary Deletes a range container
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeContainersDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rangeContainersDelete(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing range containers
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [name] 
         * @param {string} [author] 
         * @param {string} [chart] 
         * @param {string} [chartVersion] 
         * @param {string} [status] 
         * @param {string} [containerSpecification] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeContainersListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeContainersListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeContainersList(rangeId: string, scenarioId: string, name?: string, author?: string, chart?: string, chartVersion?: string, status?: string, containerSpecification?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeContainersListSortByEnum, sort?: RangeContainersListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<RangeContainersList200Response> {
            return localVarFp.rangeContainersList(rangeId, scenarioId, name, author, chart, chartVersion, status, containerSpecification, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a range container
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeContainersRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<RangeContainer> {
            return localVarFp.rangeContainersRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Scales any associated containers back to their original size
         * @summary Starts a stopped range container
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeContainersStart(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<BackgroundJob> {
            return localVarFp.rangeContainersStart(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Scales any associated containers down to 0
         * @summary Stops a range container
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeContainersStop(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<BackgroundJob> {
            return localVarFp.rangeContainersStop(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesRangeContainersApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesRangeContainersApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesRangeContainersApi extends BaseAPI {
    /**
     * 
     * @summary Creates a new range container in a scenario
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeContainersApi
     */
    public rangeContainersCreate(rangeId: string, scenarioId: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeContainersApiFp(this.configuration).rangeContainersCreate(rangeId, scenarioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a range container from an in-range scenario
     * @summary Deletes a range container
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeContainersApi
     */
    public rangeContainersDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeContainersApiFp(this.configuration).rangeContainersDelete(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing range containers
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} [name] 
     * @param {string} [author] 
     * @param {string} [chart] 
     * @param {string} [chartVersion] 
     * @param {string} [status] 
     * @param {string} [containerSpecification] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {RangeContainersListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {RangeContainersListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeContainersApi
     */
    public rangeContainersList(rangeId: string, scenarioId: string, name?: string, author?: string, chart?: string, chartVersion?: string, status?: string, containerSpecification?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeContainersListSortByEnum, sort?: RangeContainersListSortEnum, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeContainersApiFp(this.configuration).rangeContainersList(rangeId, scenarioId, name, author, chart, chartVersion, status, containerSpecification, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a range container
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeContainersApi
     */
    public rangeContainersRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeContainersApiFp(this.configuration).rangeContainersRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Scales any associated containers back to their original size
     * @summary Starts a stopped range container
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeContainersApi
     */
    public rangeContainersStart(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeContainersApiFp(this.configuration).rangeContainersStart(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Scales any associated containers down to 0
     * @summary Stops a range container
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeContainersApi
     */
    public rangeContainersStop(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeContainersApiFp(this.configuration).rangeContainersStop(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RangeContainersListSortByEnum = {
    Author: 'author',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Name: 'name',
    Uuid: 'uuid',
    Chart: 'chart',
    ChartVersion: 'chartVersion',
    ContainerSpecification: 'containerSpecification',
    Status: 'status'
} as const;
export type RangeContainersListSortByEnum = typeof RangeContainersListSortByEnum[keyof typeof RangeContainersListSortByEnum];
/**
 * @export
 */
export const RangeContainersListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type RangeContainersListSortEnum = typeof RangeContainersListSortEnum[keyof typeof RangeContainersListSortEnum];


/**
 * ManageRangeResourcesRangeDNSRecordsApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesRangeDNSRecordsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deploys a range DNS record to an in-range scenario
         * @summary Deploy range DNS record
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deployedRangeDnsRecordsCreate: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeDnsRecordsCreate', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeDnsRecordsCreate', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeDnsRecordsCreate', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-dns-records/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a range DNS record from an in-range scenario
         * @summary Deletes a range DNS record
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeDnsRecordsDelete: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeDnsRecordsDelete', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeDnsRecordsDelete', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeDnsRecordsDelete', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-dns-records/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing range DNS records
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [rangeDNSZone] 
         * @param {string} [recordClass] 
         * @param {string} [type] 
         * @param {string} [data] 
         * @param {string} [zone] 
         * @param {boolean} [ready] 
         * @param {string} [status] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeDnsRecordsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeDnsRecordsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeDnsRecordsList: async (rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, rangeDNSZone?: string, recordClass?: string, type?: string, data?: string, zone?: string, ready?: boolean, status?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeDnsRecordsListSortByEnum, sort?: DeployedRangeDnsRecordsListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeDnsRecordsList', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeDnsRecordsList', 'scenarioId', scenarioId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-dns-records`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (rangeDNSZone !== undefined) {
                localVarQueryParameter['rangeDNSZone'] = rangeDNSZone;
            }

            if (recordClass !== undefined) {
                localVarQueryParameter['recordClass'] = recordClass;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (data !== undefined) {
                localVarQueryParameter['data'] = data;
            }

            if (zone !== undefined) {
                localVarQueryParameter['zone'] = zone;
            }

            if (ready !== undefined) {
                localVarQueryParameter['ready'] = ready;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing range DNS record
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeDnsRecordsRetrieve: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeDnsRecordsRetrieve', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeDnsRecordsRetrieve', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeDnsRecordsRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-dns-records/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesRangeDNSRecordsApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesRangeDNSRecordsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesRangeDNSRecordsApiAxiosParamCreator(configuration)
    return {
        /**
         * Deploys a range DNS record to an in-range scenario
         * @summary Deploy range DNS record
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async deployedRangeDnsRecordsCreate(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeDnsRecordsCreate(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeDNSRecordsApi.deployedRangeDnsRecordsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a range DNS record from an in-range scenario
         * @summary Deletes a range DNS record
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeDnsRecordsDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeDnsRecordsDelete(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeDNSRecordsApi.deployedRangeDnsRecordsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing range DNS records
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [rangeDNSZone] 
         * @param {string} [recordClass] 
         * @param {string} [type] 
         * @param {string} [data] 
         * @param {string} [zone] 
         * @param {boolean} [ready] 
         * @param {string} [status] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeDnsRecordsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeDnsRecordsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeDnsRecordsList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, rangeDNSZone?: string, recordClass?: string, type?: string, data?: string, zone?: string, ready?: boolean, status?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeDnsRecordsListSortByEnum, sort?: DeployedRangeDnsRecordsListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedRangeDnsRecordsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeDnsRecordsList(rangeId, scenarioId, uuid, name, description, author, metadata, rangeDNSZone, recordClass, type, data, zone, ready, status, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeDNSRecordsApi.deployedRangeDnsRecordsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an existing range DNS record
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeDnsRecordsRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedRangeDNSRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeDnsRecordsRetrieve(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeDNSRecordsApi.deployedRangeDnsRecordsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesRangeDNSRecordsApi - factory interface
 * @export
 */
export const ManageRangeResourcesRangeDNSRecordsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesRangeDNSRecordsApiFp(configuration)
    return {
        /**
         * Deploys a range DNS record to an in-range scenario
         * @summary Deploy range DNS record
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deployedRangeDnsRecordsCreate(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedRangeDnsRecordsCreate(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a range DNS record from an in-range scenario
         * @summary Deletes a range DNS record
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeDnsRecordsDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedRangeDnsRecordsDelete(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing range DNS records
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [rangeDNSZone] 
         * @param {string} [recordClass] 
         * @param {string} [type] 
         * @param {string} [data] 
         * @param {string} [zone] 
         * @param {boolean} [ready] 
         * @param {string} [status] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeDnsRecordsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeDnsRecordsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeDnsRecordsList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, rangeDNSZone?: string, recordClass?: string, type?: string, data?: string, zone?: string, ready?: boolean, status?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeDnsRecordsListSortByEnum, sort?: DeployedRangeDnsRecordsListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<DeployedRangeDnsRecordsList200Response> {
            return localVarFp.deployedRangeDnsRecordsList(rangeId, scenarioId, uuid, name, description, author, metadata, rangeDNSZone, recordClass, type, data, zone, ready, status, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing range DNS record
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeDnsRecordsRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<DeployedRangeDNSRecord> {
            return localVarFp.deployedRangeDnsRecordsRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesRangeDNSRecordsApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesRangeDNSRecordsApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesRangeDNSRecordsApi extends BaseAPI {
    /**
     * Deploys a range DNS record to an in-range scenario
     * @summary Deploy range DNS record
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeDNSRecordsApi
     */
    public deployedRangeDnsRecordsCreate(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeDNSRecordsApiFp(this.configuration).deployedRangeDnsRecordsCreate(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a range DNS record from an in-range scenario
     * @summary Deletes a range DNS record
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeDNSRecordsApi
     */
    public deployedRangeDnsRecordsDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeDNSRecordsApiFp(this.configuration).deployedRangeDnsRecordsDelete(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing range DNS records
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {string} [rangeDNSZone] 
     * @param {string} [recordClass] 
     * @param {string} [type] 
     * @param {string} [data] 
     * @param {string} [zone] 
     * @param {boolean} [ready] 
     * @param {string} [status] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {DeployedRangeDnsRecordsListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {DeployedRangeDnsRecordsListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeDNSRecordsApi
     */
    public deployedRangeDnsRecordsList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, rangeDNSZone?: string, recordClass?: string, type?: string, data?: string, zone?: string, ready?: boolean, status?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeDnsRecordsListSortByEnum, sort?: DeployedRangeDnsRecordsListSortEnum, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeDNSRecordsApiFp(this.configuration).deployedRangeDnsRecordsList(rangeId, scenarioId, uuid, name, description, author, metadata, rangeDNSZone, recordClass, type, data, zone, ready, status, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing range DNS record
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeDNSRecordsApi
     */
    public deployedRangeDnsRecordsRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeDNSRecordsApiFp(this.configuration).deployedRangeDnsRecordsRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeployedRangeDnsRecordsListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author',
    RecordClass: 'recordClass',
    Ttl: 'ttl',
    Type: 'type',
    Data: 'data',
    Zone: 'zone',
    Ready: 'ready',
    Status: 'status'
} as const;
export type DeployedRangeDnsRecordsListSortByEnum = typeof DeployedRangeDnsRecordsListSortByEnum[keyof typeof DeployedRangeDnsRecordsListSortByEnum];
/**
 * @export
 */
export const DeployedRangeDnsRecordsListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type DeployedRangeDnsRecordsListSortEnum = typeof DeployedRangeDnsRecordsListSortEnum[keyof typeof DeployedRangeDnsRecordsListSortEnum];


/**
 * ManageRangeResourcesRangeDNSServersApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesRangeDNSServersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deploys a range DNS server to an in-range scenario
         * @summary Deploy range DNS server
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deployedRangeDnsServersCreate: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeDnsServersCreate', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeDnsServersCreate', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeDnsServersCreate', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-dns-servers/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a range DNS server from an in-range scenario
         * @summary Deletes a range DNS server
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeDnsServersDelete: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeDnsServersDelete', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeDnsServersDelete', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeDnsServersDelete', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-dns-servers/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing range DNS servers
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [type] 
         * @param {string} [tag] 
         * @param {boolean} [ready] 
         * @param {string} [status] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeDnsServersListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeDnsServersListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeDnsServersList: async (rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, type?: string, tag?: string, ready?: boolean, status?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeDnsServersListSortByEnum, sort?: DeployedRangeDnsServersListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeDnsServersList', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeDnsServersList', 'scenarioId', scenarioId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-dns-servers`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (ready !== undefined) {
                localVarQueryParameter['ready'] = ready;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing range DNS server
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeDnsServersRetrieve: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeDnsServersRetrieve', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeDnsServersRetrieve', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeDnsServersRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-dns-servers/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesRangeDNSServersApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesRangeDNSServersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesRangeDNSServersApiAxiosParamCreator(configuration)
    return {
        /**
         * Deploys a range DNS server to an in-range scenario
         * @summary Deploy range DNS server
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async deployedRangeDnsServersCreate(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeDnsServersCreate(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeDNSServersApi.deployedRangeDnsServersCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a range DNS server from an in-range scenario
         * @summary Deletes a range DNS server
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeDnsServersDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeDnsServersDelete(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeDNSServersApi.deployedRangeDnsServersDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing range DNS servers
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [type] 
         * @param {string} [tag] 
         * @param {boolean} [ready] 
         * @param {string} [status] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeDnsServersListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeDnsServersListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeDnsServersList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, type?: string, tag?: string, ready?: boolean, status?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeDnsServersListSortByEnum, sort?: DeployedRangeDnsServersListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedRangeDnsServersList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeDnsServersList(rangeId, scenarioId, uuid, name, description, author, metadata, type, tag, ready, status, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeDNSServersApi.deployedRangeDnsServersList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an existing range DNS server
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeDnsServersRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedRangeDNSServer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeDnsServersRetrieve(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeDNSServersApi.deployedRangeDnsServersRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesRangeDNSServersApi - factory interface
 * @export
 */
export const ManageRangeResourcesRangeDNSServersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesRangeDNSServersApiFp(configuration)
    return {
        /**
         * Deploys a range DNS server to an in-range scenario
         * @summary Deploy range DNS server
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deployedRangeDnsServersCreate(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedRangeDnsServersCreate(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a range DNS server from an in-range scenario
         * @summary Deletes a range DNS server
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeDnsServersDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedRangeDnsServersDelete(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing range DNS servers
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [type] 
         * @param {string} [tag] 
         * @param {boolean} [ready] 
         * @param {string} [status] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeDnsServersListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeDnsServersListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeDnsServersList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, type?: string, tag?: string, ready?: boolean, status?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeDnsServersListSortByEnum, sort?: DeployedRangeDnsServersListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<DeployedRangeDnsServersList200Response> {
            return localVarFp.deployedRangeDnsServersList(rangeId, scenarioId, uuid, name, description, author, metadata, type, tag, ready, status, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing range DNS server
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeDnsServersRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<DeployedRangeDNSServer> {
            return localVarFp.deployedRangeDnsServersRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesRangeDNSServersApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesRangeDNSServersApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesRangeDNSServersApi extends BaseAPI {
    /**
     * Deploys a range DNS server to an in-range scenario
     * @summary Deploy range DNS server
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeDNSServersApi
     */
    public deployedRangeDnsServersCreate(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeDNSServersApiFp(this.configuration).deployedRangeDnsServersCreate(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a range DNS server from an in-range scenario
     * @summary Deletes a range DNS server
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeDNSServersApi
     */
    public deployedRangeDnsServersDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeDNSServersApiFp(this.configuration).deployedRangeDnsServersDelete(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing range DNS servers
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {string} [type] 
     * @param {string} [tag] 
     * @param {boolean} [ready] 
     * @param {string} [status] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {DeployedRangeDnsServersListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {DeployedRangeDnsServersListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeDNSServersApi
     */
    public deployedRangeDnsServersList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, type?: string, tag?: string, ready?: boolean, status?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeDnsServersListSortByEnum, sort?: DeployedRangeDnsServersListSortEnum, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeDNSServersApiFp(this.configuration).deployedRangeDnsServersList(rangeId, scenarioId, uuid, name, description, author, metadata, type, tag, ready, status, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing range DNS server
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeDNSServersApi
     */
    public deployedRangeDnsServersRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeDNSServersApiFp(this.configuration).deployedRangeDnsServersRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeployedRangeDnsServersListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author',
    Type: 'type',
    Ready: 'ready',
    Status: 'status'
} as const;
export type DeployedRangeDnsServersListSortByEnum = typeof DeployedRangeDnsServersListSortByEnum[keyof typeof DeployedRangeDnsServersListSortByEnum];
/**
 * @export
 */
export const DeployedRangeDnsServersListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type DeployedRangeDnsServersListSortEnum = typeof DeployedRangeDnsServersListSortEnum[keyof typeof DeployedRangeDnsServersListSortEnum];


/**
 * ManageRangeResourcesRangeDNSZonesApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesRangeDNSZonesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deploys a range DNS zone to an in-range scenario
         * @summary Deploy range DNS zone
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deployedRangeDnsZonesCreate: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeDnsZonesCreate', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeDnsZonesCreate', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeDnsZonesCreate', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-dns-zones/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a range DNS zone from an in-range scenario
         * @summary Deletes a range DNS zone
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeDnsZonesDelete: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeDnsZonesDelete', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeDnsZonesDelete', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeDnsZonesDelete', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-dns-zones/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing range DNS zones
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [masterNs] 
         * @param {string} [email] 
         * @param {string} [tagSelector] 
         * @param {boolean} [ready] 
         * @param {string} [status] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeDnsZonesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeDnsZonesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeDnsZonesList: async (rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, masterNs?: string, email?: string, tagSelector?: string, ready?: boolean, status?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeDnsZonesListSortByEnum, sort?: DeployedRangeDnsZonesListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeDnsZonesList', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeDnsZonesList', 'scenarioId', scenarioId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-dns-zones`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (masterNs !== undefined) {
                localVarQueryParameter['masterNs'] = masterNs;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (tagSelector !== undefined) {
                localVarQueryParameter['tagSelector'] = tagSelector;
            }

            if (ready !== undefined) {
                localVarQueryParameter['ready'] = ready;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing range DNS zone
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeDnsZonesRetrieve: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeDnsZonesRetrieve', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeDnsZonesRetrieve', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeDnsZonesRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-dns-zones/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesRangeDNSZonesApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesRangeDNSZonesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesRangeDNSZonesApiAxiosParamCreator(configuration)
    return {
        /**
         * Deploys a range DNS zone to an in-range scenario
         * @summary Deploy range DNS zone
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async deployedRangeDnsZonesCreate(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeDnsZonesCreate(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeDNSZonesApi.deployedRangeDnsZonesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a range DNS zone from an in-range scenario
         * @summary Deletes a range DNS zone
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeDnsZonesDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeDnsZonesDelete(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeDNSZonesApi.deployedRangeDnsZonesDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing range DNS zones
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [masterNs] 
         * @param {string} [email] 
         * @param {string} [tagSelector] 
         * @param {boolean} [ready] 
         * @param {string} [status] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeDnsZonesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeDnsZonesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeDnsZonesList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, masterNs?: string, email?: string, tagSelector?: string, ready?: boolean, status?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeDnsZonesListSortByEnum, sort?: DeployedRangeDnsZonesListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedRangeDnsZonesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeDnsZonesList(rangeId, scenarioId, uuid, name, description, author, metadata, masterNs, email, tagSelector, ready, status, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeDNSZonesApi.deployedRangeDnsZonesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an existing range DNS zone
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeDnsZonesRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedRangeDNSZone>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeDnsZonesRetrieve(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeDNSZonesApi.deployedRangeDnsZonesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesRangeDNSZonesApi - factory interface
 * @export
 */
export const ManageRangeResourcesRangeDNSZonesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesRangeDNSZonesApiFp(configuration)
    return {
        /**
         * Deploys a range DNS zone to an in-range scenario
         * @summary Deploy range DNS zone
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deployedRangeDnsZonesCreate(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedRangeDnsZonesCreate(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a range DNS zone from an in-range scenario
         * @summary Deletes a range DNS zone
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeDnsZonesDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedRangeDnsZonesDelete(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing range DNS zones
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [masterNs] 
         * @param {string} [email] 
         * @param {string} [tagSelector] 
         * @param {boolean} [ready] 
         * @param {string} [status] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeDnsZonesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeDnsZonesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeDnsZonesList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, masterNs?: string, email?: string, tagSelector?: string, ready?: boolean, status?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeDnsZonesListSortByEnum, sort?: DeployedRangeDnsZonesListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<DeployedRangeDnsZonesList200Response> {
            return localVarFp.deployedRangeDnsZonesList(rangeId, scenarioId, uuid, name, description, author, metadata, masterNs, email, tagSelector, ready, status, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing range DNS zone
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeDnsZonesRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<DeployedRangeDNSZone> {
            return localVarFp.deployedRangeDnsZonesRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesRangeDNSZonesApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesRangeDNSZonesApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesRangeDNSZonesApi extends BaseAPI {
    /**
     * Deploys a range DNS zone to an in-range scenario
     * @summary Deploy range DNS zone
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeDNSZonesApi
     */
    public deployedRangeDnsZonesCreate(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeDNSZonesApiFp(this.configuration).deployedRangeDnsZonesCreate(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a range DNS zone from an in-range scenario
     * @summary Deletes a range DNS zone
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeDNSZonesApi
     */
    public deployedRangeDnsZonesDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeDNSZonesApiFp(this.configuration).deployedRangeDnsZonesDelete(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing range DNS zones
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {string} [masterNs] 
     * @param {string} [email] 
     * @param {string} [tagSelector] 
     * @param {boolean} [ready] 
     * @param {string} [status] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {DeployedRangeDnsZonesListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {DeployedRangeDnsZonesListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeDNSZonesApi
     */
    public deployedRangeDnsZonesList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, masterNs?: string, email?: string, tagSelector?: string, ready?: boolean, status?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeDnsZonesListSortByEnum, sort?: DeployedRangeDnsZonesListSortEnum, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeDNSZonesApiFp(this.configuration).deployedRangeDnsZonesList(rangeId, scenarioId, uuid, name, description, author, metadata, masterNs, email, tagSelector, ready, status, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing range DNS zone
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeDNSZonesApi
     */
    public deployedRangeDnsZonesRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeDNSZonesApiFp(this.configuration).deployedRangeDnsZonesRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeployedRangeDnsZonesListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author',
    Ready: 'ready',
    Status: 'status'
} as const;
export type DeployedRangeDnsZonesListSortByEnum = typeof DeployedRangeDnsZonesListSortByEnum[keyof typeof DeployedRangeDnsZonesListSortByEnum];
/**
 * @export
 */
export const DeployedRangeDnsZonesListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type DeployedRangeDnsZonesListSortEnum = typeof DeployedRangeDnsZonesListSortEnum[keyof typeof DeployedRangeDnsZonesListSortEnum];


/**
 * ManageRangeResourcesRangeHostNetworksApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesRangeHostNetworksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a range host network from an in-range scenario
         * @summary Deletes a range host network
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeHostNetworksDelete: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeHostNetworksDelete', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeHostNetworksDelete', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeHostNetworksDelete', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-host-networks/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing range host networks
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeHostNetworksListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeHostNetworksListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeHostNetworksList: async (rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeHostNetworksListSortByEnum, sort?: DeployedRangeHostNetworksListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeHostNetworksList', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeHostNetworksList', 'scenarioId', scenarioId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-host-networks`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing range host network
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeHostNetworksRetrieve: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeHostNetworksRetrieve', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeHostNetworksRetrieve', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeHostNetworksRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-host-networks/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesRangeHostNetworksApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesRangeHostNetworksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesRangeHostNetworksApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a range host network from an in-range scenario
         * @summary Deletes a range host network
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeHostNetworksDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeHostNetworksDelete(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeHostNetworksApi.deployedRangeHostNetworksDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing range host networks
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeHostNetworksListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeHostNetworksListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeHostNetworksList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeHostNetworksListSortByEnum, sort?: DeployedRangeHostNetworksListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedRangeHostNetworksList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeHostNetworksList(rangeId, scenarioId, uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeHostNetworksApi.deployedRangeHostNetworksList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an existing range host network
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeHostNetworksRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedRangeHostNetwork>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeHostNetworksRetrieve(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeHostNetworksApi.deployedRangeHostNetworksRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesRangeHostNetworksApi - factory interface
 * @export
 */
export const ManageRangeResourcesRangeHostNetworksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesRangeHostNetworksApiFp(configuration)
    return {
        /**
         * Deletes a range host network from an in-range scenario
         * @summary Deletes a range host network
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeHostNetworksDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedRangeHostNetworksDelete(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing range host networks
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeHostNetworksListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeHostNetworksListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeHostNetworksList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeHostNetworksListSortByEnum, sort?: DeployedRangeHostNetworksListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<DeployedRangeHostNetworksList200Response> {
            return localVarFp.deployedRangeHostNetworksList(rangeId, scenarioId, uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing range host network
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeHostNetworksRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<DeployedRangeHostNetwork> {
            return localVarFp.deployedRangeHostNetworksRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesRangeHostNetworksApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesRangeHostNetworksApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesRangeHostNetworksApi extends BaseAPI {
    /**
     * Deletes a range host network from an in-range scenario
     * @summary Deletes a range host network
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeHostNetworksApi
     */
    public deployedRangeHostNetworksDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeHostNetworksApiFp(this.configuration).deployedRangeHostNetworksDelete(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing range host networks
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {DeployedRangeHostNetworksListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {DeployedRangeHostNetworksListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeHostNetworksApi
     */
    public deployedRangeHostNetworksList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeHostNetworksListSortByEnum, sort?: DeployedRangeHostNetworksListSortEnum, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeHostNetworksApiFp(this.configuration).deployedRangeHostNetworksList(rangeId, scenarioId, uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing range host network
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeHostNetworksApi
     */
    public deployedRangeHostNetworksRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeHostNetworksApiFp(this.configuration).deployedRangeHostNetworksRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeployedRangeHostNetworksListSortByEnum = {
    Author: 'author',
    Description: 'description',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Name: 'name'
} as const;
export type DeployedRangeHostNetworksListSortByEnum = typeof DeployedRangeHostNetworksListSortByEnum[keyof typeof DeployedRangeHostNetworksListSortByEnum];
/**
 * @export
 */
export const DeployedRangeHostNetworksListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type DeployedRangeHostNetworksListSortEnum = typeof DeployedRangeHostNetworksListSortEnum[keyof typeof DeployedRangeHostNetworksListSortEnum];


/**
 * ManageRangeResourcesRangeIPsApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesRangeIPsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deploys a range IP to an in-range scenario
         * @summary Deploy a range IP
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deployedRangeIPsCreate: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeIPsCreate', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeIPsCreate', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeIPsCreate', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-ips/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a range IP from an in-range scenario
         * @summary Deletes a range IP
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeIPsDelete: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeIPsDelete', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeIPsDelete', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeIPsDelete', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-ips/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing range IPs
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [address] 
         * @param {string} [countryCode] 
         * @param {boolean} [controlNet] 
         * @param {boolean} [ready] 
         * @param {string} [status] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeIPsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeIPsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeIPsList: async (rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, address?: string, countryCode?: string, controlNet?: boolean, ready?: boolean, status?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeIPsListSortByEnum, sort?: DeployedRangeIPsListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeIPsList', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeIPsList', 'scenarioId', scenarioId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-ips`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (countryCode !== undefined) {
                localVarQueryParameter['countryCode'] = countryCode;
            }

            if (controlNet !== undefined) {
                localVarQueryParameter['controlNet'] = controlNet;
            }

            if (ready !== undefined) {
                localVarQueryParameter['ready'] = ready;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing range IP
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeIPsRetrieve: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeIPsRetrieve', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeIPsRetrieve', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeIPsRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-ips/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesRangeIPsApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesRangeIPsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesRangeIPsApiAxiosParamCreator(configuration)
    return {
        /**
         * Deploys a range IP to an in-range scenario
         * @summary Deploy a range IP
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async deployedRangeIPsCreate(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeIPsCreate(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeIPsApi.deployedRangeIPsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a range IP from an in-range scenario
         * @summary Deletes a range IP
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeIPsDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeIPsDelete(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeIPsApi.deployedRangeIPsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing range IPs
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [address] 
         * @param {string} [countryCode] 
         * @param {boolean} [controlNet] 
         * @param {boolean} [ready] 
         * @param {string} [status] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeIPsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeIPsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeIPsList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, address?: string, countryCode?: string, controlNet?: boolean, ready?: boolean, status?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeIPsListSortByEnum, sort?: DeployedRangeIPsListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedRangeIPsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeIPsList(rangeId, scenarioId, uuid, name, description, author, metadata, address, countryCode, controlNet, ready, status, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeIPsApi.deployedRangeIPsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an existing range IP
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeIPsRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedRangeIP>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeIPsRetrieve(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeIPsApi.deployedRangeIPsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesRangeIPsApi - factory interface
 * @export
 */
export const ManageRangeResourcesRangeIPsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesRangeIPsApiFp(configuration)
    return {
        /**
         * Deploys a range IP to an in-range scenario
         * @summary Deploy a range IP
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deployedRangeIPsCreate(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedRangeIPsCreate(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a range IP from an in-range scenario
         * @summary Deletes a range IP
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeIPsDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedRangeIPsDelete(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing range IPs
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [address] 
         * @param {string} [countryCode] 
         * @param {boolean} [controlNet] 
         * @param {boolean} [ready] 
         * @param {string} [status] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeIPsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeIPsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeIPsList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, address?: string, countryCode?: string, controlNet?: boolean, ready?: boolean, status?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeIPsListSortByEnum, sort?: DeployedRangeIPsListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<DeployedRangeIPsList200Response> {
            return localVarFp.deployedRangeIPsList(rangeId, scenarioId, uuid, name, description, author, metadata, address, countryCode, controlNet, ready, status, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing range IP
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeIPsRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<DeployedRangeIP> {
            return localVarFp.deployedRangeIPsRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesRangeIPsApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesRangeIPsApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesRangeIPsApi extends BaseAPI {
    /**
     * Deploys a range IP to an in-range scenario
     * @summary Deploy a range IP
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeIPsApi
     */
    public deployedRangeIPsCreate(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeIPsApiFp(this.configuration).deployedRangeIPsCreate(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a range IP from an in-range scenario
     * @summary Deletes a range IP
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeIPsApi
     */
    public deployedRangeIPsDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeIPsApiFp(this.configuration).deployedRangeIPsDelete(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing range IPs
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {string} [address] 
     * @param {string} [countryCode] 
     * @param {boolean} [controlNet] 
     * @param {boolean} [ready] 
     * @param {string} [status] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {DeployedRangeIPsListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {DeployedRangeIPsListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeIPsApi
     */
    public deployedRangeIPsList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, address?: string, countryCode?: string, controlNet?: boolean, ready?: boolean, status?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeIPsListSortByEnum, sort?: DeployedRangeIPsListSortEnum, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeIPsApiFp(this.configuration).deployedRangeIPsList(rangeId, scenarioId, uuid, name, description, author, metadata, address, countryCode, controlNet, ready, status, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing range IP
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeIPsApi
     */
    public deployedRangeIPsRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeIPsApiFp(this.configuration).deployedRangeIPsRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeployedRangeIPsListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author',
    Address: 'address',
    CountryCode: 'countryCode',
    Ready: 'ready',
    Status: 'status'
} as const;
export type DeployedRangeIPsListSortByEnum = typeof DeployedRangeIPsListSortByEnum[keyof typeof DeployedRangeIPsListSortByEnum];
/**
 * @export
 */
export const DeployedRangeIPsListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type DeployedRangeIPsListSortEnum = typeof DeployedRangeIPsListSortEnum[keyof typeof DeployedRangeIPsListSortEnum];


/**
 * ManageRangeResourcesRangeL3NetworksApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesRangeL3NetworksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a range L3 network from an in-range scenario
         * @summary Deletes a range L3 network
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeL3NetworksDelete: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeL3NetworksDelete', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeL3NetworksDelete', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeL3NetworksDelete', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-l3-networks/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing range L3 networks
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [cidr] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeL3NetworksListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeL3NetworksListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeL3NetworksList: async (rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, cidr?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeL3NetworksListSortByEnum, sort?: DeployedRangeL3NetworksListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeL3NetworksList', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeL3NetworksList', 'scenarioId', scenarioId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-l3-networks`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (cidr !== undefined) {
                localVarQueryParameter['cidr'] = cidr;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing range L3 network
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeL3NetworksRetrieve: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeL3NetworksRetrieve', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeL3NetworksRetrieve', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeL3NetworksRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-l3-networks/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesRangeL3NetworksApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesRangeL3NetworksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesRangeL3NetworksApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a range L3 network from an in-range scenario
         * @summary Deletes a range L3 network
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeL3NetworksDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeL3NetworksDelete(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeL3NetworksApi.deployedRangeL3NetworksDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing range L3 networks
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [cidr] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeL3NetworksListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeL3NetworksListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeL3NetworksList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, cidr?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeL3NetworksListSortByEnum, sort?: DeployedRangeL3NetworksListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedRangeL3NetworksList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeL3NetworksList(rangeId, scenarioId, uuid, name, description, author, metadata, cidr, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeL3NetworksApi.deployedRangeL3NetworksList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an existing range L3 network
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeL3NetworksRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedRangeL3Network>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeL3NetworksRetrieve(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeL3NetworksApi.deployedRangeL3NetworksRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesRangeL3NetworksApi - factory interface
 * @export
 */
export const ManageRangeResourcesRangeL3NetworksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesRangeL3NetworksApiFp(configuration)
    return {
        /**
         * Deletes a range L3 network from an in-range scenario
         * @summary Deletes a range L3 network
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeL3NetworksDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedRangeL3NetworksDelete(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing range L3 networks
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [cidr] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeL3NetworksListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeL3NetworksListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeL3NetworksList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, cidr?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeL3NetworksListSortByEnum, sort?: DeployedRangeL3NetworksListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<DeployedRangeL3NetworksList200Response> {
            return localVarFp.deployedRangeL3NetworksList(rangeId, scenarioId, uuid, name, description, author, metadata, cidr, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing range L3 network
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeL3NetworksRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<DeployedRangeL3Network> {
            return localVarFp.deployedRangeL3NetworksRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesRangeL3NetworksApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesRangeL3NetworksApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesRangeL3NetworksApi extends BaseAPI {
    /**
     * Deletes a range L3 network from an in-range scenario
     * @summary Deletes a range L3 network
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeL3NetworksApi
     */
    public deployedRangeL3NetworksDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeL3NetworksApiFp(this.configuration).deployedRangeL3NetworksDelete(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing range L3 networks
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {string} [cidr] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {DeployedRangeL3NetworksListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {DeployedRangeL3NetworksListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeL3NetworksApi
     */
    public deployedRangeL3NetworksList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, cidr?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeL3NetworksListSortByEnum, sort?: DeployedRangeL3NetworksListSortEnum, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeL3NetworksApiFp(this.configuration).deployedRangeL3NetworksList(rangeId, scenarioId, uuid, name, description, author, metadata, cidr, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing range L3 network
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeL3NetworksApi
     */
    public deployedRangeL3NetworksRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeL3NetworksApiFp(this.configuration).deployedRangeL3NetworksRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeployedRangeL3NetworksListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author',
    Cidr: 'cidr'
} as const;
export type DeployedRangeL3NetworksListSortByEnum = typeof DeployedRangeL3NetworksListSortByEnum[keyof typeof DeployedRangeL3NetworksListSortByEnum];
/**
 * @export
 */
export const DeployedRangeL3NetworksListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type DeployedRangeL3NetworksListSortEnum = typeof DeployedRangeL3NetworksListSortEnum[keyof typeof DeployedRangeL3NetworksListSortEnum];


/**
 * ManageRangeResourcesRangeNetworksApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesRangeNetworksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a range network from an in-range scenario
         * @summary Deletes a range network
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeNetworksDelete: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeNetworksDelete', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeNetworksDelete', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeNetworksDelete', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-networks/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing range networks
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeNetworksListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeNetworksListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeNetworksList: async (rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeNetworksListSortByEnum, sort?: DeployedRangeNetworksListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeNetworksList', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeNetworksList', 'scenarioId', scenarioId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-networks`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing range network
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeNetworksRetrieve: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeNetworksRetrieve', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeNetworksRetrieve', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeNetworksRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-networks/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesRangeNetworksApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesRangeNetworksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesRangeNetworksApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a range network from an in-range scenario
         * @summary Deletes a range network
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeNetworksDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeNetworksDelete(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeNetworksApi.deployedRangeNetworksDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing range networks
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeNetworksListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeNetworksListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeNetworksList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeNetworksListSortByEnum, sort?: DeployedRangeNetworksListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedRangeNetworksList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeNetworksList(rangeId, scenarioId, uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeNetworksApi.deployedRangeNetworksList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an existing range network
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeNetworksRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedRangeNetwork>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeNetworksRetrieve(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeNetworksApi.deployedRangeNetworksRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesRangeNetworksApi - factory interface
 * @export
 */
export const ManageRangeResourcesRangeNetworksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesRangeNetworksApiFp(configuration)
    return {
        /**
         * Deletes a range network from an in-range scenario
         * @summary Deletes a range network
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeNetworksDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedRangeNetworksDelete(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing range networks
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeNetworksListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeNetworksListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeNetworksList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeNetworksListSortByEnum, sort?: DeployedRangeNetworksListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<DeployedRangeNetworksList200Response> {
            return localVarFp.deployedRangeNetworksList(rangeId, scenarioId, uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing range network
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeNetworksRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<DeployedRangeNetwork> {
            return localVarFp.deployedRangeNetworksRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesRangeNetworksApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesRangeNetworksApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesRangeNetworksApi extends BaseAPI {
    /**
     * Deletes a range network from an in-range scenario
     * @summary Deletes a range network
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeNetworksApi
     */
    public deployedRangeNetworksDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeNetworksApiFp(this.configuration).deployedRangeNetworksDelete(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing range networks
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {DeployedRangeNetworksListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {DeployedRangeNetworksListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeNetworksApi
     */
    public deployedRangeNetworksList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeNetworksListSortByEnum, sort?: DeployedRangeNetworksListSortEnum, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeNetworksApiFp(this.configuration).deployedRangeNetworksList(rangeId, scenarioId, uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing range network
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeNetworksApi
     */
    public deployedRangeNetworksRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeNetworksApiFp(this.configuration).deployedRangeNetworksRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeployedRangeNetworksListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author'
} as const;
export type DeployedRangeNetworksListSortByEnum = typeof DeployedRangeNetworksListSortByEnum[keyof typeof DeployedRangeNetworksListSortByEnum];
/**
 * @export
 */
export const DeployedRangeNetworksListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type DeployedRangeNetworksListSortEnum = typeof DeployedRangeNetworksListSortEnum[keyof typeof DeployedRangeNetworksListSortEnum];


/**
 * ManageRangeResourcesRangePKIsApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesRangePKIsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a range PKI from an in-range scenario
         * @summary Deletes a range PKI
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangePkIsDelete: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangePkIsDelete', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangePkIsDelete', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangePkIsDelete', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-pkis/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing range PKIs
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [parentCAHost] 
         * @param {boolean} [ready] 
         * @param {string} [status] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangePkIsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangePkIsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangePkIsList: async (rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, parentCAHost?: string, ready?: boolean, status?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangePkIsListSortByEnum, sort?: DeployedRangePkIsListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangePkIsList', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangePkIsList', 'scenarioId', scenarioId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-pkis`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (parentCAHost !== undefined) {
                localVarQueryParameter['parentCAHost'] = parentCAHost;
            }

            if (ready !== undefined) {
                localVarQueryParameter['ready'] = ready;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing range PKI
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangePkIsRetrieve: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangePkIsRetrieve', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangePkIsRetrieve', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangePkIsRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-pkis/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesRangePKIsApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesRangePKIsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesRangePKIsApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a range PKI from an in-range scenario
         * @summary Deletes a range PKI
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangePkIsDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangePkIsDelete(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangePKIsApi.deployedRangePkIsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing range PKIs
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [parentCAHost] 
         * @param {boolean} [ready] 
         * @param {string} [status] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangePkIsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangePkIsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangePkIsList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, parentCAHost?: string, ready?: boolean, status?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangePkIsListSortByEnum, sort?: DeployedRangePkIsListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedRangePkIsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangePkIsList(rangeId, scenarioId, uuid, name, description, author, metadata, parentCAHost, ready, status, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangePKIsApi.deployedRangePkIsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an existing range PKI
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangePkIsRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedRangePki>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangePkIsRetrieve(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangePKIsApi.deployedRangePkIsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesRangePKIsApi - factory interface
 * @export
 */
export const ManageRangeResourcesRangePKIsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesRangePKIsApiFp(configuration)
    return {
        /**
         * Deletes a range PKI from an in-range scenario
         * @summary Deletes a range PKI
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangePkIsDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedRangePkIsDelete(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing range PKIs
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [parentCAHost] 
         * @param {boolean} [ready] 
         * @param {string} [status] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangePkIsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangePkIsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangePkIsList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, parentCAHost?: string, ready?: boolean, status?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangePkIsListSortByEnum, sort?: DeployedRangePkIsListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<DeployedRangePkIsList200Response> {
            return localVarFp.deployedRangePkIsList(rangeId, scenarioId, uuid, name, description, author, metadata, parentCAHost, ready, status, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing range PKI
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangePkIsRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<DeployedRangePki> {
            return localVarFp.deployedRangePkIsRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesRangePKIsApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesRangePKIsApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesRangePKIsApi extends BaseAPI {
    /**
     * Deletes a range PKI from an in-range scenario
     * @summary Deletes a range PKI
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangePKIsApi
     */
    public deployedRangePkIsDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangePKIsApiFp(this.configuration).deployedRangePkIsDelete(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing range PKIs
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {string} [parentCAHost] 
     * @param {boolean} [ready] 
     * @param {string} [status] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {DeployedRangePkIsListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {DeployedRangePkIsListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangePKIsApi
     */
    public deployedRangePkIsList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, parentCAHost?: string, ready?: boolean, status?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangePkIsListSortByEnum, sort?: DeployedRangePkIsListSortEnum, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangePKIsApiFp(this.configuration).deployedRangePkIsList(rangeId, scenarioId, uuid, name, description, author, metadata, parentCAHost, ready, status, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing range PKI
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangePKIsApi
     */
    public deployedRangePkIsRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangePKIsApiFp(this.configuration).deployedRangePkIsRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeployedRangePkIsListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author',
    ParentCaHost: 'parentCAHost',
    Ready: 'ready',
    Status: 'status'
} as const;
export type DeployedRangePkIsListSortByEnum = typeof DeployedRangePkIsListSortByEnum[keyof typeof DeployedRangePkIsListSortByEnum];
/**
 * @export
 */
export const DeployedRangePkIsListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type DeployedRangePkIsListSortEnum = typeof DeployedRangePkIsListSortEnum[keyof typeof DeployedRangePkIsListSortEnum];


/**
 * ManageRangeResourcesRangeRoutersApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesRangeRoutersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a range router from an in-range scenario
         * @summary Deletes a range router
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeRoutersDelete: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeRoutersDelete', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeRoutersDelete', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeRoutersDelete', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-routers/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing range routers
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [countryCode] 
         * @param {string} [hostname] 
         * @param {string} [protocol] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeRoutersListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeRoutersListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeRoutersList: async (rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, countryCode?: string, hostname?: string, protocol?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeRoutersListSortByEnum, sort?: DeployedRangeRoutersListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeRoutersList', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeRoutersList', 'scenarioId', scenarioId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-routers`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (countryCode !== undefined) {
                localVarQueryParameter['countryCode'] = countryCode;
            }

            if (hostname !== undefined) {
                localVarQueryParameter['hostname'] = hostname;
            }

            if (protocol !== undefined) {
                localVarQueryParameter['protocol'] = protocol;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing range router
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeRoutersRetrieve: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeRoutersRetrieve', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeRoutersRetrieve', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeRoutersRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-routers/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesRangeRoutersApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesRangeRoutersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesRangeRoutersApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a range router from an in-range scenario
         * @summary Deletes a range router
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeRoutersDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeRoutersDelete(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeRoutersApi.deployedRangeRoutersDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing range routers
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [countryCode] 
         * @param {string} [hostname] 
         * @param {string} [protocol] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeRoutersListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeRoutersListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeRoutersList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, countryCode?: string, hostname?: string, protocol?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeRoutersListSortByEnum, sort?: DeployedRangeRoutersListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedRangeRoutersList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeRoutersList(rangeId, scenarioId, uuid, name, description, author, metadata, countryCode, hostname, protocol, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeRoutersApi.deployedRangeRoutersList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an existing range router
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeRoutersRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedRangeRouter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeRoutersRetrieve(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeRoutersApi.deployedRangeRoutersRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesRangeRoutersApi - factory interface
 * @export
 */
export const ManageRangeResourcesRangeRoutersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesRangeRoutersApiFp(configuration)
    return {
        /**
         * Deletes a range router from an in-range scenario
         * @summary Deletes a range router
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeRoutersDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedRangeRoutersDelete(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing range routers
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [countryCode] 
         * @param {string} [hostname] 
         * @param {string} [protocol] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeRoutersListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeRoutersListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeRoutersList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, countryCode?: string, hostname?: string, protocol?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeRoutersListSortByEnum, sort?: DeployedRangeRoutersListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<DeployedRangeRoutersList200Response> {
            return localVarFp.deployedRangeRoutersList(rangeId, scenarioId, uuid, name, description, author, metadata, countryCode, hostname, protocol, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing range router
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeRoutersRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<DeployedRangeRouter> {
            return localVarFp.deployedRangeRoutersRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesRangeRoutersApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesRangeRoutersApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesRangeRoutersApi extends BaseAPI {
    /**
     * Deletes a range router from an in-range scenario
     * @summary Deletes a range router
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeRoutersApi
     */
    public deployedRangeRoutersDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeRoutersApiFp(this.configuration).deployedRangeRoutersDelete(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing range routers
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {string} [countryCode] 
     * @param {string} [hostname] 
     * @param {string} [protocol] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {DeployedRangeRoutersListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {DeployedRangeRoutersListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeRoutersApi
     */
    public deployedRangeRoutersList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, countryCode?: string, hostname?: string, protocol?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeRoutersListSortByEnum, sort?: DeployedRangeRoutersListSortEnum, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeRoutersApiFp(this.configuration).deployedRangeRoutersList(rangeId, scenarioId, uuid, name, description, author, metadata, countryCode, hostname, protocol, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing range router
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeRoutersApi
     */
    public deployedRangeRoutersRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeRoutersApiFp(this.configuration).deployedRangeRoutersRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeployedRangeRoutersListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author',
    CountryCode: 'countryCode'
} as const;
export type DeployedRangeRoutersListSortByEnum = typeof DeployedRangeRoutersListSortByEnum[keyof typeof DeployedRangeRoutersListSortByEnum];
/**
 * @export
 */
export const DeployedRangeRoutersListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type DeployedRangeRoutersListSortEnum = typeof DeployedRangeRoutersListSortEnum[keyof typeof DeployedRangeRoutersListSortEnum];


/**
 * ManageRangeResourcesRangeTelemetryAgentsApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesRangeTelemetryAgentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a Telemetry Agent from an in-range scenario
         * @summary Deletes a Telemetry Agent
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedTelemetryAgentsDelete: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedTelemetryAgentsDelete', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedTelemetryAgentsDelete', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedTelemetryAgentsDelete', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-telemetry-agents/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing Telemetry Agents
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {boolean} [ready] 
         * @param {boolean} [status] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedTelemetryAgentsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedTelemetryAgentsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedTelemetryAgentsList: async (rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, ready?: boolean, status?: boolean, offset?: number, limit?: number, search?: string, sortBy?: DeployedTelemetryAgentsListSortByEnum, sort?: DeployedTelemetryAgentsListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedTelemetryAgentsList', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedTelemetryAgentsList', 'scenarioId', scenarioId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-telemetry-agents`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (ready !== undefined) {
                localVarQueryParameter['ready'] = ready;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing Telemetry Agent
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedTelemetryAgentsRetrieve: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedTelemetryAgentsRetrieve', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedTelemetryAgentsRetrieve', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedTelemetryAgentsRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-telemetry-agents/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesRangeTelemetryAgentsApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesRangeTelemetryAgentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesRangeTelemetryAgentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a Telemetry Agent from an in-range scenario
         * @summary Deletes a Telemetry Agent
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedTelemetryAgentsDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedTelemetryAgentsDelete(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeTelemetryAgentsApi.deployedTelemetryAgentsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing Telemetry Agents
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {boolean} [ready] 
         * @param {boolean} [status] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedTelemetryAgentsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedTelemetryAgentsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedTelemetryAgentsList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, ready?: boolean, status?: boolean, offset?: number, limit?: number, search?: string, sortBy?: DeployedTelemetryAgentsListSortByEnum, sort?: DeployedTelemetryAgentsListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedTelemetryAgentsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedTelemetryAgentsList(rangeId, scenarioId, uuid, name, description, author, metadata, ready, status, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeTelemetryAgentsApi.deployedTelemetryAgentsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an existing Telemetry Agent
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedTelemetryAgentsRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedTelemetryAgent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedTelemetryAgentsRetrieve(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeTelemetryAgentsApi.deployedTelemetryAgentsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesRangeTelemetryAgentsApi - factory interface
 * @export
 */
export const ManageRangeResourcesRangeTelemetryAgentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesRangeTelemetryAgentsApiFp(configuration)
    return {
        /**
         * Deletes a Telemetry Agent from an in-range scenario
         * @summary Deletes a Telemetry Agent
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedTelemetryAgentsDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedTelemetryAgentsDelete(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing Telemetry Agents
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {boolean} [ready] 
         * @param {boolean} [status] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedTelemetryAgentsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedTelemetryAgentsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedTelemetryAgentsList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, ready?: boolean, status?: boolean, offset?: number, limit?: number, search?: string, sortBy?: DeployedTelemetryAgentsListSortByEnum, sort?: DeployedTelemetryAgentsListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<DeployedTelemetryAgentsList200Response> {
            return localVarFp.deployedTelemetryAgentsList(rangeId, scenarioId, uuid, name, description, author, metadata, ready, status, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing Telemetry Agent
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedTelemetryAgentsRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<DeployedTelemetryAgent> {
            return localVarFp.deployedTelemetryAgentsRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesRangeTelemetryAgentsApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesRangeTelemetryAgentsApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesRangeTelemetryAgentsApi extends BaseAPI {
    /**
     * Deletes a Telemetry Agent from an in-range scenario
     * @summary Deletes a Telemetry Agent
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeTelemetryAgentsApi
     */
    public deployedTelemetryAgentsDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeTelemetryAgentsApiFp(this.configuration).deployedTelemetryAgentsDelete(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing Telemetry Agents
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {boolean} [ready] 
     * @param {boolean} [status] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {DeployedTelemetryAgentsListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {DeployedTelemetryAgentsListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeTelemetryAgentsApi
     */
    public deployedTelemetryAgentsList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, ready?: boolean, status?: boolean, offset?: number, limit?: number, search?: string, sortBy?: DeployedTelemetryAgentsListSortByEnum, sort?: DeployedTelemetryAgentsListSortEnum, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeTelemetryAgentsApiFp(this.configuration).deployedTelemetryAgentsList(rangeId, scenarioId, uuid, name, description, author, metadata, ready, status, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing Telemetry Agent
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeTelemetryAgentsApi
     */
    public deployedTelemetryAgentsRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeTelemetryAgentsApiFp(this.configuration).deployedTelemetryAgentsRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeployedTelemetryAgentsListSortByEnum = {
    Author: 'author',
    Description: 'description',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Name: 'name'
} as const;
export type DeployedTelemetryAgentsListSortByEnum = typeof DeployedTelemetryAgentsListSortByEnum[keyof typeof DeployedTelemetryAgentsListSortByEnum];
/**
 * @export
 */
export const DeployedTelemetryAgentsListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type DeployedTelemetryAgentsListSortEnum = typeof DeployedTelemetryAgentsListSortEnum[keyof typeof DeployedTelemetryAgentsListSortEnum];


/**
 * ManageRangeResourcesRangeTorNetsApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesRangeTorNetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a range tor net from an in-range scenario
         * @summary Deletes a range tor net
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeTorNetsDelete: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeTorNetsDelete', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeTorNetsDelete', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeTorNetsDelete', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-tor-nets/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing range tor nets
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {DeployedRangeTorNetsListVersionEnum} [version] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeTorNetsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeTorNetsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeTorNetsList: async (rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, version?: DeployedRangeTorNetsListVersionEnum, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeTorNetsListSortByEnum, sort?: DeployedRangeTorNetsListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeTorNetsList', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeTorNetsList', 'scenarioId', scenarioId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-tor-nets`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing range tor net
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeTorNetsRetrieve: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeTorNetsRetrieve', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeTorNetsRetrieve', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeTorNetsRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-tor-nets/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesRangeTorNetsApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesRangeTorNetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesRangeTorNetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a range tor net from an in-range scenario
         * @summary Deletes a range tor net
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeTorNetsDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeTorNetsDelete(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeTorNetsApi.deployedRangeTorNetsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing range tor nets
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {DeployedRangeTorNetsListVersionEnum} [version] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeTorNetsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeTorNetsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeTorNetsList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, version?: DeployedRangeTorNetsListVersionEnum, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeTorNetsListSortByEnum, sort?: DeployedRangeTorNetsListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedRangeTorNetsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeTorNetsList(rangeId, scenarioId, uuid, name, description, author, metadata, version, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeTorNetsApi.deployedRangeTorNetsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an existing range tor net
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeTorNetsRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedRangeTorNet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeTorNetsRetrieve(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeTorNetsApi.deployedRangeTorNetsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesRangeTorNetsApi - factory interface
 * @export
 */
export const ManageRangeResourcesRangeTorNetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesRangeTorNetsApiFp(configuration)
    return {
        /**
         * Deletes a range tor net from an in-range scenario
         * @summary Deletes a range tor net
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeTorNetsDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedRangeTorNetsDelete(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing range tor nets
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {DeployedRangeTorNetsListVersionEnum} [version] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeTorNetsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeTorNetsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeTorNetsList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, version?: DeployedRangeTorNetsListVersionEnum, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeTorNetsListSortByEnum, sort?: DeployedRangeTorNetsListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<DeployedRangeTorNetsList200Response> {
            return localVarFp.deployedRangeTorNetsList(rangeId, scenarioId, uuid, name, description, author, metadata, version, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing range tor net
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeTorNetsRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<DeployedRangeTorNet> {
            return localVarFp.deployedRangeTorNetsRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesRangeTorNetsApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesRangeTorNetsApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesRangeTorNetsApi extends BaseAPI {
    /**
     * Deletes a range tor net from an in-range scenario
     * @summary Deletes a range tor net
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeTorNetsApi
     */
    public deployedRangeTorNetsDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeTorNetsApiFp(this.configuration).deployedRangeTorNetsDelete(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing range tor nets
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {DeployedRangeTorNetsListVersionEnum} [version] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {DeployedRangeTorNetsListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {DeployedRangeTorNetsListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeTorNetsApi
     */
    public deployedRangeTorNetsList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, version?: DeployedRangeTorNetsListVersionEnum, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeTorNetsListSortByEnum, sort?: DeployedRangeTorNetsListSortEnum, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeTorNetsApiFp(this.configuration).deployedRangeTorNetsList(rangeId, scenarioId, uuid, name, description, author, metadata, version, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing range tor net
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeTorNetsApi
     */
    public deployedRangeTorNetsRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeTorNetsApiFp(this.configuration).deployedRangeTorNetsRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeployedRangeTorNetsListVersionEnum = {
    _04711: '0.4.7.11'
} as const;
export type DeployedRangeTorNetsListVersionEnum = typeof DeployedRangeTorNetsListVersionEnum[keyof typeof DeployedRangeTorNetsListVersionEnum];
/**
 * @export
 */
export const DeployedRangeTorNetsListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author',
    Version: 'version'
} as const;
export type DeployedRangeTorNetsListSortByEnum = typeof DeployedRangeTorNetsListSortByEnum[keyof typeof DeployedRangeTorNetsListSortByEnum];
/**
 * @export
 */
export const DeployedRangeTorNetsListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type DeployedRangeTorNetsListSortEnum = typeof DeployedRangeTorNetsListSortEnum[keyof typeof DeployedRangeTorNetsListSortEnum];


/**
 * ManageRangeResourcesRangeTrafficTrackersApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesRangeTrafficTrackersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Deletes a Traffic Tracker from an in-range scenario
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedTrafficTrackersDelete: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedTrafficTrackersDelete', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedTrafficTrackersDelete', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedTrafficTrackersDelete', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-traffic-trackers/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a Traffic Tracker in a scenario
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedTrafficTrackersDeploy: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedTrafficTrackersDeploy', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedTrafficTrackersDeploy', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedTrafficTrackersDeploy', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-traffic-trackers/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing Traffic Trackers
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {boolean} [ready] 
         * @param {boolean} [status] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedTrafficTrackersListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedTrafficTrackersListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedTrafficTrackersList: async (rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, ready?: boolean, status?: boolean, offset?: number, limit?: number, search?: string, sortBy?: DeployedTrafficTrackersListSortByEnum, sort?: DeployedTrafficTrackersListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedTrafficTrackersList', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedTrafficTrackersList', 'scenarioId', scenarioId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-traffic-trackers`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (ready !== undefined) {
                localVarQueryParameter['ready'] = ready;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing Traffic Tracker
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedTrafficTrackersRetrieve: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedTrafficTrackersRetrieve', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedTrafficTrackersRetrieve', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedTrafficTrackersRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-traffic-trackers/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesRangeTrafficTrackersApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesRangeTrafficTrackersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesRangeTrafficTrackersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Deletes a Traffic Tracker from an in-range scenario
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedTrafficTrackersDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedTrafficTrackersDelete(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeTrafficTrackersApi.deployedTrafficTrackersDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates a Traffic Tracker in a scenario
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedTrafficTrackersDeploy(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedTrafficTrackersDeploy(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeTrafficTrackersApi.deployedTrafficTrackersDeploy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing Traffic Trackers
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {boolean} [ready] 
         * @param {boolean} [status] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedTrafficTrackersListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedTrafficTrackersListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedTrafficTrackersList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, ready?: boolean, status?: boolean, offset?: number, limit?: number, search?: string, sortBy?: DeployedTrafficTrackersListSortByEnum, sort?: DeployedTrafficTrackersListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedTrafficTrackersList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedTrafficTrackersList(rangeId, scenarioId, uuid, name, description, author, metadata, ready, status, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeTrafficTrackersApi.deployedTrafficTrackersList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an existing Traffic Tracker
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedTrafficTrackersRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedTrafficTracker>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedTrafficTrackersRetrieve(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeTrafficTrackersApi.deployedTrafficTrackersRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesRangeTrafficTrackersApi - factory interface
 * @export
 */
export const ManageRangeResourcesRangeTrafficTrackersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesRangeTrafficTrackersApiFp(configuration)
    return {
        /**
         * 
         * @summary Deletes a Traffic Tracker from an in-range scenario
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedTrafficTrackersDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedTrafficTrackersDelete(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a Traffic Tracker in a scenario
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedTrafficTrackersDeploy(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedTrafficTrackersDeploy(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing Traffic Trackers
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {boolean} [ready] 
         * @param {boolean} [status] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedTrafficTrackersListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedTrafficTrackersListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedTrafficTrackersList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, ready?: boolean, status?: boolean, offset?: number, limit?: number, search?: string, sortBy?: DeployedTrafficTrackersListSortByEnum, sort?: DeployedTrafficTrackersListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<DeployedTrafficTrackersList200Response> {
            return localVarFp.deployedTrafficTrackersList(rangeId, scenarioId, uuid, name, description, author, metadata, ready, status, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing Traffic Tracker
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedTrafficTrackersRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<DeployedTrafficTracker> {
            return localVarFp.deployedTrafficTrackersRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesRangeTrafficTrackersApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesRangeTrafficTrackersApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesRangeTrafficTrackersApi extends BaseAPI {
    /**
     * 
     * @summary Deletes a Traffic Tracker from an in-range scenario
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeTrafficTrackersApi
     */
    public deployedTrafficTrackersDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeTrafficTrackersApiFp(this.configuration).deployedTrafficTrackersDelete(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a Traffic Tracker in a scenario
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeTrafficTrackersApi
     */
    public deployedTrafficTrackersDeploy(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeTrafficTrackersApiFp(this.configuration).deployedTrafficTrackersDeploy(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing Traffic Trackers
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {boolean} [ready] 
     * @param {boolean} [status] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {DeployedTrafficTrackersListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {DeployedTrafficTrackersListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeTrafficTrackersApi
     */
    public deployedTrafficTrackersList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, ready?: boolean, status?: boolean, offset?: number, limit?: number, search?: string, sortBy?: DeployedTrafficTrackersListSortByEnum, sort?: DeployedTrafficTrackersListSortEnum, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeTrafficTrackersApiFp(this.configuration).deployedTrafficTrackersList(rangeId, scenarioId, uuid, name, description, author, metadata, ready, status, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing Traffic Tracker
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeTrafficTrackersApi
     */
    public deployedTrafficTrackersRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeTrafficTrackersApiFp(this.configuration).deployedTrafficTrackersRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeployedTrafficTrackersListSortByEnum = {
    Author: 'author',
    Description: 'description',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Name: 'name'
} as const;
export type DeployedTrafficTrackersListSortByEnum = typeof DeployedTrafficTrackersListSortByEnum[keyof typeof DeployedTrafficTrackersListSortByEnum];
/**
 * @export
 */
export const DeployedTrafficTrackersListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type DeployedTrafficTrackersListSortEnum = typeof DeployedTrafficTrackersListSortEnum[keyof typeof DeployedTrafficTrackersListSortEnum];


/**
 * ManageRangeResourcesRangeVMExportsApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesRangeVMExportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Restores Virtual Machine State from specified snapshot
         * @summary Creates a Range VM Export
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {RangeVmExportForm} [rangeVmExportForm] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeVmExportsCreate: async (rangeId: string, scenarioId: string, rangeVmExportForm?: RangeVmExportForm, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('rangeVmExportsCreate', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('rangeVmExportsCreate', 'scenarioId', scenarioId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-vm-exports`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeVmExportForm, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a Range VM Export in a range
         * @summary Deletes a Range VM Export
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} rangeVmExportName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeVmExportsDelete: async (rangeId: string, scenarioId: string, rangeVmExportName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('rangeVmExportsDelete', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('rangeVmExportsDelete', 'scenarioId', scenarioId)
            // verify required parameter 'rangeVmExportName' is not null or undefined
            assertParamExists('rangeVmExportsDelete', 'rangeVmExportName', rangeVmExportName)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-vm-exports/{rangeVmExportName}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"rangeVmExportName"}}`, encodeURIComponent(String(rangeVmExportName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the Range VM Export by name and range Id
         * @summary Gets Range VM Export in specified range
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} rangeVmExportName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeVmExportsGet: async (rangeId: string, scenarioId: string, rangeVmExportName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('rangeVmExportsGet', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('rangeVmExportsGet', 'scenarioId', scenarioId)
            // verify required parameter 'rangeVmExportName' is not null or undefined
            assertParamExists('rangeVmExportsGet', 'rangeVmExportName', rangeVmExportName)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-vm-exports/{rangeVmExportName}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"rangeVmExportName"}}`, encodeURIComponent(String(rangeVmExportName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing Range VM Exports
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeVmExportsList: async (rangeId: string, scenarioId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('rangeVmExportsList', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('rangeVmExportsList', 'scenarioId', scenarioId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-vm-exports`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesRangeVMExportsApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesRangeVMExportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesRangeVMExportsApiAxiosParamCreator(configuration)
    return {
        /**
         * Restores Virtual Machine State from specified snapshot
         * @summary Creates a Range VM Export
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {RangeVmExportForm} [rangeVmExportForm] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeVmExportsCreate(rangeId: string, scenarioId: string, rangeVmExportForm?: RangeVmExportForm, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeVmExportsCreate(rangeId, scenarioId, rangeVmExportForm, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeVMExportsApi.rangeVmExportsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a Range VM Export in a range
         * @summary Deletes a Range VM Export
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} rangeVmExportName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeVmExportsDelete(rangeId: string, scenarioId: string, rangeVmExportName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeVmExportsDelete(rangeId, scenarioId, rangeVmExportName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeVMExportsApi.rangeVmExportsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the Range VM Export by name and range Id
         * @summary Gets Range VM Export in specified range
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} rangeVmExportName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeVmExportsGet(rangeId: string, scenarioId: string, rangeVmExportName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeVmExportApi>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeVmExportsGet(rangeId, scenarioId, rangeVmExportName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeVMExportsApi.rangeVmExportsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing Range VM Exports
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeVmExportsList(rangeId: string, scenarioId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeVmExportsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeVmExportsList(rangeId, scenarioId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeVMExportsApi.rangeVmExportsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesRangeVMExportsApi - factory interface
 * @export
 */
export const ManageRangeResourcesRangeVMExportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesRangeVMExportsApiFp(configuration)
    return {
        /**
         * Restores Virtual Machine State from specified snapshot
         * @summary Creates a Range VM Export
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {RangeVmExportForm} [rangeVmExportForm] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeVmExportsCreate(rangeId: string, scenarioId: string, rangeVmExportForm?: RangeVmExportForm, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rangeVmExportsCreate(rangeId, scenarioId, rangeVmExportForm, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a Range VM Export in a range
         * @summary Deletes a Range VM Export
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} rangeVmExportName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeVmExportsDelete(rangeId: string, scenarioId: string, rangeVmExportName: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rangeVmExportsDelete(rangeId, scenarioId, rangeVmExportName, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the Range VM Export by name and range Id
         * @summary Gets Range VM Export in specified range
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} rangeVmExportName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeVmExportsGet(rangeId: string, scenarioId: string, rangeVmExportName: string, options?: RawAxiosRequestConfig): AxiosPromise<RangeVmExportApi> {
            return localVarFp.rangeVmExportsGet(rangeId, scenarioId, rangeVmExportName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing Range VM Exports
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeVmExportsList(rangeId: string, scenarioId: string, options?: RawAxiosRequestConfig): AxiosPromise<RangeVmExportsList200Response> {
            return localVarFp.rangeVmExportsList(rangeId, scenarioId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesRangeVMExportsApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesRangeVMExportsApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesRangeVMExportsApi extends BaseAPI {
    /**
     * Restores Virtual Machine State from specified snapshot
     * @summary Creates a Range VM Export
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {RangeVmExportForm} [rangeVmExportForm] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeVMExportsApi
     */
    public rangeVmExportsCreate(rangeId: string, scenarioId: string, rangeVmExportForm?: RangeVmExportForm, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeVMExportsApiFp(this.configuration).rangeVmExportsCreate(rangeId, scenarioId, rangeVmExportForm, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a Range VM Export in a range
     * @summary Deletes a Range VM Export
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} rangeVmExportName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeVMExportsApi
     */
    public rangeVmExportsDelete(rangeId: string, scenarioId: string, rangeVmExportName: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeVMExportsApiFp(this.configuration).rangeVmExportsDelete(rangeId, scenarioId, rangeVmExportName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the Range VM Export by name and range Id
     * @summary Gets Range VM Export in specified range
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} rangeVmExportName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeVMExportsApi
     */
    public rangeVmExportsGet(rangeId: string, scenarioId: string, rangeVmExportName: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeVMExportsApiFp(this.configuration).rangeVmExportsGet(rangeId, scenarioId, rangeVmExportName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing Range VM Exports
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeVMExportsApi
     */
    public rangeVmExportsList(rangeId: string, scenarioId: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeVMExportsApiFp(this.configuration).rangeVmExportsList(rangeId, scenarioId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ManageRangeResourcesRangeVMsApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesRangeVMsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deploys a VM specification as a range VM to an in-range scenario
         * @summary Deploy a range VM
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deployedRangeVMsCreate: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeVMsCreate', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeVMsCreate', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeVMsCreate', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-vms/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a range VM from an in-range scenario
         * @summary Deletes a range VM
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeVMsDelete: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeVMsDelete', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeVMsDelete', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeVMsDelete', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-vms/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deploy a Hypervisor console
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} rangeVmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeVMsDeployHypervisorConsole: async (rangeId: string, scenarioId: string, rangeVmId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeVMsDeployHypervisorConsole', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeVMsDeployHypervisorConsole', 'scenarioId', scenarioId)
            // verify required parameter 'rangeVmId' is not null or undefined
            assertParamExists('deployedRangeVMsDeployHypervisorConsole', 'rangeVmId', rangeVmId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-vms/{rangeVmId}/deploy-hypervisor-console`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"rangeVmId"}}`, encodeURIComponent(String(rangeVmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing range VMs
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {boolean} [running] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeVMsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeVMsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeVMsList: async (rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, running?: boolean, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeVMsListSortByEnum, sort?: DeployedRangeVMsListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeVMsList', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeVMsList', 'scenarioId', scenarioId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-vms`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (running !== undefined) {
                localVarQueryParameter['running'] = running;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing range VM
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeVMsRetrieve: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeVMsRetrieve', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeVMsRetrieve', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeVMsRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-vms/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts the range VM
         * @summary Starts a stopped range VM
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeVMsStart: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeVMsStart', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeVMsStart', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeVMsStart', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-vms/{uuid}/start`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stops the range VM
         * @summary Stop a range VM
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeVMsStop: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeVMsStop', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeVMsStop', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeVMsStop', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-vms/{uuid}/stop`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesRangeVMsApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesRangeVMsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesRangeVMsApiAxiosParamCreator(configuration)
    return {
        /**
         * Deploys a VM specification as a range VM to an in-range scenario
         * @summary Deploy a range VM
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async deployedRangeVMsCreate(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeVMsCreate(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeVMsApi.deployedRangeVMsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a range VM from an in-range scenario
         * @summary Deletes a range VM
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeVMsDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeVMsDelete(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeVMsApi.deployedRangeVMsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Deploy a Hypervisor console
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} rangeVmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeVMsDeployHypervisorConsole(rangeId: string, scenarioId: string, rangeVmId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BackgroundJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeVMsDeployHypervisorConsole(rangeId, scenarioId, rangeVmId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeVMsApi.deployedRangeVMsDeployHypervisorConsole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing range VMs
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {boolean} [running] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeVMsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeVMsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeVMsList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, running?: boolean, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeVMsListSortByEnum, sort?: DeployedRangeVMsListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedRangeVMsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeVMsList(rangeId, scenarioId, uuid, name, description, author, metadata, running, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeVMsApi.deployedRangeVMsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an existing range VM
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeVMsRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeVM>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeVMsRetrieve(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeVMsApi.deployedRangeVMsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Starts the range VM
         * @summary Starts a stopped range VM
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeVMsStart(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BackgroundJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeVMsStart(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeVMsApi.deployedRangeVMsStart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Stops the range VM
         * @summary Stop a range VM
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeVMsStop(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BackgroundJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeVMsStop(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeVMsApi.deployedRangeVMsStop']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesRangeVMsApi - factory interface
 * @export
 */
export const ManageRangeResourcesRangeVMsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesRangeVMsApiFp(configuration)
    return {
        /**
         * Deploys a VM specification as a range VM to an in-range scenario
         * @summary Deploy a range VM
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deployedRangeVMsCreate(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedRangeVMsCreate(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a range VM from an in-range scenario
         * @summary Deletes a range VM
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeVMsDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedRangeVMsDelete(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deploy a Hypervisor console
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} rangeVmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeVMsDeployHypervisorConsole(rangeId: string, scenarioId: string, rangeVmId: string, options?: RawAxiosRequestConfig): AxiosPromise<BackgroundJob> {
            return localVarFp.deployedRangeVMsDeployHypervisorConsole(rangeId, scenarioId, rangeVmId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing range VMs
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {boolean} [running] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeVMsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeVMsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeVMsList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, running?: boolean, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeVMsListSortByEnum, sort?: DeployedRangeVMsListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<DeployedRangeVMsList200Response> {
            return localVarFp.deployedRangeVMsList(rangeId, scenarioId, uuid, name, description, author, metadata, running, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing range VM
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeVMsRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<RangeVM> {
            return localVarFp.deployedRangeVMsRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Starts the range VM
         * @summary Starts a stopped range VM
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeVMsStart(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<BackgroundJob> {
            return localVarFp.deployedRangeVMsStart(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Stops the range VM
         * @summary Stop a range VM
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeVMsStop(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<BackgroundJob> {
            return localVarFp.deployedRangeVMsStop(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesRangeVMsApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesRangeVMsApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesRangeVMsApi extends BaseAPI {
    /**
     * Deploys a VM specification as a range VM to an in-range scenario
     * @summary Deploy a range VM
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeVMsApi
     */
    public deployedRangeVMsCreate(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeVMsApiFp(this.configuration).deployedRangeVMsCreate(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a range VM from an in-range scenario
     * @summary Deletes a range VM
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeVMsApi
     */
    public deployedRangeVMsDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeVMsApiFp(this.configuration).deployedRangeVMsDelete(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deploy a Hypervisor console
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} rangeVmId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeVMsApi
     */
    public deployedRangeVMsDeployHypervisorConsole(rangeId: string, scenarioId: string, rangeVmId: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeVMsApiFp(this.configuration).deployedRangeVMsDeployHypervisorConsole(rangeId, scenarioId, rangeVmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing range VMs
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {boolean} [running] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {DeployedRangeVMsListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {DeployedRangeVMsListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeVMsApi
     */
    public deployedRangeVMsList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, running?: boolean, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeVMsListSortByEnum, sort?: DeployedRangeVMsListSortEnum, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeVMsApiFp(this.configuration).deployedRangeVMsList(rangeId, scenarioId, uuid, name, description, author, metadata, running, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing range VM
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeVMsApi
     */
    public deployedRangeVMsRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeVMsApiFp(this.configuration).deployedRangeVMsRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Starts the range VM
     * @summary Starts a stopped range VM
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeVMsApi
     */
    public deployedRangeVMsStart(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeVMsApiFp(this.configuration).deployedRangeVMsStart(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stops the range VM
     * @summary Stop a range VM
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeVMsApi
     */
    public deployedRangeVMsStop(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeVMsApiFp(this.configuration).deployedRangeVMsStop(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeployedRangeVMsListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author'
} as const;
export type DeployedRangeVMsListSortByEnum = typeof DeployedRangeVMsListSortByEnum[keyof typeof DeployedRangeVMsListSortByEnum];
/**
 * @export
 */
export const DeployedRangeVMsListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type DeployedRangeVMsListSortEnum = typeof DeployedRangeVMsListSortEnum[keyof typeof DeployedRangeVMsListSortEnum];


/**
 * ManageRangeResourcesRangeVolumesApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesRangeVolumesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deploys a range volume to an in-range scenario
         * @summary Deploy a range volume
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deployedRangeVolumesCreate: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeVolumesCreate', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeVolumesCreate', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeVolumesCreate', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-volumes/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a range volume from an in-range scenario
         * @summary Deletes a range volume
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeVolumesDelete: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeVolumesDelete', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeVolumesDelete', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeVolumesDelete', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-volumes/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing range volumes
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [volume] 
         * @param {string} [volumeType] 
         * @param {string} [storageClass] 
         * @param {boolean} [ready] 
         * @param {string} [status] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeVolumesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeVolumesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeVolumesList: async (rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, volume?: string, volumeType?: string, storageClass?: string, ready?: boolean, status?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeVolumesListSortByEnum, sort?: DeployedRangeVolumesListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeVolumesList', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeVolumesList', 'scenarioId', scenarioId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-volumes`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (volume !== undefined) {
                localVarQueryParameter['volume'] = volume;
            }

            if (volumeType !== undefined) {
                localVarQueryParameter['volumeType'] = volumeType;
            }

            if (storageClass !== undefined) {
                localVarQueryParameter['storageClass'] = storageClass;
            }

            if (ready !== undefined) {
                localVarQueryParameter['ready'] = ready;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve an existing range volume
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeVolumesRetrieve: async (rangeId: string, scenarioId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('deployedRangeVolumesRetrieve', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('deployedRangeVolumesRetrieve', 'scenarioId', scenarioId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deployedRangeVolumesRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/range-volumes/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesRangeVolumesApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesRangeVolumesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesRangeVolumesApiAxiosParamCreator(configuration)
    return {
        /**
         * Deploys a range volume to an in-range scenario
         * @summary Deploy a range volume
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async deployedRangeVolumesCreate(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeVolumesCreate(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeVolumesApi.deployedRangeVolumesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a range volume from an in-range scenario
         * @summary Deletes a range volume
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeVolumesDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeVolumesDelete(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeVolumesApi.deployedRangeVolumesDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing range volumes
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [volume] 
         * @param {string} [volumeType] 
         * @param {string} [storageClass] 
         * @param {boolean} [ready] 
         * @param {string} [status] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeVolumesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeVolumesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeVolumesList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, volume?: string, volumeType?: string, storageClass?: string, ready?: boolean, status?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeVolumesListSortByEnum, sort?: DeployedRangeVolumesListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedRangeVolumesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeVolumesList(rangeId, scenarioId, uuid, name, description, author, metadata, volume, volumeType, storageClass, ready, status, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeVolumesApi.deployedRangeVolumesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve an existing range volume
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deployedRangeVolumesRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedRangeVolume>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deployedRangeVolumesRetrieve(rangeId, scenarioId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesRangeVolumesApi.deployedRangeVolumesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesRangeVolumesApi - factory interface
 * @export
 */
export const ManageRangeResourcesRangeVolumesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesRangeVolumesApiFp(configuration)
    return {
        /**
         * Deploys a range volume to an in-range scenario
         * @summary Deploy a range volume
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        deployedRangeVolumesCreate(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedRangeVolumesCreate(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a range volume from an in-range scenario
         * @summary Deletes a range volume
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeVolumesDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deployedRangeVolumesDelete(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing range volumes
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [volume] 
         * @param {string} [volumeType] 
         * @param {string} [storageClass] 
         * @param {boolean} [ready] 
         * @param {string} [status] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {DeployedRangeVolumesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {DeployedRangeVolumesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeVolumesList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, volume?: string, volumeType?: string, storageClass?: string, ready?: boolean, status?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeVolumesListSortByEnum, sort?: DeployedRangeVolumesListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<DeployedRangeVolumesList200Response> {
            return localVarFp.deployedRangeVolumesList(rangeId, scenarioId, uuid, name, description, author, metadata, volume, volumeType, storageClass, ready, status, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve an existing range volume
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployedRangeVolumesRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<DeployedRangeVolume> {
            return localVarFp.deployedRangeVolumesRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesRangeVolumesApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesRangeVolumesApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesRangeVolumesApi extends BaseAPI {
    /**
     * Deploys a range volume to an in-range scenario
     * @summary Deploy a range volume
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeVolumesApi
     */
    public deployedRangeVolumesCreate(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeVolumesApiFp(this.configuration).deployedRangeVolumesCreate(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a range volume from an in-range scenario
     * @summary Deletes a range volume
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeVolumesApi
     */
    public deployedRangeVolumesDelete(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeVolumesApiFp(this.configuration).deployedRangeVolumesDelete(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing range volumes
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {string} [volume] 
     * @param {string} [volumeType] 
     * @param {string} [storageClass] 
     * @param {boolean} [ready] 
     * @param {string} [status] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {DeployedRangeVolumesListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {DeployedRangeVolumesListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeVolumesApi
     */
    public deployedRangeVolumesList(rangeId: string, scenarioId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, volume?: string, volumeType?: string, storageClass?: string, ready?: boolean, status?: string, offset?: number, limit?: number, search?: string, sortBy?: DeployedRangeVolumesListSortByEnum, sort?: DeployedRangeVolumesListSortEnum, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeVolumesApiFp(this.configuration).deployedRangeVolumesList(rangeId, scenarioId, uuid, name, description, author, metadata, volume, volumeType, storageClass, ready, status, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve an existing range volume
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesRangeVolumesApi
     */
    public deployedRangeVolumesRetrieve(rangeId: string, scenarioId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesRangeVolumesApiFp(this.configuration).deployedRangeVolumesRetrieve(rangeId, scenarioId, uuid, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeployedRangeVolumesListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author',
    Volume: 'volume',
    StorageClass: 'storageClass',
    Storage: 'storage',
    Ready: 'ready',
    Status: 'status'
} as const;
export type DeployedRangeVolumesListSortByEnum = typeof DeployedRangeVolumesListSortByEnum[keyof typeof DeployedRangeVolumesListSortByEnum];
/**
 * @export
 */
export const DeployedRangeVolumesListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type DeployedRangeVolumesListSortEnum = typeof DeployedRangeVolumesListSortEnum[keyof typeof DeployedRangeVolumesListSortEnum];


/**
 * ManageRangeResourcesScenarioPermissionsApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesScenarioPermissionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds a user to a scenario permission group
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {ScenarioPermissionsAddUserGroupEnum} group 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenarioPermissionsAddUser: async (rangeId: string, scenarioId: string, group: ScenarioPermissionsAddUserGroupEnum, username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('scenarioPermissionsAddUser', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('scenarioPermissionsAddUser', 'scenarioId', scenarioId)
            // verify required parameter 'group' is not null or undefined
            assertParamExists('scenarioPermissionsAddUser', 'group', group)
            // verify required parameter 'username' is not null or undefined
            assertParamExists('scenarioPermissionsAddUser', 'username', username)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/permissions/{group}/{username}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Removes a user from a scenario permission group
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {ScenarioPermissionsRemoveUserGroupEnum} group 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenarioPermissionsRemoveUser: async (rangeId: string, scenarioId: string, group: ScenarioPermissionsRemoveUserGroupEnum, username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('scenarioPermissionsRemoveUser', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('scenarioPermissionsRemoveUser', 'scenarioId', scenarioId)
            // verify required parameter 'group' is not null or undefined
            assertParamExists('scenarioPermissionsRemoveUser', 'group', group)
            // verify required parameter 'username' is not null or undefined
            assertParamExists('scenarioPermissionsRemoveUser', 'username', username)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/permissions/{group}/{username}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve existing in-range scenario permissions
         * @summary Retrieve scenario permissions
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenarioPermissionsRetrieve: async (rangeId: string, scenarioId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('scenarioPermissionsRetrieve', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('scenarioPermissionsRetrieve', 'scenarioId', scenarioId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/permissions`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates existing in-range scenario permissions
         * @summary Update scenario permissions
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {ScenarioPermissionUpdate} [scenarioPermissionUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenarioPermissionsUpdate: async (rangeId: string, scenarioId: string, scenarioPermissionUpdate?: ScenarioPermissionUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('scenarioPermissionsUpdate', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('scenarioPermissionsUpdate', 'scenarioId', scenarioId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/permissions`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scenarioPermissionUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesScenarioPermissionsApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesScenarioPermissionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesScenarioPermissionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Adds a user to a scenario permission group
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {ScenarioPermissionsAddUserGroupEnum} group 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scenarioPermissionsAddUser(rangeId: string, scenarioId: string, group: ScenarioPermissionsAddUserGroupEnum, username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scenarioPermissionsAddUser(rangeId, scenarioId, group, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesScenarioPermissionsApi.scenarioPermissionsAddUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Removes a user from a scenario permission group
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {ScenarioPermissionsRemoveUserGroupEnum} group 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scenarioPermissionsRemoveUser(rangeId: string, scenarioId: string, group: ScenarioPermissionsRemoveUserGroupEnum, username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scenarioPermissionsRemoveUser(rangeId, scenarioId, group, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesScenarioPermissionsApi.scenarioPermissionsRemoveUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve existing in-range scenario permissions
         * @summary Retrieve scenario permissions
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scenarioPermissionsRetrieve(rangeId: string, scenarioId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedScenarioPermission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scenarioPermissionsRetrieve(rangeId, scenarioId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesScenarioPermissionsApi.scenarioPermissionsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates existing in-range scenario permissions
         * @summary Update scenario permissions
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {ScenarioPermissionUpdate} [scenarioPermissionUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scenarioPermissionsUpdate(rangeId: string, scenarioId: string, scenarioPermissionUpdate?: ScenarioPermissionUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedScenarioPermission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scenarioPermissionsUpdate(rangeId, scenarioId, scenarioPermissionUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesScenarioPermissionsApi.scenarioPermissionsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesScenarioPermissionsApi - factory interface
 * @export
 */
export const ManageRangeResourcesScenarioPermissionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesScenarioPermissionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Adds a user to a scenario permission group
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {ScenarioPermissionsAddUserGroupEnum} group 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenarioPermissionsAddUser(rangeId: string, scenarioId: string, group: ScenarioPermissionsAddUserGroupEnum, username: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.scenarioPermissionsAddUser(rangeId, scenarioId, group, username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Removes a user from a scenario permission group
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {ScenarioPermissionsRemoveUserGroupEnum} group 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenarioPermissionsRemoveUser(rangeId: string, scenarioId: string, group: ScenarioPermissionsRemoveUserGroupEnum, username: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.scenarioPermissionsRemoveUser(rangeId, scenarioId, group, username, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve existing in-range scenario permissions
         * @summary Retrieve scenario permissions
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenarioPermissionsRetrieve(rangeId: string, scenarioId: string, options?: RawAxiosRequestConfig): AxiosPromise<DeployedScenarioPermission> {
            return localVarFp.scenarioPermissionsRetrieve(rangeId, scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates existing in-range scenario permissions
         * @summary Update scenario permissions
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {ScenarioPermissionUpdate} [scenarioPermissionUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenarioPermissionsUpdate(rangeId: string, scenarioId: string, scenarioPermissionUpdate?: ScenarioPermissionUpdate, options?: RawAxiosRequestConfig): AxiosPromise<DeployedScenarioPermission> {
            return localVarFp.scenarioPermissionsUpdate(rangeId, scenarioId, scenarioPermissionUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesScenarioPermissionsApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesScenarioPermissionsApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesScenarioPermissionsApi extends BaseAPI {
    /**
     * 
     * @summary Adds a user to a scenario permission group
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {ScenarioPermissionsAddUserGroupEnum} group 
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesScenarioPermissionsApi
     */
    public scenarioPermissionsAddUser(rangeId: string, scenarioId: string, group: ScenarioPermissionsAddUserGroupEnum, username: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesScenarioPermissionsApiFp(this.configuration).scenarioPermissionsAddUser(rangeId, scenarioId, group, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Removes a user from a scenario permission group
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {ScenarioPermissionsRemoveUserGroupEnum} group 
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesScenarioPermissionsApi
     */
    public scenarioPermissionsRemoveUser(rangeId: string, scenarioId: string, group: ScenarioPermissionsRemoveUserGroupEnum, username: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesScenarioPermissionsApiFp(this.configuration).scenarioPermissionsRemoveUser(rangeId, scenarioId, group, username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve existing in-range scenario permissions
     * @summary Retrieve scenario permissions
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesScenarioPermissionsApi
     */
    public scenarioPermissionsRetrieve(rangeId: string, scenarioId: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesScenarioPermissionsApiFp(this.configuration).scenarioPermissionsRetrieve(rangeId, scenarioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates existing in-range scenario permissions
     * @summary Update scenario permissions
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {ScenarioPermissionUpdate} [scenarioPermissionUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesScenarioPermissionsApi
     */
    public scenarioPermissionsUpdate(rangeId: string, scenarioId: string, scenarioPermissionUpdate?: ScenarioPermissionUpdate, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesScenarioPermissionsApiFp(this.configuration).scenarioPermissionsUpdate(rangeId, scenarioId, scenarioPermissionUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ScenarioPermissionsAddUserGroupEnum = {
    BlueCell: 'blueCell',
    RedCell: 'redCell',
    WhiteCell: 'whiteCell',
    ScenarioAdmin: 'scenarioAdmin'
} as const;
export type ScenarioPermissionsAddUserGroupEnum = typeof ScenarioPermissionsAddUserGroupEnum[keyof typeof ScenarioPermissionsAddUserGroupEnum];
/**
 * @export
 */
export const ScenarioPermissionsRemoveUserGroupEnum = {
    BlueCell: 'blueCell',
    RedCell: 'redCell',
    WhiteCell: 'whiteCell',
    ScenarioAdmin: 'scenarioAdmin'
} as const;
export type ScenarioPermissionsRemoveUserGroupEnum = typeof ScenarioPermissionsRemoveUserGroupEnum[keyof typeof ScenarioPermissionsRemoveUserGroupEnum];


/**
 * ManageRangeResourcesScenariosApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesScenariosApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deploys a scenario in an existing range
         * @summary Creates a scenario
         * @param {string} rangeId 
         * @param {ScenariosCreateByRangeIdRequest} scenariosCreateByRangeIdRequest Optional runtime scenario specific overrides
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosCreateByRangeId: async (rangeId: string, scenariosCreateByRangeIdRequest: ScenariosCreateByRangeIdRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('scenariosCreateByRangeId', 'rangeId', rangeId)
            // verify required parameter 'scenariosCreateByRangeIdRequest' is not null or undefined
            assertParamExists('scenariosCreateByRangeId', 'scenariosCreateByRangeIdRequest', scenariosCreateByRangeIdRequest)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scenariosCreateByRangeIdRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a scenario from a range
         * @summary Deletes a scenario
         * @param {string} rangeId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosDeleteByRangeIdUuid: async (rangeId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('scenariosDeleteByRangeIdUuid', 'rangeId', rangeId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('scenariosDeleteByRangeIdUuid', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} rangeId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosGetKubeConfig: async (rangeId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('scenariosGetKubeConfig', 'rangeId', rangeId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('scenariosGetKubeConfig', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{uuid}/kubeconfig`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List existing in-range scenarios
         * @summary List scenarios
         * @param {string} rangeId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [tag] 
         * @param {string} [deployedBy] 
         * @param {string} [classId] 
         * @param {string} [studentId] 
         * @param {string} [studentUsername] 
         * @param {string} [scenarioId] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {ScenariosListByRangeIdSortByEnum} [sortBy] Key used to sort the collection by
         * @param {ScenariosListByRangeIdSortEnum} [sort] 
         * @param {Array<ScenariosListByRangeIdIncludesEnum>} [includes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosListByRangeId: async (rangeId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, tag?: string, deployedBy?: string, classId?: string, studentId?: string, studentUsername?: string, scenarioId?: string, offset?: number, limit?: number, search?: string, sortBy?: ScenariosListByRangeIdSortByEnum, sort?: ScenariosListByRangeIdSortEnum, includes?: Array<ScenariosListByRangeIdIncludesEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('scenariosListByRangeId', 'rangeId', rangeId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (deployedBy !== undefined) {
                localVarQueryParameter['deployedBy'] = deployedBy;
            }

            if (classId !== undefined) {
                localVarQueryParameter['classId'] = classId;
            }

            if (studentId !== undefined) {
                localVarQueryParameter['studentId'] = studentId;
            }

            if (studentUsername !== undefined) {
                localVarQueryParameter['studentUsername'] = studentUsername;
            }

            if (scenarioId !== undefined) {
                localVarQueryParameter['scenarioId'] = scenarioId;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }

            if (includes) {
                localVarQueryParameter['includes'] = includes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an existing in-range scenario
         * @summary Retrieve a scenario
         * @param {string} rangeId 
         * @param {string} uuid 
         * @param {Array<ScenariosRetrieveByRangeIdUuidIncludesEnum>} [includes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosRetrieveByRangeIdUuid: async (rangeId: string, uuid: string, includes?: Array<ScenariosRetrieveByRangeIdUuidIncludesEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('scenariosRetrieveByRangeIdUuid', 'rangeId', rangeId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('scenariosRetrieveByRangeIdUuid', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (includes) {
                localVarQueryParameter['includes'] = includes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve overrides for an existing in-range scenario
         * @summary Retrieve scenario overrides
         * @param {string} rangeId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosRetrieveScenarioOverrides: async (rangeId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('scenariosRetrieveScenarioOverrides', 'rangeId', rangeId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('scenariosRetrieveScenarioOverrides', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{uuid}/overrides`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts any associated containers or VMS
         * @summary Stars all containers and vms in a scenario
         * @param {string} rangeId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosStart: async (rangeId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('scenariosStart', 'rangeId', rangeId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('scenariosStart', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{uuid}/start`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stops any associated containers or VMS
         * @summary Stops all containers and vms in a scenario
         * @param {string} rangeId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosStop: async (rangeId: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('scenariosStop', 'rangeId', rangeId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('scenariosStop', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{uuid}/stop`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Re-deploys a scenario in an existing range. To re-use the currently existing overrides, omit them from the request payload.
         * @summary Updates a scenario
         * @param {string} rangeId 
         * @param {string} uuid 
         * @param {ScenariosUpdateByRangeIdUuidRequest} [scenariosUpdateByRangeIdUuidRequest] Optional runtime scenario specific overrides
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosUpdateByRangeIdUuid: async (rangeId: string, uuid: string, scenariosUpdateByRangeIdUuidRequest?: ScenariosUpdateByRangeIdUuidRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('scenariosUpdateByRangeIdUuid', 'rangeId', rangeId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('scenariosUpdateByRangeIdUuid', 'uuid', uuid)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{uuid}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scenariosUpdateByRangeIdUuidRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesScenariosApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesScenariosApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesScenariosApiAxiosParamCreator(configuration)
    return {
        /**
         * Deploys a scenario in an existing range
         * @summary Creates a scenario
         * @param {string} rangeId 
         * @param {ScenariosCreateByRangeIdRequest} scenariosCreateByRangeIdRequest Optional runtime scenario specific overrides
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scenariosCreateByRangeId(rangeId: string, scenariosCreateByRangeIdRequest: ScenariosCreateByRangeIdRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedScenario>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scenariosCreateByRangeId(rangeId, scenariosCreateByRangeIdRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesScenariosApi.scenariosCreateByRangeId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a scenario from a range
         * @summary Deletes a scenario
         * @param {string} rangeId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scenariosDeleteByRangeIdUuid(rangeId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scenariosDeleteByRangeIdUuid(rangeId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesScenariosApi.scenariosDeleteByRangeIdUuid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} rangeId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scenariosGetKubeConfig(rangeId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scenariosGetKubeConfig(rangeId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesScenariosApi.scenariosGetKubeConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List existing in-range scenarios
         * @summary List scenarios
         * @param {string} rangeId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [tag] 
         * @param {string} [deployedBy] 
         * @param {string} [classId] 
         * @param {string} [studentId] 
         * @param {string} [studentUsername] 
         * @param {string} [scenarioId] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {ScenariosListByRangeIdSortByEnum} [sortBy] Key used to sort the collection by
         * @param {ScenariosListByRangeIdSortEnum} [sort] 
         * @param {Array<ScenariosListByRangeIdIncludesEnum>} [includes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scenariosListByRangeId(rangeId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, tag?: string, deployedBy?: string, classId?: string, studentId?: string, studentUsername?: string, scenarioId?: string, offset?: number, limit?: number, search?: string, sortBy?: ScenariosListByRangeIdSortByEnum, sort?: ScenariosListByRangeIdSortEnum, includes?: Array<ScenariosListByRangeIdIncludesEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenariosListByRangeId200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scenariosListByRangeId(rangeId, uuid, name, description, author, metadata, tag, deployedBy, classId, studentId, studentUsername, scenarioId, offset, limit, search, sortBy, sort, includes, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesScenariosApi.scenariosListByRangeId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an existing in-range scenario
         * @summary Retrieve a scenario
         * @param {string} rangeId 
         * @param {string} uuid 
         * @param {Array<ScenariosRetrieveByRangeIdUuidIncludesEnum>} [includes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scenariosRetrieveByRangeIdUuid(rangeId: string, uuid: string, includes?: Array<ScenariosRetrieveByRangeIdUuidIncludesEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedScenarioDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scenariosRetrieveByRangeIdUuid(rangeId, uuid, includes, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesScenariosApi.scenariosRetrieveByRangeIdUuid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve overrides for an existing in-range scenario
         * @summary Retrieve scenario overrides
         * @param {string} rangeId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scenariosRetrieveScenarioOverrides(rangeId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenarioOverridesOverride>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scenariosRetrieveScenarioOverrides(rangeId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesScenariosApi.scenariosRetrieveScenarioOverrides']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Starts any associated containers or VMS
         * @summary Stars all containers and vms in a scenario
         * @param {string} rangeId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scenariosStart(rangeId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BackgroundJob>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scenariosStart(rangeId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesScenariosApi.scenariosStart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Stops any associated containers or VMS
         * @summary Stops all containers and vms in a scenario
         * @param {string} rangeId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scenariosStop(rangeId: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BackgroundJob>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scenariosStop(rangeId, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesScenariosApi.scenariosStop']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Re-deploys a scenario in an existing range. To re-use the currently existing overrides, omit them from the request payload.
         * @summary Updates a scenario
         * @param {string} rangeId 
         * @param {string} uuid 
         * @param {ScenariosUpdateByRangeIdUuidRequest} [scenariosUpdateByRangeIdUuidRequest] Optional runtime scenario specific overrides
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scenariosUpdateByRangeIdUuid(rangeId: string, uuid: string, scenariosUpdateByRangeIdUuidRequest?: ScenariosUpdateByRangeIdUuidRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeployedScenario>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scenariosUpdateByRangeIdUuid(rangeId, uuid, scenariosUpdateByRangeIdUuidRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesScenariosApi.scenariosUpdateByRangeIdUuid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesScenariosApi - factory interface
 * @export
 */
export const ManageRangeResourcesScenariosApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesScenariosApiFp(configuration)
    return {
        /**
         * Deploys a scenario in an existing range
         * @summary Creates a scenario
         * @param {string} rangeId 
         * @param {ScenariosCreateByRangeIdRequest} scenariosCreateByRangeIdRequest Optional runtime scenario specific overrides
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosCreateByRangeId(rangeId: string, scenariosCreateByRangeIdRequest: ScenariosCreateByRangeIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeployedScenario> {
            return localVarFp.scenariosCreateByRangeId(rangeId, scenariosCreateByRangeIdRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a scenario from a range
         * @summary Deletes a scenario
         * @param {string} rangeId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosDeleteByRangeIdUuid(rangeId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.scenariosDeleteByRangeIdUuid(rangeId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} rangeId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosGetKubeConfig(rangeId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.scenariosGetKubeConfig(rangeId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * List existing in-range scenarios
         * @summary List scenarios
         * @param {string} rangeId 
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [tag] 
         * @param {string} [deployedBy] 
         * @param {string} [classId] 
         * @param {string} [studentId] 
         * @param {string} [studentUsername] 
         * @param {string} [scenarioId] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {ScenariosListByRangeIdSortByEnum} [sortBy] Key used to sort the collection by
         * @param {ScenariosListByRangeIdSortEnum} [sort] 
         * @param {Array<ScenariosListByRangeIdIncludesEnum>} [includes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosListByRangeId(rangeId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, tag?: string, deployedBy?: string, classId?: string, studentId?: string, studentUsername?: string, scenarioId?: string, offset?: number, limit?: number, search?: string, sortBy?: ScenariosListByRangeIdSortByEnum, sort?: ScenariosListByRangeIdSortEnum, includes?: Array<ScenariosListByRangeIdIncludesEnum>, options?: RawAxiosRequestConfig): AxiosPromise<ScenariosListByRangeId200Response> {
            return localVarFp.scenariosListByRangeId(rangeId, uuid, name, description, author, metadata, tag, deployedBy, classId, studentId, studentUsername, scenarioId, offset, limit, search, sortBy, sort, includes, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an existing in-range scenario
         * @summary Retrieve a scenario
         * @param {string} rangeId 
         * @param {string} uuid 
         * @param {Array<ScenariosRetrieveByRangeIdUuidIncludesEnum>} [includes] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosRetrieveByRangeIdUuid(rangeId: string, uuid: string, includes?: Array<ScenariosRetrieveByRangeIdUuidIncludesEnum>, options?: RawAxiosRequestConfig): AxiosPromise<DeployedScenarioDetail> {
            return localVarFp.scenariosRetrieveByRangeIdUuid(rangeId, uuid, includes, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve overrides for an existing in-range scenario
         * @summary Retrieve scenario overrides
         * @param {string} rangeId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosRetrieveScenarioOverrides(rangeId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<ScenarioOverridesOverride> {
            return localVarFp.scenariosRetrieveScenarioOverrides(rangeId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Starts any associated containers or VMS
         * @summary Stars all containers and vms in a scenario
         * @param {string} rangeId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosStart(rangeId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<BackgroundJob>> {
            return localVarFp.scenariosStart(rangeId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Stops any associated containers or VMS
         * @summary Stops all containers and vms in a scenario
         * @param {string} rangeId 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosStop(rangeId: string, uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<BackgroundJob>> {
            return localVarFp.scenariosStop(rangeId, uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Re-deploys a scenario in an existing range. To re-use the currently existing overrides, omit them from the request payload.
         * @summary Updates a scenario
         * @param {string} rangeId 
         * @param {string} uuid 
         * @param {ScenariosUpdateByRangeIdUuidRequest} [scenariosUpdateByRangeIdUuidRequest] Optional runtime scenario specific overrides
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosUpdateByRangeIdUuid(rangeId: string, uuid: string, scenariosUpdateByRangeIdUuidRequest?: ScenariosUpdateByRangeIdUuidRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeployedScenario> {
            return localVarFp.scenariosUpdateByRangeIdUuid(rangeId, uuid, scenariosUpdateByRangeIdUuidRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesScenariosApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesScenariosApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesScenariosApi extends BaseAPI {
    /**
     * Deploys a scenario in an existing range
     * @summary Creates a scenario
     * @param {string} rangeId 
     * @param {ScenariosCreateByRangeIdRequest} scenariosCreateByRangeIdRequest Optional runtime scenario specific overrides
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesScenariosApi
     */
    public scenariosCreateByRangeId(rangeId: string, scenariosCreateByRangeIdRequest: ScenariosCreateByRangeIdRequest, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesScenariosApiFp(this.configuration).scenariosCreateByRangeId(rangeId, scenariosCreateByRangeIdRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a scenario from a range
     * @summary Deletes a scenario
     * @param {string} rangeId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesScenariosApi
     */
    public scenariosDeleteByRangeIdUuid(rangeId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesScenariosApiFp(this.configuration).scenariosDeleteByRangeIdUuid(rangeId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} rangeId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesScenariosApi
     */
    public scenariosGetKubeConfig(rangeId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesScenariosApiFp(this.configuration).scenariosGetKubeConfig(rangeId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List existing in-range scenarios
     * @summary List scenarios
     * @param {string} rangeId 
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {string} [tag] 
     * @param {string} [deployedBy] 
     * @param {string} [classId] 
     * @param {string} [studentId] 
     * @param {string} [studentUsername] 
     * @param {string} [scenarioId] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {ScenariosListByRangeIdSortByEnum} [sortBy] Key used to sort the collection by
     * @param {ScenariosListByRangeIdSortEnum} [sort] 
     * @param {Array<ScenariosListByRangeIdIncludesEnum>} [includes] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesScenariosApi
     */
    public scenariosListByRangeId(rangeId: string, uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, tag?: string, deployedBy?: string, classId?: string, studentId?: string, studentUsername?: string, scenarioId?: string, offset?: number, limit?: number, search?: string, sortBy?: ScenariosListByRangeIdSortByEnum, sort?: ScenariosListByRangeIdSortEnum, includes?: Array<ScenariosListByRangeIdIncludesEnum>, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesScenariosApiFp(this.configuration).scenariosListByRangeId(rangeId, uuid, name, description, author, metadata, tag, deployedBy, classId, studentId, studentUsername, scenarioId, offset, limit, search, sortBy, sort, includes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an existing in-range scenario
     * @summary Retrieve a scenario
     * @param {string} rangeId 
     * @param {string} uuid 
     * @param {Array<ScenariosRetrieveByRangeIdUuidIncludesEnum>} [includes] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesScenariosApi
     */
    public scenariosRetrieveByRangeIdUuid(rangeId: string, uuid: string, includes?: Array<ScenariosRetrieveByRangeIdUuidIncludesEnum>, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesScenariosApiFp(this.configuration).scenariosRetrieveByRangeIdUuid(rangeId, uuid, includes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve overrides for an existing in-range scenario
     * @summary Retrieve scenario overrides
     * @param {string} rangeId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesScenariosApi
     */
    public scenariosRetrieveScenarioOverrides(rangeId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesScenariosApiFp(this.configuration).scenariosRetrieveScenarioOverrides(rangeId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Starts any associated containers or VMS
     * @summary Stars all containers and vms in a scenario
     * @param {string} rangeId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesScenariosApi
     */
    public scenariosStart(rangeId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesScenariosApiFp(this.configuration).scenariosStart(rangeId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stops any associated containers or VMS
     * @summary Stops all containers and vms in a scenario
     * @param {string} rangeId 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesScenariosApi
     */
    public scenariosStop(rangeId: string, uuid: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesScenariosApiFp(this.configuration).scenariosStop(rangeId, uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Re-deploys a scenario in an existing range. To re-use the currently existing overrides, omit them from the request payload.
     * @summary Updates a scenario
     * @param {string} rangeId 
     * @param {string} uuid 
     * @param {ScenariosUpdateByRangeIdUuidRequest} [scenariosUpdateByRangeIdUuidRequest] Optional runtime scenario specific overrides
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesScenariosApi
     */
    public scenariosUpdateByRangeIdUuid(rangeId: string, uuid: string, scenariosUpdateByRangeIdUuidRequest?: ScenariosUpdateByRangeIdUuidRequest, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesScenariosApiFp(this.configuration).scenariosUpdateByRangeIdUuid(rangeId, uuid, scenariosUpdateByRangeIdUuidRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ScenariosListByRangeIdSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author',
    ScenarioId: 'scenarioId',
    DeployedBy: 'deployedBy',
    StudentUsername: 'studentUsername'
} as const;
export type ScenariosListByRangeIdSortByEnum = typeof ScenariosListByRangeIdSortByEnum[keyof typeof ScenariosListByRangeIdSortByEnum];
/**
 * @export
 */
export const ScenariosListByRangeIdSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ScenariosListByRangeIdSortEnum = typeof ScenariosListByRangeIdSortEnum[keyof typeof ScenariosListByRangeIdSortEnum];
/**
 * @export
 */
export const ScenariosListByRangeIdIncludesEnum = {
    DetailPackages: 'detail.packages'
} as const;
export type ScenariosListByRangeIdIncludesEnum = typeof ScenariosListByRangeIdIncludesEnum[keyof typeof ScenariosListByRangeIdIncludesEnum];
/**
 * @export
 */
export const ScenariosRetrieveByRangeIdUuidIncludesEnum = {
    DetailPackages: 'detail.packages'
} as const;
export type ScenariosRetrieveByRangeIdUuidIncludesEnum = typeof ScenariosRetrieveByRangeIdUuidIncludesEnum[keyof typeof ScenariosRetrieveByRangeIdUuidIncludesEnum];


/**
 * ManageRangeResourcesVirtualMachineRestoresApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesVirtualMachineRestoresApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Restores Virtual Machine State from specified snapshot
         * @summary Creates a Virtual Machine Restore
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} rangeVmId 
         * @param {string} snapshotName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualMachineRestoresCreate: async (rangeId: string, scenarioId: string, rangeVmId: string, snapshotName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('virtualMachineRestoresCreate', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('virtualMachineRestoresCreate', 'scenarioId', scenarioId)
            // verify required parameter 'rangeVmId' is not null or undefined
            assertParamExists('virtualMachineRestoresCreate', 'rangeVmId', rangeVmId)
            // verify required parameter 'snapshotName' is not null or undefined
            assertParamExists('virtualMachineRestoresCreate', 'snapshotName', snapshotName)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/{rangeVmId}/virtual-machine-restores/{snapshotName}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"rangeVmId"}}`, encodeURIComponent(String(rangeVmId)))
                .replace(`{${"snapshotName"}}`, encodeURIComponent(String(snapshotName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a Virtual Machine Restore in a scenario of a specific VM
         * @summary Deletes a Virtual Machine Restore
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} rangeVmId 
         * @param {string} restoreName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualMachineRestoresDelete: async (rangeId: string, scenarioId: string, rangeVmId: string, restoreName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('virtualMachineRestoresDelete', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('virtualMachineRestoresDelete', 'scenarioId', scenarioId)
            // verify required parameter 'rangeVmId' is not null or undefined
            assertParamExists('virtualMachineRestoresDelete', 'rangeVmId', rangeVmId)
            // verify required parameter 'restoreName' is not null or undefined
            assertParamExists('virtualMachineRestoresDelete', 'restoreName', restoreName)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/{rangeVmId}/virtual-machine-restores/{restoreName}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"rangeVmId"}}`, encodeURIComponent(String(rangeVmId)))
                .replace(`{${"restoreName"}}`, encodeURIComponent(String(restoreName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes all Virtual Machine Restores that correspond to a specific VM
         * @summary Deletes all Virtual Machine Restores that correspond to a specific VM
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} rangeVmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualMachineRestoresDeleteAll: async (rangeId: string, scenarioId: string, rangeVmId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('virtualMachineRestoresDeleteAll', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('virtualMachineRestoresDeleteAll', 'scenarioId', scenarioId)
            // verify required parameter 'rangeVmId' is not null or undefined
            assertParamExists('virtualMachineRestoresDeleteAll', 'rangeVmId', rangeVmId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/{rangeVmId}/virtual-machine-restores`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"rangeVmId"}}`, encodeURIComponent(String(rangeVmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing Virtual Machine Restores
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} rangeVmId 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {VirtualMachineRestoresListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {VirtualMachineRestoresListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualMachineRestoresList: async (rangeId: string, scenarioId: string, rangeVmId: string, offset?: number, limit?: number, search?: string, sortBy?: VirtualMachineRestoresListSortByEnum, sort?: VirtualMachineRestoresListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('virtualMachineRestoresList', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('virtualMachineRestoresList', 'scenarioId', scenarioId)
            // verify required parameter 'rangeVmId' is not null or undefined
            assertParamExists('virtualMachineRestoresList', 'rangeVmId', rangeVmId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/{rangeVmId}/virtual-machine-restores`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"rangeVmId"}}`, encodeURIComponent(String(rangeVmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesVirtualMachineRestoresApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesVirtualMachineRestoresApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesVirtualMachineRestoresApiAxiosParamCreator(configuration)
    return {
        /**
         * Restores Virtual Machine State from specified snapshot
         * @summary Creates a Virtual Machine Restore
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} rangeVmId 
         * @param {string} snapshotName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualMachineRestoresCreate(rangeId: string, scenarioId: string, rangeVmId: string, snapshotName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualMachineRestoresCreate(rangeId, scenarioId, rangeVmId, snapshotName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesVirtualMachineRestoresApi.virtualMachineRestoresCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a Virtual Machine Restore in a scenario of a specific VM
         * @summary Deletes a Virtual Machine Restore
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} rangeVmId 
         * @param {string} restoreName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualMachineRestoresDelete(rangeId: string, scenarioId: string, rangeVmId: string, restoreName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualMachineRestoresDelete(rangeId, scenarioId, rangeVmId, restoreName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesVirtualMachineRestoresApi.virtualMachineRestoresDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes all Virtual Machine Restores that correspond to a specific VM
         * @summary Deletes all Virtual Machine Restores that correspond to a specific VM
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} rangeVmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualMachineRestoresDeleteAll(rangeId: string, scenarioId: string, rangeVmId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualMachineRestoresDeleteAll(rangeId, scenarioId, rangeVmId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesVirtualMachineRestoresApi.virtualMachineRestoresDeleteAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing Virtual Machine Restores
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} rangeVmId 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {VirtualMachineRestoresListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {VirtualMachineRestoresListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualMachineRestoresList(rangeId: string, scenarioId: string, rangeVmId: string, offset?: number, limit?: number, search?: string, sortBy?: VirtualMachineRestoresListSortByEnum, sort?: VirtualMachineRestoresListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualMachineRestoresList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualMachineRestoresList(rangeId, scenarioId, rangeVmId, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesVirtualMachineRestoresApi.virtualMachineRestoresList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesVirtualMachineRestoresApi - factory interface
 * @export
 */
export const ManageRangeResourcesVirtualMachineRestoresApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesVirtualMachineRestoresApiFp(configuration)
    return {
        /**
         * Restores Virtual Machine State from specified snapshot
         * @summary Creates a Virtual Machine Restore
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} rangeVmId 
         * @param {string} snapshotName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualMachineRestoresCreate(rangeId: string, scenarioId: string, rangeVmId: string, snapshotName: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.virtualMachineRestoresCreate(rangeId, scenarioId, rangeVmId, snapshotName, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a Virtual Machine Restore in a scenario of a specific VM
         * @summary Deletes a Virtual Machine Restore
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} rangeVmId 
         * @param {string} restoreName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualMachineRestoresDelete(rangeId: string, scenarioId: string, rangeVmId: string, restoreName: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.virtualMachineRestoresDelete(rangeId, scenarioId, rangeVmId, restoreName, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes all Virtual Machine Restores that correspond to a specific VM
         * @summary Deletes all Virtual Machine Restores that correspond to a specific VM
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} rangeVmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualMachineRestoresDeleteAll(rangeId: string, scenarioId: string, rangeVmId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.virtualMachineRestoresDeleteAll(rangeId, scenarioId, rangeVmId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing Virtual Machine Restores
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} rangeVmId 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {VirtualMachineRestoresListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {VirtualMachineRestoresListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualMachineRestoresList(rangeId: string, scenarioId: string, rangeVmId: string, offset?: number, limit?: number, search?: string, sortBy?: VirtualMachineRestoresListSortByEnum, sort?: VirtualMachineRestoresListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<VirtualMachineRestoresList200Response> {
            return localVarFp.virtualMachineRestoresList(rangeId, scenarioId, rangeVmId, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesVirtualMachineRestoresApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesVirtualMachineRestoresApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesVirtualMachineRestoresApi extends BaseAPI {
    /**
     * Restores Virtual Machine State from specified snapshot
     * @summary Creates a Virtual Machine Restore
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} rangeVmId 
     * @param {string} snapshotName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesVirtualMachineRestoresApi
     */
    public virtualMachineRestoresCreate(rangeId: string, scenarioId: string, rangeVmId: string, snapshotName: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesVirtualMachineRestoresApiFp(this.configuration).virtualMachineRestoresCreate(rangeId, scenarioId, rangeVmId, snapshotName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a Virtual Machine Restore in a scenario of a specific VM
     * @summary Deletes a Virtual Machine Restore
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} rangeVmId 
     * @param {string} restoreName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesVirtualMachineRestoresApi
     */
    public virtualMachineRestoresDelete(rangeId: string, scenarioId: string, rangeVmId: string, restoreName: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesVirtualMachineRestoresApiFp(this.configuration).virtualMachineRestoresDelete(rangeId, scenarioId, rangeVmId, restoreName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes all Virtual Machine Restores that correspond to a specific VM
     * @summary Deletes all Virtual Machine Restores that correspond to a specific VM
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} rangeVmId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesVirtualMachineRestoresApi
     */
    public virtualMachineRestoresDeleteAll(rangeId: string, scenarioId: string, rangeVmId: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesVirtualMachineRestoresApiFp(this.configuration).virtualMachineRestoresDeleteAll(rangeId, scenarioId, rangeVmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing Virtual Machine Restores
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} rangeVmId 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {VirtualMachineRestoresListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {VirtualMachineRestoresListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesVirtualMachineRestoresApi
     */
    public virtualMachineRestoresList(rangeId: string, scenarioId: string, rangeVmId: string, offset?: number, limit?: number, search?: string, sortBy?: VirtualMachineRestoresListSortByEnum, sort?: VirtualMachineRestoresListSortEnum, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesVirtualMachineRestoresApiFp(this.configuration).virtualMachineRestoresList(rangeId, scenarioId, rangeVmId, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const VirtualMachineRestoresListSortByEnum = {
    Name: 'name',
    CreationTimestamp: 'creationTimestamp',
    VmName: 'vmName',
    SnapshotName: 'snapshotName'
} as const;
export type VirtualMachineRestoresListSortByEnum = typeof VirtualMachineRestoresListSortByEnum[keyof typeof VirtualMachineRestoresListSortByEnum];
/**
 * @export
 */
export const VirtualMachineRestoresListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type VirtualMachineRestoresListSortEnum = typeof VirtualMachineRestoresListSortEnum[keyof typeof VirtualMachineRestoresListSortEnum];


/**
 * ManageRangeResourcesVirtualMachineSnapshotsApi - axios parameter creator
 * @export
 */
export const ManageRangeResourcesVirtualMachineSnapshotsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a Virtual Machine Snapshot in a scenario of a specific VM
         * @summary Creates Virtual Machine Snapshot
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} rangeVmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualMachineSnapshotsCreate: async (rangeId: string, scenarioId: string, rangeVmId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('virtualMachineSnapshotsCreate', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('virtualMachineSnapshotsCreate', 'scenarioId', scenarioId)
            // verify required parameter 'rangeVmId' is not null or undefined
            assertParamExists('virtualMachineSnapshotsCreate', 'rangeVmId', rangeVmId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/virtual-machine-snapshots/{rangeVmId}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"rangeVmId"}}`, encodeURIComponent(String(rangeVmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a Virtual Machine Snapshot in a scenario for each VM listed
         * @summary Creates Virtual Machine Snapshots for all listed VMs
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualMachineSnapshotsCreateFromList: async (rangeId: string, scenarioId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('virtualMachineSnapshotsCreateFromList', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('virtualMachineSnapshotsCreateFromList', 'scenarioId', scenarioId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/virtual-machine-snapshots`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a Virtual Machine Snapshot in a scenario of a specific VM
         * @summary Deletes a Virtual Machine Snapshot
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} rangeVmId 
         * @param {string} snapshotName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualMachineSnapshotsDelete: async (rangeId: string, scenarioId: string, rangeVmId: string, snapshotName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('virtualMachineSnapshotsDelete', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('virtualMachineSnapshotsDelete', 'scenarioId', scenarioId)
            // verify required parameter 'rangeVmId' is not null or undefined
            assertParamExists('virtualMachineSnapshotsDelete', 'rangeVmId', rangeVmId)
            // verify required parameter 'snapshotName' is not null or undefined
            assertParamExists('virtualMachineSnapshotsDelete', 'snapshotName', snapshotName)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/virtual-machine-snapshots/{rangeVmId}/{snapshotName}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"rangeVmId"}}`, encodeURIComponent(String(rangeVmId)))
                .replace(`{${"snapshotName"}}`, encodeURIComponent(String(snapshotName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all existing Virtual Machine Snapshots in a scenario
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [search] Search the list partially or fully
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {VirtualMachineSnapshotsListSnapshotsSortByEnum} [sortBy] Key used to sort the collection by
         * @param {VirtualMachineSnapshotsListSnapshotsSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualMachineSnapshotsListSnapshots: async (rangeId: string, scenarioId: string, search?: string, offset?: number, limit?: number, sortBy?: VirtualMachineSnapshotsListSnapshotsSortByEnum, sort?: VirtualMachineSnapshotsListSnapshotsSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('virtualMachineSnapshotsListSnapshots', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('virtualMachineSnapshotsListSnapshots', 'scenarioId', scenarioId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/virtual-machine-snapshots`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Virtual Machine Snapshots from a specific VM in a scenario
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} rangeVmId 
         * @param {string} [search] Search the list partially or fully
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {VirtualMachineSnapshotsRetrieveSortByEnum} [sortBy] Key used to sort the collection by
         * @param {VirtualMachineSnapshotsRetrieveSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualMachineSnapshotsRetrieve: async (rangeId: string, scenarioId: string, rangeVmId: string, search?: string, offset?: number, limit?: number, sortBy?: VirtualMachineSnapshotsRetrieveSortByEnum, sort?: VirtualMachineSnapshotsRetrieveSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rangeId' is not null or undefined
            assertParamExists('virtualMachineSnapshotsRetrieve', 'rangeId', rangeId)
            // verify required parameter 'scenarioId' is not null or undefined
            assertParamExists('virtualMachineSnapshotsRetrieve', 'scenarioId', scenarioId)
            // verify required parameter 'rangeVmId' is not null or undefined
            assertParamExists('virtualMachineSnapshotsRetrieve', 'rangeVmId', rangeVmId)
            const localVarPath = `/v1/manage/range/{rangeId}/scenarios/{scenarioId}/virtual-machine-snapshots/{rangeVmId}`
                .replace(`{${"rangeId"}}`, encodeURIComponent(String(rangeId)))
                .replace(`{${"scenarioId"}}`, encodeURIComponent(String(scenarioId)))
                .replace(`{${"rangeVmId"}}`, encodeURIComponent(String(rangeVmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageRangeResourcesVirtualMachineSnapshotsApi - functional programming interface
 * @export
 */
export const ManageRangeResourcesVirtualMachineSnapshotsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageRangeResourcesVirtualMachineSnapshotsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a Virtual Machine Snapshot in a scenario of a specific VM
         * @summary Creates Virtual Machine Snapshot
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} rangeVmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualMachineSnapshotsCreate(rangeId: string, scenarioId: string, rangeVmId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BackgroundJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualMachineSnapshotsCreate(rangeId, scenarioId, rangeVmId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesVirtualMachineSnapshotsApi.virtualMachineSnapshotsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a Virtual Machine Snapshot in a scenario for each VM listed
         * @summary Creates Virtual Machine Snapshots for all listed VMs
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualMachineSnapshotsCreateFromList(rangeId: string, scenarioId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BackgroundJob>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualMachineSnapshotsCreateFromList(rangeId, scenarioId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesVirtualMachineSnapshotsApi.virtualMachineSnapshotsCreateFromList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a Virtual Machine Snapshot in a scenario of a specific VM
         * @summary Deletes a Virtual Machine Snapshot
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} rangeVmId 
         * @param {string} snapshotName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualMachineSnapshotsDelete(rangeId: string, scenarioId: string, rangeVmId: string, snapshotName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualMachineSnapshotsDelete(rangeId, scenarioId, rangeVmId, snapshotName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesVirtualMachineSnapshotsApi.virtualMachineSnapshotsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all existing Virtual Machine Snapshots in a scenario
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [search] Search the list partially or fully
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {VirtualMachineSnapshotsListSnapshotsSortByEnum} [sortBy] Key used to sort the collection by
         * @param {VirtualMachineSnapshotsListSnapshotsSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualMachineSnapshotsListSnapshots(rangeId: string, scenarioId: string, search?: string, offset?: number, limit?: number, sortBy?: VirtualMachineSnapshotsListSnapshotsSortByEnum, sort?: VirtualMachineSnapshotsListSnapshotsSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualMachineSnapshotsListSnapshots200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualMachineSnapshotsListSnapshots(rangeId, scenarioId, search, offset, limit, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesVirtualMachineSnapshotsApi.virtualMachineSnapshotsListSnapshots']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List Virtual Machine Snapshots from a specific VM in a scenario
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} rangeVmId 
         * @param {string} [search] Search the list partially or fully
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {VirtualMachineSnapshotsRetrieveSortByEnum} [sortBy] Key used to sort the collection by
         * @param {VirtualMachineSnapshotsRetrieveSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualMachineSnapshotsRetrieve(rangeId: string, scenarioId: string, rangeVmId: string, search?: string, offset?: number, limit?: number, sortBy?: VirtualMachineSnapshotsRetrieveSortByEnum, sort?: VirtualMachineSnapshotsRetrieveSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualMachineSnapshotsListSnapshots200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualMachineSnapshotsRetrieve(rangeId, scenarioId, rangeVmId, search, offset, limit, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageRangeResourcesVirtualMachineSnapshotsApi.virtualMachineSnapshotsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageRangeResourcesVirtualMachineSnapshotsApi - factory interface
 * @export
 */
export const ManageRangeResourcesVirtualMachineSnapshotsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageRangeResourcesVirtualMachineSnapshotsApiFp(configuration)
    return {
        /**
         * Creates a Virtual Machine Snapshot in a scenario of a specific VM
         * @summary Creates Virtual Machine Snapshot
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} rangeVmId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualMachineSnapshotsCreate(rangeId: string, scenarioId: string, rangeVmId: string, options?: RawAxiosRequestConfig): AxiosPromise<BackgroundJob> {
            return localVarFp.virtualMachineSnapshotsCreate(rangeId, scenarioId, rangeVmId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a Virtual Machine Snapshot in a scenario for each VM listed
         * @summary Creates Virtual Machine Snapshots for all listed VMs
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualMachineSnapshotsCreateFromList(rangeId: string, scenarioId: string, options?: RawAxiosRequestConfig): AxiosPromise<BackgroundJob> {
            return localVarFp.virtualMachineSnapshotsCreateFromList(rangeId, scenarioId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a Virtual Machine Snapshot in a scenario of a specific VM
         * @summary Deletes a Virtual Machine Snapshot
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} rangeVmId 
         * @param {string} snapshotName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualMachineSnapshotsDelete(rangeId: string, scenarioId: string, rangeVmId: string, snapshotName: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.virtualMachineSnapshotsDelete(rangeId, scenarioId, rangeVmId, snapshotName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all existing Virtual Machine Snapshots in a scenario
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} [search] Search the list partially or fully
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {VirtualMachineSnapshotsListSnapshotsSortByEnum} [sortBy] Key used to sort the collection by
         * @param {VirtualMachineSnapshotsListSnapshotsSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualMachineSnapshotsListSnapshots(rangeId: string, scenarioId: string, search?: string, offset?: number, limit?: number, sortBy?: VirtualMachineSnapshotsListSnapshotsSortByEnum, sort?: VirtualMachineSnapshotsListSnapshotsSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<VirtualMachineSnapshotsListSnapshots200Response> {
            return localVarFp.virtualMachineSnapshotsListSnapshots(rangeId, scenarioId, search, offset, limit, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Virtual Machine Snapshots from a specific VM in a scenario
         * @param {string} rangeId 
         * @param {string} scenarioId 
         * @param {string} rangeVmId 
         * @param {string} [search] Search the list partially or fully
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {VirtualMachineSnapshotsRetrieveSortByEnum} [sortBy] Key used to sort the collection by
         * @param {VirtualMachineSnapshotsRetrieveSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualMachineSnapshotsRetrieve(rangeId: string, scenarioId: string, rangeVmId: string, search?: string, offset?: number, limit?: number, sortBy?: VirtualMachineSnapshotsRetrieveSortByEnum, sort?: VirtualMachineSnapshotsRetrieveSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<VirtualMachineSnapshotsListSnapshots200Response> {
            return localVarFp.virtualMachineSnapshotsRetrieve(rangeId, scenarioId, rangeVmId, search, offset, limit, sortBy, sort, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageRangeResourcesVirtualMachineSnapshotsApi - object-oriented interface
 * @export
 * @class ManageRangeResourcesVirtualMachineSnapshotsApi
 * @extends {BaseAPI}
 */
export class ManageRangeResourcesVirtualMachineSnapshotsApi extends BaseAPI {
    /**
     * Creates a Virtual Machine Snapshot in a scenario of a specific VM
     * @summary Creates Virtual Machine Snapshot
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} rangeVmId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesVirtualMachineSnapshotsApi
     */
    public virtualMachineSnapshotsCreate(rangeId: string, scenarioId: string, rangeVmId: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesVirtualMachineSnapshotsApiFp(this.configuration).virtualMachineSnapshotsCreate(rangeId, scenarioId, rangeVmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a Virtual Machine Snapshot in a scenario for each VM listed
     * @summary Creates Virtual Machine Snapshots for all listed VMs
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesVirtualMachineSnapshotsApi
     */
    public virtualMachineSnapshotsCreateFromList(rangeId: string, scenarioId: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesVirtualMachineSnapshotsApiFp(this.configuration).virtualMachineSnapshotsCreateFromList(rangeId, scenarioId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a Virtual Machine Snapshot in a scenario of a specific VM
     * @summary Deletes a Virtual Machine Snapshot
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} rangeVmId 
     * @param {string} snapshotName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesVirtualMachineSnapshotsApi
     */
    public virtualMachineSnapshotsDelete(rangeId: string, scenarioId: string, rangeVmId: string, snapshotName: string, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesVirtualMachineSnapshotsApiFp(this.configuration).virtualMachineSnapshotsDelete(rangeId, scenarioId, rangeVmId, snapshotName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all existing Virtual Machine Snapshots in a scenario
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} [search] Search the list partially or fully
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {VirtualMachineSnapshotsListSnapshotsSortByEnum} [sortBy] Key used to sort the collection by
     * @param {VirtualMachineSnapshotsListSnapshotsSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesVirtualMachineSnapshotsApi
     */
    public virtualMachineSnapshotsListSnapshots(rangeId: string, scenarioId: string, search?: string, offset?: number, limit?: number, sortBy?: VirtualMachineSnapshotsListSnapshotsSortByEnum, sort?: VirtualMachineSnapshotsListSnapshotsSortEnum, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesVirtualMachineSnapshotsApiFp(this.configuration).virtualMachineSnapshotsListSnapshots(rangeId, scenarioId, search, offset, limit, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Virtual Machine Snapshots from a specific VM in a scenario
     * @param {string} rangeId 
     * @param {string} scenarioId 
     * @param {string} rangeVmId 
     * @param {string} [search] Search the list partially or fully
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {VirtualMachineSnapshotsRetrieveSortByEnum} [sortBy] Key used to sort the collection by
     * @param {VirtualMachineSnapshotsRetrieveSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageRangeResourcesVirtualMachineSnapshotsApi
     */
    public virtualMachineSnapshotsRetrieve(rangeId: string, scenarioId: string, rangeVmId: string, search?: string, offset?: number, limit?: number, sortBy?: VirtualMachineSnapshotsRetrieveSortByEnum, sort?: VirtualMachineSnapshotsRetrieveSortEnum, options?: RawAxiosRequestConfig) {
        return ManageRangeResourcesVirtualMachineSnapshotsApiFp(this.configuration).virtualMachineSnapshotsRetrieve(rangeId, scenarioId, rangeVmId, search, offset, limit, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const VirtualMachineSnapshotsListSnapshotsSortByEnum = {
    Name: 'name',
    CreationTimestamp: 'creationTimestamp',
    VmName: 'vmName'
} as const;
export type VirtualMachineSnapshotsListSnapshotsSortByEnum = typeof VirtualMachineSnapshotsListSnapshotsSortByEnum[keyof typeof VirtualMachineSnapshotsListSnapshotsSortByEnum];
/**
 * @export
 */
export const VirtualMachineSnapshotsListSnapshotsSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type VirtualMachineSnapshotsListSnapshotsSortEnum = typeof VirtualMachineSnapshotsListSnapshotsSortEnum[keyof typeof VirtualMachineSnapshotsListSnapshotsSortEnum];
/**
 * @export
 */
export const VirtualMachineSnapshotsRetrieveSortByEnum = {
    Name: 'name',
    CreationTimestamp: 'creationTimestamp',
    VmName: 'vmName'
} as const;
export type VirtualMachineSnapshotsRetrieveSortByEnum = typeof VirtualMachineSnapshotsRetrieveSortByEnum[keyof typeof VirtualMachineSnapshotsRetrieveSortByEnum];
/**
 * @export
 */
export const VirtualMachineSnapshotsRetrieveSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type VirtualMachineSnapshotsRetrieveSortEnum = typeof VirtualMachineSnapshotsRetrieveSortEnum[keyof typeof VirtualMachineSnapshotsRetrieveSortEnum];


/**
 * OPAMTOApi - axios parameter creator
 * @export
 */
export const OPAMTOApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Warning: Swagger UI might crash when trying to display the MTO tree.
         * @summary Retrieve MTO tree
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mtoRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/opa/mto`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OPAMTOApi - functional programming interface
 * @export
 */
export const OPAMTOApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OPAMTOApiAxiosParamCreator(configuration)
    return {
        /**
         * Warning: Swagger UI might crash when trying to display the MTO tree.
         * @summary Retrieve MTO tree
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mtoRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MtoTreeNode>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mtoRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OPAMTOApi.mtoRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OPAMTOApi - factory interface
 * @export
 */
export const OPAMTOApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OPAMTOApiFp(configuration)
    return {
        /**
         * Warning: Swagger UI might crash when trying to display the MTO tree.
         * @summary Retrieve MTO tree
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mtoRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<MtoTreeNode> {
            return localVarFp.mtoRetrieve(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OPAMTOApi - object-oriented interface
 * @export
 * @class OPAMTOApi
 * @extends {BaseAPI}
 */
export class OPAMTOApi extends BaseAPI {
    /**
     * Warning: Swagger UI might crash when trying to display the MTO tree.
     * @summary Retrieve MTO tree
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OPAMTOApi
     */
    public mtoRetrieve(options?: RawAxiosRequestConfig) {
        return OPAMTOApiFp(this.configuration).mtoRetrieve(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProvisioningServiceAnsiblePlaybooksApi - axios parameter creator
 * @export
 */
export const ProvisioningServiceAnsiblePlaybooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an Ansible Playbook
         * @param {AnsiblePlaybookCreate} [ansiblePlaybookCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ansiblePlaybooksCreate: async (ansiblePlaybookCreate?: AnsiblePlaybookCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/provisioning-service/ansible-playbook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ansiblePlaybookCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an Ansible Playbook from the provisioning service
         * @summary Deletes an Ansible Playbook
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ansiblePlaybooksDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('ansiblePlaybooksDelete', 'uuid', uuid)
            const localVarPath = `/v1/provisioning-service/ansible-playbook/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing Ansible Playbooks
         * @param {string} [author] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [uuid] 
         * @param {boolean} [schema] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {AnsiblePlaybooksListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {AnsiblePlaybooksListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ansiblePlaybooksList: async (author?: string, name?: string, description?: string, uuid?: string, schema?: boolean, offset?: number, limit?: number, search?: string, sortBy?: AnsiblePlaybooksListSortByEnum, sort?: AnsiblePlaybooksListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/provisioning-service/ansible-playbook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (schema !== undefined) {
                localVarQueryParameter['schema'] = schema;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an Ansible Playbook from the provisioning service
         * @summary Retrieve an Ansible Playbook
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ansiblePlaybooksRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('ansiblePlaybooksRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/provisioning-service/ansible-playbook/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an Ansible Playbook
         * @param {string} uuid 
         * @param {AnsiblePlaybookUpdate} [ansiblePlaybookUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ansiblePlaybooksUpdate: async (uuid: string, ansiblePlaybookUpdate?: AnsiblePlaybookUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('ansiblePlaybooksUpdate', 'uuid', uuid)
            const localVarPath = `/v1/provisioning-service/ansible-playbook/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ansiblePlaybookUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProvisioningServiceAnsiblePlaybooksApi - functional programming interface
 * @export
 */
export const ProvisioningServiceAnsiblePlaybooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProvisioningServiceAnsiblePlaybooksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create an Ansible Playbook
         * @param {AnsiblePlaybookCreate} [ansiblePlaybookCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ansiblePlaybooksCreate(ansiblePlaybookCreate?: AnsiblePlaybookCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnsiblePlaybook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ansiblePlaybooksCreate(ansiblePlaybookCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningServiceAnsiblePlaybooksApi.ansiblePlaybooksCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes an Ansible Playbook from the provisioning service
         * @summary Deletes an Ansible Playbook
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ansiblePlaybooksDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ansiblePlaybooksDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningServiceAnsiblePlaybooksApi.ansiblePlaybooksDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing Ansible Playbooks
         * @param {string} [author] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [uuid] 
         * @param {boolean} [schema] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {AnsiblePlaybooksListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {AnsiblePlaybooksListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ansiblePlaybooksList(author?: string, name?: string, description?: string, uuid?: string, schema?: boolean, offset?: number, limit?: number, search?: string, sortBy?: AnsiblePlaybooksListSortByEnum, sort?: AnsiblePlaybooksListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnsiblePlaybooksList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ansiblePlaybooksList(author, name, description, uuid, schema, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningServiceAnsiblePlaybooksApi.ansiblePlaybooksList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an Ansible Playbook from the provisioning service
         * @summary Retrieve an Ansible Playbook
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ansiblePlaybooksRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnsiblePlaybook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ansiblePlaybooksRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningServiceAnsiblePlaybooksApi.ansiblePlaybooksRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an Ansible Playbook
         * @param {string} uuid 
         * @param {AnsiblePlaybookUpdate} [ansiblePlaybookUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ansiblePlaybooksUpdate(uuid: string, ansiblePlaybookUpdate?: AnsiblePlaybookUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnsiblePlaybook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ansiblePlaybooksUpdate(uuid, ansiblePlaybookUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningServiceAnsiblePlaybooksApi.ansiblePlaybooksUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProvisioningServiceAnsiblePlaybooksApi - factory interface
 * @export
 */
export const ProvisioningServiceAnsiblePlaybooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProvisioningServiceAnsiblePlaybooksApiFp(configuration)
    return {
        /**
         * 
         * @summary Create an Ansible Playbook
         * @param {AnsiblePlaybookCreate} [ansiblePlaybookCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ansiblePlaybooksCreate(ansiblePlaybookCreate?: AnsiblePlaybookCreate, options?: RawAxiosRequestConfig): AxiosPromise<AnsiblePlaybook> {
            return localVarFp.ansiblePlaybooksCreate(ansiblePlaybookCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an Ansible Playbook from the provisioning service
         * @summary Deletes an Ansible Playbook
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ansiblePlaybooksDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.ansiblePlaybooksDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing Ansible Playbooks
         * @param {string} [author] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [uuid] 
         * @param {boolean} [schema] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {AnsiblePlaybooksListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {AnsiblePlaybooksListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ansiblePlaybooksList(author?: string, name?: string, description?: string, uuid?: string, schema?: boolean, offset?: number, limit?: number, search?: string, sortBy?: AnsiblePlaybooksListSortByEnum, sort?: AnsiblePlaybooksListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<AnsiblePlaybooksList200Response> {
            return localVarFp.ansiblePlaybooksList(author, name, description, uuid, schema, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an Ansible Playbook from the provisioning service
         * @summary Retrieve an Ansible Playbook
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ansiblePlaybooksRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<AnsiblePlaybook> {
            return localVarFp.ansiblePlaybooksRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an Ansible Playbook
         * @param {string} uuid 
         * @param {AnsiblePlaybookUpdate} [ansiblePlaybookUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ansiblePlaybooksUpdate(uuid: string, ansiblePlaybookUpdate?: AnsiblePlaybookUpdate, options?: RawAxiosRequestConfig): AxiosPromise<AnsiblePlaybook> {
            return localVarFp.ansiblePlaybooksUpdate(uuid, ansiblePlaybookUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProvisioningServiceAnsiblePlaybooksApi - object-oriented interface
 * @export
 * @class ProvisioningServiceAnsiblePlaybooksApi
 * @extends {BaseAPI}
 */
export class ProvisioningServiceAnsiblePlaybooksApi extends BaseAPI {
    /**
     * 
     * @summary Create an Ansible Playbook
     * @param {AnsiblePlaybookCreate} [ansiblePlaybookCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningServiceAnsiblePlaybooksApi
     */
    public ansiblePlaybooksCreate(ansiblePlaybookCreate?: AnsiblePlaybookCreate, options?: RawAxiosRequestConfig) {
        return ProvisioningServiceAnsiblePlaybooksApiFp(this.configuration).ansiblePlaybooksCreate(ansiblePlaybookCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an Ansible Playbook from the provisioning service
     * @summary Deletes an Ansible Playbook
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningServiceAnsiblePlaybooksApi
     */
    public ansiblePlaybooksDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return ProvisioningServiceAnsiblePlaybooksApiFp(this.configuration).ansiblePlaybooksDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing Ansible Playbooks
     * @param {string} [author] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [uuid] 
     * @param {boolean} [schema] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {AnsiblePlaybooksListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {AnsiblePlaybooksListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningServiceAnsiblePlaybooksApi
     */
    public ansiblePlaybooksList(author?: string, name?: string, description?: string, uuid?: string, schema?: boolean, offset?: number, limit?: number, search?: string, sortBy?: AnsiblePlaybooksListSortByEnum, sort?: AnsiblePlaybooksListSortEnum, options?: RawAxiosRequestConfig) {
        return ProvisioningServiceAnsiblePlaybooksApiFp(this.configuration).ansiblePlaybooksList(author, name, description, uuid, schema, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an Ansible Playbook from the provisioning service
     * @summary Retrieve an Ansible Playbook
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningServiceAnsiblePlaybooksApi
     */
    public ansiblePlaybooksRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return ProvisioningServiceAnsiblePlaybooksApiFp(this.configuration).ansiblePlaybooksRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an Ansible Playbook
     * @param {string} uuid 
     * @param {AnsiblePlaybookUpdate} [ansiblePlaybookUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningServiceAnsiblePlaybooksApi
     */
    public ansiblePlaybooksUpdate(uuid: string, ansiblePlaybookUpdate?: AnsiblePlaybookUpdate, options?: RawAxiosRequestConfig) {
        return ProvisioningServiceAnsiblePlaybooksApiFp(this.configuration).ansiblePlaybooksUpdate(uuid, ansiblePlaybookUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const AnsiblePlaybooksListSortByEnum = {
    Author: 'author',
    Name: 'name',
    Description: 'description',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Uuid: 'uuid'
} as const;
export type AnsiblePlaybooksListSortByEnum = typeof AnsiblePlaybooksListSortByEnum[keyof typeof AnsiblePlaybooksListSortByEnum];
/**
 * @export
 */
export const AnsiblePlaybooksListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type AnsiblePlaybooksListSortEnum = typeof AnsiblePlaybooksListSortEnum[keyof typeof AnsiblePlaybooksListSortEnum];


/**
 * ProvisioningServiceAnsibleRolesApi - axios parameter creator
 * @export
 */
export const ProvisioningServiceAnsibleRolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an Ansible Role
         * @param {string} name A user provided human readable name.
         * @param {File} file The file to upload
         * @param {Array<string>} systemCpeUuids Array of CPE UUIDs
         * @param {string} [description] A user provided human readable description.
         * @param {object} [metadata] User provided metadata
         * @param {Array<ScenarioGroup>} [scenarioGroups] Optional list of ScenarioGroups that can view the resource when deployed
         * @param {object} [roleVariablesSchema] JSON Schema for Role Variables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ansibleRolesCreate: async (name: string, file: File, systemCpeUuids: Array<string>, description?: string, metadata?: object, scenarioGroups?: Array<ScenarioGroup>, roleVariablesSchema?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('ansibleRolesCreate', 'name', name)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('ansibleRolesCreate', 'file', file)
            // verify required parameter 'systemCpeUuids' is not null or undefined
            assertParamExists('ansibleRolesCreate', 'systemCpeUuids', systemCpeUuids)
            const localVarPath = `/v1/provisioning-service/ansible-role`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (metadata !== undefined) { 
                localVarFormParams.append('metadata', new Blob([JSON.stringify(metadata)], { type: "application/json", }));
            }
                if (scenarioGroups) {
                localVarFormParams.append('scenarioGroups', scenarioGroups.join(COLLECTION_FORMATS.csv));
            }

    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (roleVariablesSchema !== undefined) { 
                localVarFormParams.append('roleVariablesSchema', JSON.stringify(roleVariablesSchema));
            }
                if (systemCpeUuids) {
                localVarFormParams.append('systemCpeUuids', systemCpeUuids.join(COLLECTION_FORMATS.csv));
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an Ansible Role from the provisioning service
         * @summary Deletes an Ansible Role
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ansibleRolesDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('ansibleRolesDelete', 'uuid', uuid)
            const localVarPath = `/v1/provisioning-service/ansible-role/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download an Ansible Role
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ansibleRolesDownload: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('ansibleRolesDownload', 'uuid', uuid)
            const localVarPath = `/v1/provisioning-service/ansible-role/{uuid}/download`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * CPE match fields used for filtering must conform to the CPE (2.3) Name Matching Specification
         * @summary List existing Ansible Roles
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {boolean} [publicUrl] 
         * @param {string} [lang] CPE Match Field
         * @param {string} [other] CPE Match Field
         * @param {AnsibleRolesListPartEnum} [part] CPE Match Field
         * @param {string} [product] CPE Match Field
         * @param {string} [softwareEdition] CPE Match Field
         * @param {string} [targetHardware] CPE Match Field
         * @param {string} [targetSoftware] CPE Match Field
         * @param {string} [update] CPE Match Field
         * @param {string} [vendor] CPE Match Field
         * @param {string} [version] CPE Match Field
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {AnsibleRolesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {AnsibleRolesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ansibleRolesList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, publicUrl?: boolean, lang?: string, other?: string, part?: AnsibleRolesListPartEnum, product?: string, softwareEdition?: string, targetHardware?: string, targetSoftware?: string, update?: string, vendor?: string, version?: string, offset?: number, limit?: number, search?: string, sortBy?: AnsibleRolesListSortByEnum, sort?: AnsibleRolesListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/provisioning-service/ansible-role`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (publicUrl !== undefined) {
                localVarQueryParameter['publicUrl'] = publicUrl;
            }

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }

            if (other !== undefined) {
                localVarQueryParameter['other'] = other;
            }

            if (part !== undefined) {
                localVarQueryParameter['part'] = part;
            }

            if (product !== undefined) {
                localVarQueryParameter['product'] = product;
            }

            if (softwareEdition !== undefined) {
                localVarQueryParameter['softwareEdition'] = softwareEdition;
            }

            if (targetHardware !== undefined) {
                localVarQueryParameter['targetHardware'] = targetHardware;
            }

            if (targetSoftware !== undefined) {
                localVarQueryParameter['targetSoftware'] = targetSoftware;
            }

            if (update !== undefined) {
                localVarQueryParameter['update'] = update;
            }

            if (vendor !== undefined) {
                localVarQueryParameter['vendor'] = vendor;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve an Ansible Role from the provisioning service
         * @summary Retrieve an Ansible Role
         * @param {string} uuid 
         * @param {boolean} [publicUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ansibleRolesRetrieve: async (uuid: string, publicUrl?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('ansibleRolesRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/provisioning-service/ansible-role/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (publicUrl !== undefined) {
                localVarQueryParameter['publicUrl'] = publicUrl;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an Ansible Role
         * @param {string} uuid 
         * @param {AnsibleRoleUpdate} [ansibleRoleUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ansibleRolesUpdate: async (uuid: string, ansibleRoleUpdate?: AnsibleRoleUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('ansibleRolesUpdate', 'uuid', uuid)
            const localVarPath = `/v1/provisioning-service/ansible-role/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ansibleRoleUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProvisioningServiceAnsibleRolesApi - functional programming interface
 * @export
 */
export const ProvisioningServiceAnsibleRolesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProvisioningServiceAnsibleRolesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create an Ansible Role
         * @param {string} name A user provided human readable name.
         * @param {File} file The file to upload
         * @param {Array<string>} systemCpeUuids Array of CPE UUIDs
         * @param {string} [description] A user provided human readable description.
         * @param {object} [metadata] User provided metadata
         * @param {Array<ScenarioGroup>} [scenarioGroups] Optional list of ScenarioGroups that can view the resource when deployed
         * @param {object} [roleVariablesSchema] JSON Schema for Role Variables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ansibleRolesCreate(name: string, file: File, systemCpeUuids: Array<string>, description?: string, metadata?: object, scenarioGroups?: Array<ScenarioGroup>, roleVariablesSchema?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnsibleRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ansibleRolesCreate(name, file, systemCpeUuids, description, metadata, scenarioGroups, roleVariablesSchema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningServiceAnsibleRolesApi.ansibleRolesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes an Ansible Role from the provisioning service
         * @summary Deletes an Ansible Role
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ansibleRolesDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ansibleRolesDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningServiceAnsibleRolesApi.ansibleRolesDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download an Ansible Role
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ansibleRolesDownload(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ansibleRolesDownload(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningServiceAnsibleRolesApi.ansibleRolesDownload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * CPE match fields used for filtering must conform to the CPE (2.3) Name Matching Specification
         * @summary List existing Ansible Roles
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {boolean} [publicUrl] 
         * @param {string} [lang] CPE Match Field
         * @param {string} [other] CPE Match Field
         * @param {AnsibleRolesListPartEnum} [part] CPE Match Field
         * @param {string} [product] CPE Match Field
         * @param {string} [softwareEdition] CPE Match Field
         * @param {string} [targetHardware] CPE Match Field
         * @param {string} [targetSoftware] CPE Match Field
         * @param {string} [update] CPE Match Field
         * @param {string} [vendor] CPE Match Field
         * @param {string} [version] CPE Match Field
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {AnsibleRolesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {AnsibleRolesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ansibleRolesList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, publicUrl?: boolean, lang?: string, other?: string, part?: AnsibleRolesListPartEnum, product?: string, softwareEdition?: string, targetHardware?: string, targetSoftware?: string, update?: string, vendor?: string, version?: string, offset?: number, limit?: number, search?: string, sortBy?: AnsibleRolesListSortByEnum, sort?: AnsibleRolesListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnsibleRolesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ansibleRolesList(uuid, name, description, author, metadata, publicUrl, lang, other, part, product, softwareEdition, targetHardware, targetSoftware, update, vendor, version, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningServiceAnsibleRolesApi.ansibleRolesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an Ansible Role from the provisioning service
         * @summary Retrieve an Ansible Role
         * @param {string} uuid 
         * @param {boolean} [publicUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ansibleRolesRetrieve(uuid: string, publicUrl?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnsibleRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ansibleRolesRetrieve(uuid, publicUrl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningServiceAnsibleRolesApi.ansibleRolesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an Ansible Role
         * @param {string} uuid 
         * @param {AnsibleRoleUpdate} [ansibleRoleUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ansibleRolesUpdate(uuid: string, ansibleRoleUpdate?: AnsibleRoleUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnsibleRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ansibleRolesUpdate(uuid, ansibleRoleUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProvisioningServiceAnsibleRolesApi.ansibleRolesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProvisioningServiceAnsibleRolesApi - factory interface
 * @export
 */
export const ProvisioningServiceAnsibleRolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProvisioningServiceAnsibleRolesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create an Ansible Role
         * @param {string} name A user provided human readable name.
         * @param {File} file The file to upload
         * @param {Array<string>} systemCpeUuids Array of CPE UUIDs
         * @param {string} [description] A user provided human readable description.
         * @param {object} [metadata] User provided metadata
         * @param {Array<ScenarioGroup>} [scenarioGroups] Optional list of ScenarioGroups that can view the resource when deployed
         * @param {object} [roleVariablesSchema] JSON Schema for Role Variables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ansibleRolesCreate(name: string, file: File, systemCpeUuids: Array<string>, description?: string, metadata?: object, scenarioGroups?: Array<ScenarioGroup>, roleVariablesSchema?: object, options?: RawAxiosRequestConfig): AxiosPromise<AnsibleRole> {
            return localVarFp.ansibleRolesCreate(name, file, systemCpeUuids, description, metadata, scenarioGroups, roleVariablesSchema, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an Ansible Role from the provisioning service
         * @summary Deletes an Ansible Role
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ansibleRolesDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.ansibleRolesDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download an Ansible Role
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ansibleRolesDownload(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.ansibleRolesDownload(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * CPE match fields used for filtering must conform to the CPE (2.3) Name Matching Specification
         * @summary List existing Ansible Roles
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {boolean} [publicUrl] 
         * @param {string} [lang] CPE Match Field
         * @param {string} [other] CPE Match Field
         * @param {AnsibleRolesListPartEnum} [part] CPE Match Field
         * @param {string} [product] CPE Match Field
         * @param {string} [softwareEdition] CPE Match Field
         * @param {string} [targetHardware] CPE Match Field
         * @param {string} [targetSoftware] CPE Match Field
         * @param {string} [update] CPE Match Field
         * @param {string} [vendor] CPE Match Field
         * @param {string} [version] CPE Match Field
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {AnsibleRolesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {AnsibleRolesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ansibleRolesList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, publicUrl?: boolean, lang?: string, other?: string, part?: AnsibleRolesListPartEnum, product?: string, softwareEdition?: string, targetHardware?: string, targetSoftware?: string, update?: string, vendor?: string, version?: string, offset?: number, limit?: number, search?: string, sortBy?: AnsibleRolesListSortByEnum, sort?: AnsibleRolesListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<AnsibleRolesList200Response> {
            return localVarFp.ansibleRolesList(uuid, name, description, author, metadata, publicUrl, lang, other, part, product, softwareEdition, targetHardware, targetSoftware, update, vendor, version, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an Ansible Role from the provisioning service
         * @summary Retrieve an Ansible Role
         * @param {string} uuid 
         * @param {boolean} [publicUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ansibleRolesRetrieve(uuid: string, publicUrl?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<AnsibleRole> {
            return localVarFp.ansibleRolesRetrieve(uuid, publicUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an Ansible Role
         * @param {string} uuid 
         * @param {AnsibleRoleUpdate} [ansibleRoleUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ansibleRolesUpdate(uuid: string, ansibleRoleUpdate?: AnsibleRoleUpdate, options?: RawAxiosRequestConfig): AxiosPromise<AnsibleRole> {
            return localVarFp.ansibleRolesUpdate(uuid, ansibleRoleUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProvisioningServiceAnsibleRolesApi - object-oriented interface
 * @export
 * @class ProvisioningServiceAnsibleRolesApi
 * @extends {BaseAPI}
 */
export class ProvisioningServiceAnsibleRolesApi extends BaseAPI {
    /**
     * 
     * @summary Create an Ansible Role
     * @param {string} name A user provided human readable name.
     * @param {File} file The file to upload
     * @param {Array<string>} systemCpeUuids Array of CPE UUIDs
     * @param {string} [description] A user provided human readable description.
     * @param {object} [metadata] User provided metadata
     * @param {Array<ScenarioGroup>} [scenarioGroups] Optional list of ScenarioGroups that can view the resource when deployed
     * @param {object} [roleVariablesSchema] JSON Schema for Role Variables
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningServiceAnsibleRolesApi
     */
    public ansibleRolesCreate(name: string, file: File, systemCpeUuids: Array<string>, description?: string, metadata?: object, scenarioGroups?: Array<ScenarioGroup>, roleVariablesSchema?: object, options?: RawAxiosRequestConfig) {
        return ProvisioningServiceAnsibleRolesApiFp(this.configuration).ansibleRolesCreate(name, file, systemCpeUuids, description, metadata, scenarioGroups, roleVariablesSchema, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an Ansible Role from the provisioning service
     * @summary Deletes an Ansible Role
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningServiceAnsibleRolesApi
     */
    public ansibleRolesDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return ProvisioningServiceAnsibleRolesApiFp(this.configuration).ansibleRolesDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download an Ansible Role
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningServiceAnsibleRolesApi
     */
    public ansibleRolesDownload(uuid: string, options?: RawAxiosRequestConfig) {
        return ProvisioningServiceAnsibleRolesApiFp(this.configuration).ansibleRolesDownload(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * CPE match fields used for filtering must conform to the CPE (2.3) Name Matching Specification
     * @summary List existing Ansible Roles
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {boolean} [publicUrl] 
     * @param {string} [lang] CPE Match Field
     * @param {string} [other] CPE Match Field
     * @param {AnsibleRolesListPartEnum} [part] CPE Match Field
     * @param {string} [product] CPE Match Field
     * @param {string} [softwareEdition] CPE Match Field
     * @param {string} [targetHardware] CPE Match Field
     * @param {string} [targetSoftware] CPE Match Field
     * @param {string} [update] CPE Match Field
     * @param {string} [vendor] CPE Match Field
     * @param {string} [version] CPE Match Field
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {AnsibleRolesListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {AnsibleRolesListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningServiceAnsibleRolesApi
     */
    public ansibleRolesList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, publicUrl?: boolean, lang?: string, other?: string, part?: AnsibleRolesListPartEnum, product?: string, softwareEdition?: string, targetHardware?: string, targetSoftware?: string, update?: string, vendor?: string, version?: string, offset?: number, limit?: number, search?: string, sortBy?: AnsibleRolesListSortByEnum, sort?: AnsibleRolesListSortEnum, options?: RawAxiosRequestConfig) {
        return ProvisioningServiceAnsibleRolesApiFp(this.configuration).ansibleRolesList(uuid, name, description, author, metadata, publicUrl, lang, other, part, product, softwareEdition, targetHardware, targetSoftware, update, vendor, version, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve an Ansible Role from the provisioning service
     * @summary Retrieve an Ansible Role
     * @param {string} uuid 
     * @param {boolean} [publicUrl] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningServiceAnsibleRolesApi
     */
    public ansibleRolesRetrieve(uuid: string, publicUrl?: boolean, options?: RawAxiosRequestConfig) {
        return ProvisioningServiceAnsibleRolesApiFp(this.configuration).ansibleRolesRetrieve(uuid, publicUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an Ansible Role
     * @param {string} uuid 
     * @param {AnsibleRoleUpdate} [ansibleRoleUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProvisioningServiceAnsibleRolesApi
     */
    public ansibleRolesUpdate(uuid: string, ansibleRoleUpdate?: AnsibleRoleUpdate, options?: RawAxiosRequestConfig) {
        return ProvisioningServiceAnsibleRolesApiFp(this.configuration).ansibleRolesUpdate(uuid, ansibleRoleUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const AnsibleRolesListPartEnum = {
    A: 'a',
    O: 'o',
    H: 'h',
    Star: '*',
    Minus: '-'
} as const;
export type AnsibleRolesListPartEnum = typeof AnsibleRolesListPartEnum[keyof typeof AnsibleRolesListPartEnum];
/**
 * @export
 */
export const AnsibleRolesListSortByEnum = {
    Author: 'author',
    Description: 'description',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Name: 'name',
    Size: 'size',
    CpeLang: 'cpe.lang',
    CpeOther: 'cpe.other',
    CpePart: 'cpe.part',
    CpeProduct: 'cpe.product',
    CpeSoftwareEdition: 'cpe.softwareEdition',
    CpeTargetHardware: 'cpe.targetHardware',
    CpeTargetSoftware: 'cpe.targetSoftware',
    CpeUpdate: 'cpe.update',
    CpeVendor: 'cpe.vendor',
    CpeVersion: 'cpe.version'
} as const;
export type AnsibleRolesListSortByEnum = typeof AnsibleRolesListSortByEnum[keyof typeof AnsibleRolesListSortByEnum];
/**
 * @export
 */
export const AnsibleRolesListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type AnsibleRolesListSortEnum = typeof AnsibleRolesListSortEnum[keyof typeof AnsibleRolesListSortEnum];


/**
 * RangeContentAutoGradersApi - axios parameter creator
 * @export
 */
export const RangeContentAutoGradersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates an Auto Grader
         * @param {AutoGraderCreate} [autoGraderCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoGradersCreate: async (autoGraderCreate?: AutoGraderCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/auto-graders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(autoGraderCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes an Auto Grader
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoGradersDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('autoGradersDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/range/auto-graders/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint can be used to test out sample data against the Auto Grader script. It will return the result of calling the grade function with the given data.
         * @summary Evaluates the given data using the Auto Grader script
         * @param {string} uuid 
         * @param {AutoGradersEvaluateRequest} [autoGradersEvaluateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoGradersEvaluate: async (uuid: string, autoGradersEvaluateRequest?: AutoGradersEvaluateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('autoGradersEvaluate', 'uuid', uuid)
            const localVarPath = `/v1/content/range/auto-graders/{uuid}/evaluate`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(autoGradersEvaluateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of Auto Graders
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [telemetryAgent] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {AutoGradersListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {AutoGradersListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoGradersList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, telemetryAgent?: string, offset?: number, limit?: number, search?: string, sortBy?: AutoGradersListSortByEnum, sort?: AutoGradersListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/auto-graders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (telemetryAgent !== undefined) {
                localVarQueryParameter['telemetryAgent'] = telemetryAgent;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves an Auto Grader
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoGradersRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('autoGradersRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/range/auto-graders/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an Auto Grader
         * @param {string} uuid 
         * @param {AutoGraderUpdate} [autoGraderUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoGradersUpdate: async (uuid: string, autoGraderUpdate?: AutoGraderUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('autoGradersUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/range/auto-graders/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(autoGraderUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RangeContentAutoGradersApi - functional programming interface
 * @export
 */
export const RangeContentAutoGradersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RangeContentAutoGradersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Creates an Auto Grader
         * @param {AutoGraderCreate} [autoGraderCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoGradersCreate(autoGraderCreate?: AutoGraderCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoGrader>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoGradersCreate(autoGraderCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentAutoGradersApi.autoGradersCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Deletes an Auto Grader
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoGradersDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoGradersDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentAutoGradersApi.autoGradersDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint can be used to test out sample data against the Auto Grader script. It will return the result of calling the grade function with the given data.
         * @summary Evaluates the given data using the Auto Grader script
         * @param {string} uuid 
         * @param {AutoGradersEvaluateRequest} [autoGradersEvaluateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoGradersEvaluate(uuid: string, autoGradersEvaluateRequest?: AutoGradersEvaluateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AutoGraderResult>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoGradersEvaluate(uuid, autoGradersEvaluateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentAutoGradersApi.autoGradersEvaluate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Returns a list of Auto Graders
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [telemetryAgent] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {AutoGradersListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {AutoGradersListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoGradersList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, telemetryAgent?: string, offset?: number, limit?: number, search?: string, sortBy?: AutoGradersListSortByEnum, sort?: AutoGradersListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoGradersList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoGradersList(uuid, name, description, author, metadata, telemetryAgent, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentAutoGradersApi.autoGradersList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves an Auto Grader
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoGradersRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoGrader>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoGradersRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentAutoGradersApi.autoGradersRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates an Auto Grader
         * @param {string} uuid 
         * @param {AutoGraderUpdate} [autoGraderUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoGradersUpdate(uuid: string, autoGraderUpdate?: AutoGraderUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoGrader>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoGradersUpdate(uuid, autoGraderUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentAutoGradersApi.autoGradersUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RangeContentAutoGradersApi - factory interface
 * @export
 */
export const RangeContentAutoGradersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RangeContentAutoGradersApiFp(configuration)
    return {
        /**
         * 
         * @summary Creates an Auto Grader
         * @param {AutoGraderCreate} [autoGraderCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoGradersCreate(autoGraderCreate?: AutoGraderCreate, options?: RawAxiosRequestConfig): AxiosPromise<AutoGrader> {
            return localVarFp.autoGradersCreate(autoGraderCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes an Auto Grader
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoGradersDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.autoGradersDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint can be used to test out sample data against the Auto Grader script. It will return the result of calling the grade function with the given data.
         * @summary Evaluates the given data using the Auto Grader script
         * @param {string} uuid 
         * @param {AutoGradersEvaluateRequest} [autoGradersEvaluateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoGradersEvaluate(uuid: string, autoGradersEvaluateRequest?: AutoGradersEvaluateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<AutoGraderResult>> {
            return localVarFp.autoGradersEvaluate(uuid, autoGradersEvaluateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a list of Auto Graders
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [telemetryAgent] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {AutoGradersListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {AutoGradersListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoGradersList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, telemetryAgent?: string, offset?: number, limit?: number, search?: string, sortBy?: AutoGradersListSortByEnum, sort?: AutoGradersListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<AutoGradersList200Response> {
            return localVarFp.autoGradersList(uuid, name, description, author, metadata, telemetryAgent, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves an Auto Grader
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoGradersRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<AutoGrader> {
            return localVarFp.autoGradersRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates an Auto Grader
         * @param {string} uuid 
         * @param {AutoGraderUpdate} [autoGraderUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoGradersUpdate(uuid: string, autoGraderUpdate?: AutoGraderUpdate, options?: RawAxiosRequestConfig): AxiosPromise<AutoGrader> {
            return localVarFp.autoGradersUpdate(uuid, autoGraderUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RangeContentAutoGradersApi - object-oriented interface
 * @export
 * @class RangeContentAutoGradersApi
 * @extends {BaseAPI}
 */
export class RangeContentAutoGradersApi extends BaseAPI {
    /**
     * 
     * @summary Creates an Auto Grader
     * @param {AutoGraderCreate} [autoGraderCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentAutoGradersApi
     */
    public autoGradersCreate(autoGraderCreate?: AutoGraderCreate, options?: RawAxiosRequestConfig) {
        return RangeContentAutoGradersApiFp(this.configuration).autoGradersCreate(autoGraderCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes an Auto Grader
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentAutoGradersApi
     */
    public autoGradersDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentAutoGradersApiFp(this.configuration).autoGradersDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint can be used to test out sample data against the Auto Grader script. It will return the result of calling the grade function with the given data.
     * @summary Evaluates the given data using the Auto Grader script
     * @param {string} uuid 
     * @param {AutoGradersEvaluateRequest} [autoGradersEvaluateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentAutoGradersApi
     */
    public autoGradersEvaluate(uuid: string, autoGradersEvaluateRequest?: AutoGradersEvaluateRequest, options?: RawAxiosRequestConfig) {
        return RangeContentAutoGradersApiFp(this.configuration).autoGradersEvaluate(uuid, autoGradersEvaluateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a list of Auto Graders
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {string} [telemetryAgent] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {AutoGradersListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {AutoGradersListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentAutoGradersApi
     */
    public autoGradersList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, telemetryAgent?: string, offset?: number, limit?: number, search?: string, sortBy?: AutoGradersListSortByEnum, sort?: AutoGradersListSortEnum, options?: RawAxiosRequestConfig) {
        return RangeContentAutoGradersApiFp(this.configuration).autoGradersList(uuid, name, description, author, metadata, telemetryAgent, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves an Auto Grader
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentAutoGradersApi
     */
    public autoGradersRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentAutoGradersApiFp(this.configuration).autoGradersRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates an Auto Grader
     * @param {string} uuid 
     * @param {AutoGraderUpdate} [autoGraderUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentAutoGradersApi
     */
    public autoGradersUpdate(uuid: string, autoGraderUpdate?: AutoGraderUpdate, options?: RawAxiosRequestConfig) {
        return RangeContentAutoGradersApiFp(this.configuration).autoGradersUpdate(uuid, autoGraderUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const AutoGradersListSortByEnum = {
    Author: 'author',
    Description: 'description',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Name: 'name'
} as const;
export type AutoGradersListSortByEnum = typeof AutoGradersListSortByEnum[keyof typeof AutoGradersListSortByEnum];
/**
 * @export
 */
export const AutoGradersListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type AutoGradersListSortEnum = typeof AutoGradersListSortEnum[keyof typeof AutoGradersListSortEnum];


/**
 * RangeContentClusterRangeNetworksApi - axios parameter creator
 * @export
 */
export const RangeContentClusterRangeNetworksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a cluster range network
         * @param {ClusterRangeNetworkCreate} [clusterRangeNetworkCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterRangeNetworksCreate: async (clusterRangeNetworkCreate?: ClusterRangeNetworkCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/cluster-range-networks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clusterRangeNetworkCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a cluster range network
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterRangeNetworksDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('clusterRangeNetworksDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/range/cluster-range-networks/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List cluster range networks
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {ClusterRangeNetworksListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {ClusterRangeNetworksListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterRangeNetworksList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: ClusterRangeNetworksListSortByEnum, sort?: ClusterRangeNetworksListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/cluster-range-networks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a cluster range network
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterRangeNetworksRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('clusterRangeNetworksRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/range/cluster-range-networks/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a cluster range network
         * @param {string} uuid 
         * @param {ClusterRangeNetworkUpdate} [clusterRangeNetworkUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterRangeNetworksUpdate: async (uuid: string, clusterRangeNetworkUpdate?: ClusterRangeNetworkUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('clusterRangeNetworksUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/range/cluster-range-networks/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clusterRangeNetworkUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RangeContentClusterRangeNetworksApi - functional programming interface
 * @export
 */
export const RangeContentClusterRangeNetworksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RangeContentClusterRangeNetworksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a cluster range network
         * @param {ClusterRangeNetworkCreate} [clusterRangeNetworkCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clusterRangeNetworksCreate(clusterRangeNetworkCreate?: ClusterRangeNetworkCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterRangeNetwork>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clusterRangeNetworksCreate(clusterRangeNetworkCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentClusterRangeNetworksApi.clusterRangeNetworksCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a cluster range network
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clusterRangeNetworksDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clusterRangeNetworksDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentClusterRangeNetworksApi.clusterRangeNetworksDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List cluster range networks
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {ClusterRangeNetworksListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {ClusterRangeNetworksListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clusterRangeNetworksList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: ClusterRangeNetworksListSortByEnum, sort?: ClusterRangeNetworksListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterRangeNetworksList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clusterRangeNetworksList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentClusterRangeNetworksApi.clusterRangeNetworksList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a cluster range network
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clusterRangeNetworksRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterRangeNetwork>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clusterRangeNetworksRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentClusterRangeNetworksApi.clusterRangeNetworksRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a cluster range network
         * @param {string} uuid 
         * @param {ClusterRangeNetworkUpdate} [clusterRangeNetworkUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clusterRangeNetworksUpdate(uuid: string, clusterRangeNetworkUpdate?: ClusterRangeNetworkUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterRangeNetwork>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clusterRangeNetworksUpdate(uuid, clusterRangeNetworkUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentClusterRangeNetworksApi.clusterRangeNetworksUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RangeContentClusterRangeNetworksApi - factory interface
 * @export
 */
export const RangeContentClusterRangeNetworksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RangeContentClusterRangeNetworksApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a cluster range network
         * @param {ClusterRangeNetworkCreate} [clusterRangeNetworkCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterRangeNetworksCreate(clusterRangeNetworkCreate?: ClusterRangeNetworkCreate, options?: RawAxiosRequestConfig): AxiosPromise<ClusterRangeNetwork> {
            return localVarFp.clusterRangeNetworksCreate(clusterRangeNetworkCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a cluster range network
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterRangeNetworksDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.clusterRangeNetworksDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List cluster range networks
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {ClusterRangeNetworksListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {ClusterRangeNetworksListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterRangeNetworksList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: ClusterRangeNetworksListSortByEnum, sort?: ClusterRangeNetworksListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<ClusterRangeNetworksList200Response> {
            return localVarFp.clusterRangeNetworksList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a cluster range network
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterRangeNetworksRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<ClusterRangeNetwork> {
            return localVarFp.clusterRangeNetworksRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a cluster range network
         * @param {string} uuid 
         * @param {ClusterRangeNetworkUpdate} [clusterRangeNetworkUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterRangeNetworksUpdate(uuid: string, clusterRangeNetworkUpdate?: ClusterRangeNetworkUpdate, options?: RawAxiosRequestConfig): AxiosPromise<ClusterRangeNetwork> {
            return localVarFp.clusterRangeNetworksUpdate(uuid, clusterRangeNetworkUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RangeContentClusterRangeNetworksApi - object-oriented interface
 * @export
 * @class RangeContentClusterRangeNetworksApi
 * @extends {BaseAPI}
 */
export class RangeContentClusterRangeNetworksApi extends BaseAPI {
    /**
     * 
     * @summary Create a cluster range network
     * @param {ClusterRangeNetworkCreate} [clusterRangeNetworkCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentClusterRangeNetworksApi
     */
    public clusterRangeNetworksCreate(clusterRangeNetworkCreate?: ClusterRangeNetworkCreate, options?: RawAxiosRequestConfig) {
        return RangeContentClusterRangeNetworksApiFp(this.configuration).clusterRangeNetworksCreate(clusterRangeNetworkCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a cluster range network
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentClusterRangeNetworksApi
     */
    public clusterRangeNetworksDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentClusterRangeNetworksApiFp(this.configuration).clusterRangeNetworksDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List cluster range networks
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {ClusterRangeNetworksListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {ClusterRangeNetworksListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentClusterRangeNetworksApi
     */
    public clusterRangeNetworksList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: ClusterRangeNetworksListSortByEnum, sort?: ClusterRangeNetworksListSortEnum, options?: RawAxiosRequestConfig) {
        return RangeContentClusterRangeNetworksApiFp(this.configuration).clusterRangeNetworksList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a cluster range network
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentClusterRangeNetworksApi
     */
    public clusterRangeNetworksRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentClusterRangeNetworksApiFp(this.configuration).clusterRangeNetworksRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a cluster range network
     * @param {string} uuid 
     * @param {ClusterRangeNetworkUpdate} [clusterRangeNetworkUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentClusterRangeNetworksApi
     */
    public clusterRangeNetworksUpdate(uuid: string, clusterRangeNetworkUpdate?: ClusterRangeNetworkUpdate, options?: RawAxiosRequestConfig) {
        return RangeContentClusterRangeNetworksApiFp(this.configuration).clusterRangeNetworksUpdate(uuid, clusterRangeNetworkUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ClusterRangeNetworksListSortByEnum = {
    Author: 'author',
    Description: 'description',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Name: 'name'
} as const;
export type ClusterRangeNetworksListSortByEnum = typeof ClusterRangeNetworksListSortByEnum[keyof typeof ClusterRangeNetworksListSortByEnum];
/**
 * @export
 */
export const ClusterRangeNetworksListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ClusterRangeNetworksListSortEnum = typeof ClusterRangeNetworksListSortEnum[keyof typeof ClusterRangeNetworksListSortEnum];


/**
 * RangeContentContainerSpecificationsApi - axios parameter creator
 * @export
 */
export const RangeContentContainerSpecificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a container specification
         * @param {ContainerSpecificationCreate} [containerSpecificationCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerSpecificationsCreate: async (containerSpecificationCreate?: ContainerSpecificationCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/container-specifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(containerSpecificationCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a container specification
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerSpecificationsDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('containerSpecificationsDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/range/container-specifications/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of existing container specifications
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {ContainerSpecificationsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {ContainerSpecificationsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerSpecificationsList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: ContainerSpecificationsListSortByEnum, sort?: ContainerSpecificationsListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/container-specifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a container specification
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerSpecificationsRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('containerSpecificationsRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/range/container-specifications/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a container specification
         * @param {string} uuid 
         * @param {ContainerSpecificationUpdate} [containerSpecificationUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerSpecificationsUpdate: async (uuid: string, containerSpecificationUpdate?: ContainerSpecificationUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('containerSpecificationsUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/range/container-specifications/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(containerSpecificationUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RangeContentContainerSpecificationsApi - functional programming interface
 * @export
 */
export const RangeContentContainerSpecificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RangeContentContainerSpecificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a container specification
         * @param {ContainerSpecificationCreate} [containerSpecificationCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerSpecificationsCreate(containerSpecificationCreate?: ContainerSpecificationCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerSpecification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containerSpecificationsCreate(containerSpecificationCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentContainerSpecificationsApi.containerSpecificationsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a container specification
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerSpecificationsDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containerSpecificationsDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentContainerSpecificationsApi.containerSpecificationsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List of existing container specifications
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {ContainerSpecificationsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {ContainerSpecificationsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerSpecificationsList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: ContainerSpecificationsListSortByEnum, sort?: ContainerSpecificationsListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerSpecificationsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containerSpecificationsList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentContainerSpecificationsApi.containerSpecificationsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a container specification
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerSpecificationsRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerSpecification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containerSpecificationsRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentContainerSpecificationsApi.containerSpecificationsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a container specification
         * @param {string} uuid 
         * @param {ContainerSpecificationUpdate} [containerSpecificationUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerSpecificationsUpdate(uuid: string, containerSpecificationUpdate?: ContainerSpecificationUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerSpecification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containerSpecificationsUpdate(uuid, containerSpecificationUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentContainerSpecificationsApi.containerSpecificationsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RangeContentContainerSpecificationsApi - factory interface
 * @export
 */
export const RangeContentContainerSpecificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RangeContentContainerSpecificationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a container specification
         * @param {ContainerSpecificationCreate} [containerSpecificationCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerSpecificationsCreate(containerSpecificationCreate?: ContainerSpecificationCreate, options?: RawAxiosRequestConfig): AxiosPromise<ContainerSpecification> {
            return localVarFp.containerSpecificationsCreate(containerSpecificationCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a container specification
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerSpecificationsDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.containerSpecificationsDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List of existing container specifications
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {ContainerSpecificationsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {ContainerSpecificationsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerSpecificationsList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: ContainerSpecificationsListSortByEnum, sort?: ContainerSpecificationsListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<ContainerSpecificationsList200Response> {
            return localVarFp.containerSpecificationsList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a container specification
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerSpecificationsRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<ContainerSpecification> {
            return localVarFp.containerSpecificationsRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a container specification
         * @param {string} uuid 
         * @param {ContainerSpecificationUpdate} [containerSpecificationUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerSpecificationsUpdate(uuid: string, containerSpecificationUpdate?: ContainerSpecificationUpdate, options?: RawAxiosRequestConfig): AxiosPromise<ContainerSpecification> {
            return localVarFp.containerSpecificationsUpdate(uuid, containerSpecificationUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RangeContentContainerSpecificationsApi - object-oriented interface
 * @export
 * @class RangeContentContainerSpecificationsApi
 * @extends {BaseAPI}
 */
export class RangeContentContainerSpecificationsApi extends BaseAPI {
    /**
     * 
     * @summary Create a container specification
     * @param {ContainerSpecificationCreate} [containerSpecificationCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentContainerSpecificationsApi
     */
    public containerSpecificationsCreate(containerSpecificationCreate?: ContainerSpecificationCreate, options?: RawAxiosRequestConfig) {
        return RangeContentContainerSpecificationsApiFp(this.configuration).containerSpecificationsCreate(containerSpecificationCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a container specification
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentContainerSpecificationsApi
     */
    public containerSpecificationsDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentContainerSpecificationsApiFp(this.configuration).containerSpecificationsDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List of existing container specifications
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {ContainerSpecificationsListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {ContainerSpecificationsListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentContainerSpecificationsApi
     */
    public containerSpecificationsList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: ContainerSpecificationsListSortByEnum, sort?: ContainerSpecificationsListSortEnum, options?: RawAxiosRequestConfig) {
        return RangeContentContainerSpecificationsApiFp(this.configuration).containerSpecificationsList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a container specification
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentContainerSpecificationsApi
     */
    public containerSpecificationsRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentContainerSpecificationsApiFp(this.configuration).containerSpecificationsRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a container specification
     * @param {string} uuid 
     * @param {ContainerSpecificationUpdate} [containerSpecificationUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentContainerSpecificationsApi
     */
    public containerSpecificationsUpdate(uuid: string, containerSpecificationUpdate?: ContainerSpecificationUpdate, options?: RawAxiosRequestConfig) {
        return RangeContentContainerSpecificationsApiFp(this.configuration).containerSpecificationsUpdate(uuid, containerSpecificationUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ContainerSpecificationsListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author'
} as const;
export type ContainerSpecificationsListSortByEnum = typeof ContainerSpecificationsListSortByEnum[keyof typeof ContainerSpecificationsListSortByEnum];
/**
 * @export
 */
export const ContainerSpecificationsListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ContainerSpecificationsListSortEnum = typeof ContainerSpecificationsListSortEnum[keyof typeof ContainerSpecificationsListSortEnum];


/**
 * RangeContentEventTreesApi - axios parameter creator
 * @export
 */
export const RangeContentEventTreesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an event tree
         * @param {EventTreeCreate} [eventTreeCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventTreesCreate: async (eventTreeCreate?: EventTreeCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/event-trees`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventTreeCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an event tree
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventTreesDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('eventTreesDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/range/event-trees/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of event trees
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {EventTreesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {EventTreesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventTreesList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: EventTreesListSortByEnum, sort?: EventTreesListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/event-trees`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves an event tree
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventTreesRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('eventTreesRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/range/event-trees/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an event tree
         * @param {string} uuid 
         * @param {EventTreeUpdate} [eventTreeUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventTreesUpdate: async (uuid: string, eventTreeUpdate?: EventTreeUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('eventTreesUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/range/event-trees/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventTreeUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RangeContentEventTreesApi - functional programming interface
 * @export
 */
export const RangeContentEventTreesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RangeContentEventTreesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create an event tree
         * @param {EventTreeCreate} [eventTreeCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventTreesCreate(eventTreeCreate?: EventTreeCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventTree>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventTreesCreate(eventTreeCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentEventTreesApi.eventTreesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an event tree
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventTreesDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventTreesDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentEventTreesApi.eventTreesDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List of event trees
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {EventTreesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {EventTreesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventTreesList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: EventTreesListSortByEnum, sort?: EventTreesListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventTreesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventTreesList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentEventTreesApi.eventTreesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves an event tree
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventTreesRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventTree>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventTreesRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentEventTreesApi.eventTreesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an event tree
         * @param {string} uuid 
         * @param {EventTreeUpdate} [eventTreeUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventTreesUpdate(uuid: string, eventTreeUpdate?: EventTreeUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventTree>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventTreesUpdate(uuid, eventTreeUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentEventTreesApi.eventTreesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RangeContentEventTreesApi - factory interface
 * @export
 */
export const RangeContentEventTreesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RangeContentEventTreesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create an event tree
         * @param {EventTreeCreate} [eventTreeCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventTreesCreate(eventTreeCreate?: EventTreeCreate, options?: RawAxiosRequestConfig): AxiosPromise<EventTree> {
            return localVarFp.eventTreesCreate(eventTreeCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an event tree
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventTreesDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.eventTreesDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List of event trees
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {EventTreesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {EventTreesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventTreesList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: EventTreesListSortByEnum, sort?: EventTreesListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<EventTreesList200Response> {
            return localVarFp.eventTreesList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves an event tree
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventTreesRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<EventTree> {
            return localVarFp.eventTreesRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an event tree
         * @param {string} uuid 
         * @param {EventTreeUpdate} [eventTreeUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventTreesUpdate(uuid: string, eventTreeUpdate?: EventTreeUpdate, options?: RawAxiosRequestConfig): AxiosPromise<EventTree> {
            return localVarFp.eventTreesUpdate(uuid, eventTreeUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RangeContentEventTreesApi - object-oriented interface
 * @export
 * @class RangeContentEventTreesApi
 * @extends {BaseAPI}
 */
export class RangeContentEventTreesApi extends BaseAPI {
    /**
     * 
     * @summary Create an event tree
     * @param {EventTreeCreate} [eventTreeCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentEventTreesApi
     */
    public eventTreesCreate(eventTreeCreate?: EventTreeCreate, options?: RawAxiosRequestConfig) {
        return RangeContentEventTreesApiFp(this.configuration).eventTreesCreate(eventTreeCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an event tree
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentEventTreesApi
     */
    public eventTreesDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentEventTreesApiFp(this.configuration).eventTreesDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List of event trees
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {EventTreesListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {EventTreesListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentEventTreesApi
     */
    public eventTreesList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: EventTreesListSortByEnum, sort?: EventTreesListSortEnum, options?: RawAxiosRequestConfig) {
        return RangeContentEventTreesApiFp(this.configuration).eventTreesList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves an event tree
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentEventTreesApi
     */
    public eventTreesRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentEventTreesApiFp(this.configuration).eventTreesRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an event tree
     * @param {string} uuid 
     * @param {EventTreeUpdate} [eventTreeUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentEventTreesApi
     */
    public eventTreesUpdate(uuid: string, eventTreeUpdate?: EventTreeUpdate, options?: RawAxiosRequestConfig) {
        return RangeContentEventTreesApiFp(this.configuration).eventTreesUpdate(uuid, eventTreeUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const EventTreesListSortByEnum = {
    Author: 'author',
    Description: 'description',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Name: 'name'
} as const;
export type EventTreesListSortByEnum = typeof EventTreesListSortByEnum[keyof typeof EventTreesListSortByEnum];
/**
 * @export
 */
export const EventTreesListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type EventTreesListSortEnum = typeof EventTreesListSortEnum[keyof typeof EventTreesListSortEnum];


/**
 * RangeContentGhostAgentsApi - axios parameter creator
 * @export
 */
export const RangeContentGhostAgentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a ghost agent
         * @param {GhostAgentCreate} [ghostAgentCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostAgentsCreate: async (ghostAgentCreate?: GhostAgentCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/ghost-agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ghostAgentCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a ghost agent
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostAgentsDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('ghostAgentsDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/range/ghost-agents/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of ghost agents
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {GhostAgentsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {GhostAgentsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostAgentsList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: GhostAgentsListSortByEnum, sort?: GhostAgentsListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/ghost-agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a ghost agent
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostAgentsRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('ghostAgentsRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/range/ghost-agents/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a ghost agent
         * @param {string} uuid 
         * @param {GhostAgentUpdate} [ghostAgentUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostAgentsUpdate: async (uuid: string, ghostAgentUpdate?: GhostAgentUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('ghostAgentsUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/range/ghost-agents/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ghostAgentUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RangeContentGhostAgentsApi - functional programming interface
 * @export
 */
export const RangeContentGhostAgentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RangeContentGhostAgentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a ghost agent
         * @param {GhostAgentCreate} [ghostAgentCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ghostAgentsCreate(ghostAgentCreate?: GhostAgentCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GhostAgent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ghostAgentsCreate(ghostAgentCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentGhostAgentsApi.ghostAgentsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Deletes a ghost agent
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ghostAgentsDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ghostAgentsDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentGhostAgentsApi.ghostAgentsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List of ghost agents
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {GhostAgentsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {GhostAgentsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ghostAgentsList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: GhostAgentsListSortByEnum, sort?: GhostAgentsListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GhostAgentsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ghostAgentsList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentGhostAgentsApi.ghostAgentsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves a ghost agent
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ghostAgentsRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GhostAgent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ghostAgentsRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentGhostAgentsApi.ghostAgentsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates a ghost agent
         * @param {string} uuid 
         * @param {GhostAgentUpdate} [ghostAgentUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ghostAgentsUpdate(uuid: string, ghostAgentUpdate?: GhostAgentUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GhostAgent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ghostAgentsUpdate(uuid, ghostAgentUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentGhostAgentsApi.ghostAgentsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RangeContentGhostAgentsApi - factory interface
 * @export
 */
export const RangeContentGhostAgentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RangeContentGhostAgentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a ghost agent
         * @param {GhostAgentCreate} [ghostAgentCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostAgentsCreate(ghostAgentCreate?: GhostAgentCreate, options?: RawAxiosRequestConfig): AxiosPromise<GhostAgent> {
            return localVarFp.ghostAgentsCreate(ghostAgentCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a ghost agent
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostAgentsDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.ghostAgentsDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List of ghost agents
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {GhostAgentsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {GhostAgentsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostAgentsList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: GhostAgentsListSortByEnum, sort?: GhostAgentsListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<GhostAgentsList200Response> {
            return localVarFp.ghostAgentsList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves a ghost agent
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostAgentsRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<GhostAgent> {
            return localVarFp.ghostAgentsRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a ghost agent
         * @param {string} uuid 
         * @param {GhostAgentUpdate} [ghostAgentUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostAgentsUpdate(uuid: string, ghostAgentUpdate?: GhostAgentUpdate, options?: RawAxiosRequestConfig): AxiosPromise<GhostAgent> {
            return localVarFp.ghostAgentsUpdate(uuid, ghostAgentUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RangeContentGhostAgentsApi - object-oriented interface
 * @export
 * @class RangeContentGhostAgentsApi
 * @extends {BaseAPI}
 */
export class RangeContentGhostAgentsApi extends BaseAPI {
    /**
     * 
     * @summary Create a ghost agent
     * @param {GhostAgentCreate} [ghostAgentCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentGhostAgentsApi
     */
    public ghostAgentsCreate(ghostAgentCreate?: GhostAgentCreate, options?: RawAxiosRequestConfig) {
        return RangeContentGhostAgentsApiFp(this.configuration).ghostAgentsCreate(ghostAgentCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a ghost agent
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentGhostAgentsApi
     */
    public ghostAgentsDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentGhostAgentsApiFp(this.configuration).ghostAgentsDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List of ghost agents
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {GhostAgentsListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {GhostAgentsListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentGhostAgentsApi
     */
    public ghostAgentsList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: GhostAgentsListSortByEnum, sort?: GhostAgentsListSortEnum, options?: RawAxiosRequestConfig) {
        return RangeContentGhostAgentsApiFp(this.configuration).ghostAgentsList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves a ghost agent
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentGhostAgentsApi
     */
    public ghostAgentsRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentGhostAgentsApiFp(this.configuration).ghostAgentsRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a ghost agent
     * @param {string} uuid 
     * @param {GhostAgentUpdate} [ghostAgentUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentGhostAgentsApi
     */
    public ghostAgentsUpdate(uuid: string, ghostAgentUpdate?: GhostAgentUpdate, options?: RawAxiosRequestConfig) {
        return RangeContentGhostAgentsApiFp(this.configuration).ghostAgentsUpdate(uuid, ghostAgentUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GhostAgentsListSortByEnum = {
    Author: 'author',
    Description: 'description',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Name: 'name'
} as const;
export type GhostAgentsListSortByEnum = typeof GhostAgentsListSortByEnum[keyof typeof GhostAgentsListSortByEnum];
/**
 * @export
 */
export const GhostAgentsListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GhostAgentsListSortEnum = typeof GhostAgentsListSortEnum[keyof typeof GhostAgentsListSortEnum];


/**
 * RangeContentGhostC2ServersApi - axios parameter creator
 * @export
 */
export const RangeContentGhostC2ServersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a ghost C2 server
         * @param {GhostC2ServerCreate} [ghostC2ServerCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostC2ServersCreate: async (ghostC2ServerCreate?: GhostC2ServerCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/ghost-c2-servers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ghostC2ServerCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a ghost C2 server
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostC2ServersDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('ghostC2ServersDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/range/ghost-c2-servers/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of ghost C2 servers
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {GhostC2ServersListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {GhostC2ServersListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostC2ServersList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: GhostC2ServersListSortByEnum, sort?: GhostC2ServersListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/ghost-c2-servers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a ghost C2 server
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostC2ServersRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('ghostC2ServersRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/range/ghost-c2-servers/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a ghost C2 server
         * @param {string} uuid 
         * @param {GhostC2ServerUpdate} [ghostC2ServerUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostC2ServersUpdate: async (uuid: string, ghostC2ServerUpdate?: GhostC2ServerUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('ghostC2ServersUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/range/ghost-c2-servers/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ghostC2ServerUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RangeContentGhostC2ServersApi - functional programming interface
 * @export
 */
export const RangeContentGhostC2ServersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RangeContentGhostC2ServersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a ghost C2 server
         * @param {GhostC2ServerCreate} [ghostC2ServerCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ghostC2ServersCreate(ghostC2ServerCreate?: GhostC2ServerCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GhostC2Server>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ghostC2ServersCreate(ghostC2ServerCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentGhostC2ServersApi.ghostC2ServersCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Deletes a ghost C2 server
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ghostC2ServersDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ghostC2ServersDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentGhostC2ServersApi.ghostC2ServersDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List of ghost C2 servers
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {GhostC2ServersListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {GhostC2ServersListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ghostC2ServersList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: GhostC2ServersListSortByEnum, sort?: GhostC2ServersListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GhostC2ServersList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ghostC2ServersList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentGhostC2ServersApi.ghostC2ServersList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves a ghost C2 server
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ghostC2ServersRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GhostC2Server>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ghostC2ServersRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentGhostC2ServersApi.ghostC2ServersRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates a ghost C2 server
         * @param {string} uuid 
         * @param {GhostC2ServerUpdate} [ghostC2ServerUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ghostC2ServersUpdate(uuid: string, ghostC2ServerUpdate?: GhostC2ServerUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GhostC2Server>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ghostC2ServersUpdate(uuid, ghostC2ServerUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentGhostC2ServersApi.ghostC2ServersUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RangeContentGhostC2ServersApi - factory interface
 * @export
 */
export const RangeContentGhostC2ServersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RangeContentGhostC2ServersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a ghost C2 server
         * @param {GhostC2ServerCreate} [ghostC2ServerCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostC2ServersCreate(ghostC2ServerCreate?: GhostC2ServerCreate, options?: RawAxiosRequestConfig): AxiosPromise<GhostC2Server> {
            return localVarFp.ghostC2ServersCreate(ghostC2ServerCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a ghost C2 server
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostC2ServersDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.ghostC2ServersDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List of ghost C2 servers
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {GhostC2ServersListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {GhostC2ServersListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostC2ServersList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: GhostC2ServersListSortByEnum, sort?: GhostC2ServersListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<GhostC2ServersList200Response> {
            return localVarFp.ghostC2ServersList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves a ghost C2 server
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostC2ServersRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<GhostC2Server> {
            return localVarFp.ghostC2ServersRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a ghost C2 server
         * @param {string} uuid 
         * @param {GhostC2ServerUpdate} [ghostC2ServerUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostC2ServersUpdate(uuid: string, ghostC2ServerUpdate?: GhostC2ServerUpdate, options?: RawAxiosRequestConfig): AxiosPromise<GhostC2Server> {
            return localVarFp.ghostC2ServersUpdate(uuid, ghostC2ServerUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RangeContentGhostC2ServersApi - object-oriented interface
 * @export
 * @class RangeContentGhostC2ServersApi
 * @extends {BaseAPI}
 */
export class RangeContentGhostC2ServersApi extends BaseAPI {
    /**
     * 
     * @summary Create a ghost C2 server
     * @param {GhostC2ServerCreate} [ghostC2ServerCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentGhostC2ServersApi
     */
    public ghostC2ServersCreate(ghostC2ServerCreate?: GhostC2ServerCreate, options?: RawAxiosRequestConfig) {
        return RangeContentGhostC2ServersApiFp(this.configuration).ghostC2ServersCreate(ghostC2ServerCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a ghost C2 server
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentGhostC2ServersApi
     */
    public ghostC2ServersDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentGhostC2ServersApiFp(this.configuration).ghostC2ServersDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List of ghost C2 servers
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {GhostC2ServersListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {GhostC2ServersListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentGhostC2ServersApi
     */
    public ghostC2ServersList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: GhostC2ServersListSortByEnum, sort?: GhostC2ServersListSortEnum, options?: RawAxiosRequestConfig) {
        return RangeContentGhostC2ServersApiFp(this.configuration).ghostC2ServersList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves a ghost C2 server
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentGhostC2ServersApi
     */
    public ghostC2ServersRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentGhostC2ServersApiFp(this.configuration).ghostC2ServersRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a ghost C2 server
     * @param {string} uuid 
     * @param {GhostC2ServerUpdate} [ghostC2ServerUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentGhostC2ServersApi
     */
    public ghostC2ServersUpdate(uuid: string, ghostC2ServerUpdate?: GhostC2ServerUpdate, options?: RawAxiosRequestConfig) {
        return RangeContentGhostC2ServersApiFp(this.configuration).ghostC2ServersUpdate(uuid, ghostC2ServerUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GhostC2ServersListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author'
} as const;
export type GhostC2ServersListSortByEnum = typeof GhostC2ServersListSortByEnum[keyof typeof GhostC2ServersListSortByEnum];
/**
 * @export
 */
export const GhostC2ServersListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GhostC2ServersListSortEnum = typeof GhostC2ServersListSortEnum[keyof typeof GhostC2ServersListSortEnum];


/**
 * RangeContentGhostClientsApi - axios parameter creator
 * @export
 */
export const RangeContentGhostClientsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a ghost client
         * @param {GhostClientCreate} [ghostClientCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostClientsCreate: async (ghostClientCreate?: GhostClientCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/ghost-clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ghostClientCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a ghost client
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostClientsDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('ghostClientsDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/range/ghost-clients/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of ghost clients
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {GhostClientsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {GhostClientsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostClientsList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: GhostClientsListSortByEnum, sort?: GhostClientsListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/ghost-clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a ghost client
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostClientsRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('ghostClientsRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/range/ghost-clients/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a ghost client
         * @param {string} uuid 
         * @param {GhostClientUpdate} [ghostClientUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostClientsUpdate: async (uuid: string, ghostClientUpdate?: GhostClientUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('ghostClientsUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/range/ghost-clients/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ghostClientUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RangeContentGhostClientsApi - functional programming interface
 * @export
 */
export const RangeContentGhostClientsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RangeContentGhostClientsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a ghost client
         * @param {GhostClientCreate} [ghostClientCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ghostClientsCreate(ghostClientCreate?: GhostClientCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GhostClient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ghostClientsCreate(ghostClientCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentGhostClientsApi.ghostClientsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Deletes a ghost client
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ghostClientsDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ghostClientsDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentGhostClientsApi.ghostClientsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List of ghost clients
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {GhostClientsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {GhostClientsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ghostClientsList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: GhostClientsListSortByEnum, sort?: GhostClientsListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GhostClientsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ghostClientsList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentGhostClientsApi.ghostClientsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves a ghost client
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ghostClientsRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GhostClient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ghostClientsRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentGhostClientsApi.ghostClientsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates a ghost client
         * @param {string} uuid 
         * @param {GhostClientUpdate} [ghostClientUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ghostClientsUpdate(uuid: string, ghostClientUpdate?: GhostClientUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GhostClient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ghostClientsUpdate(uuid, ghostClientUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentGhostClientsApi.ghostClientsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RangeContentGhostClientsApi - factory interface
 * @export
 */
export const RangeContentGhostClientsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RangeContentGhostClientsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a ghost client
         * @param {GhostClientCreate} [ghostClientCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostClientsCreate(ghostClientCreate?: GhostClientCreate, options?: RawAxiosRequestConfig): AxiosPromise<GhostClient> {
            return localVarFp.ghostClientsCreate(ghostClientCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a ghost client
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostClientsDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.ghostClientsDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List of ghost clients
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {GhostClientsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {GhostClientsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostClientsList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: GhostClientsListSortByEnum, sort?: GhostClientsListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<GhostClientsList200Response> {
            return localVarFp.ghostClientsList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves a ghost client
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostClientsRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<GhostClient> {
            return localVarFp.ghostClientsRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a ghost client
         * @param {string} uuid 
         * @param {GhostClientUpdate} [ghostClientUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostClientsUpdate(uuid: string, ghostClientUpdate?: GhostClientUpdate, options?: RawAxiosRequestConfig): AxiosPromise<GhostClient> {
            return localVarFp.ghostClientsUpdate(uuid, ghostClientUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RangeContentGhostClientsApi - object-oriented interface
 * @export
 * @class RangeContentGhostClientsApi
 * @extends {BaseAPI}
 */
export class RangeContentGhostClientsApi extends BaseAPI {
    /**
     * 
     * @summary Create a ghost client
     * @param {GhostClientCreate} [ghostClientCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentGhostClientsApi
     */
    public ghostClientsCreate(ghostClientCreate?: GhostClientCreate, options?: RawAxiosRequestConfig) {
        return RangeContentGhostClientsApiFp(this.configuration).ghostClientsCreate(ghostClientCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a ghost client
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentGhostClientsApi
     */
    public ghostClientsDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentGhostClientsApiFp(this.configuration).ghostClientsDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List of ghost clients
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {GhostClientsListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {GhostClientsListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentGhostClientsApi
     */
    public ghostClientsList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: GhostClientsListSortByEnum, sort?: GhostClientsListSortEnum, options?: RawAxiosRequestConfig) {
        return RangeContentGhostClientsApiFp(this.configuration).ghostClientsList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves a ghost client
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentGhostClientsApi
     */
    public ghostClientsRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentGhostClientsApiFp(this.configuration).ghostClientsRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a ghost client
     * @param {string} uuid 
     * @param {GhostClientUpdate} [ghostClientUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentGhostClientsApi
     */
    public ghostClientsUpdate(uuid: string, ghostClientUpdate?: GhostClientUpdate, options?: RawAxiosRequestConfig) {
        return RangeContentGhostClientsApiFp(this.configuration).ghostClientsUpdate(uuid, ghostClientUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GhostClientsListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author'
} as const;
export type GhostClientsListSortByEnum = typeof GhostClientsListSortByEnum[keyof typeof GhostClientsListSortByEnum];
/**
 * @export
 */
export const GhostClientsListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GhostClientsListSortEnum = typeof GhostClientsListSortEnum[keyof typeof GhostClientsListSortEnum];


/**
 * RangeContentGhostTrafficApi - axios parameter creator
 * @export
 */
export const RangeContentGhostTrafficApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a ghost traffic
         * @param {GhostTrafficCreate} [ghostTrafficCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostTrafficCreate: async (ghostTrafficCreate?: GhostTrafficCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/ghost-traffic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ghostTrafficCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a ghost traffic
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostTrafficDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('ghostTrafficDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/range/ghost-traffic/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of ghost traffic
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {GhostTrafficListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {GhostTrafficListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostTrafficList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: GhostTrafficListSortByEnum, sort?: GhostTrafficListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/ghost-traffic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Renders a ghost traffic template
         * @param {string} uuid 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostTrafficRender: async (uuid: string, body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('ghostTrafficRender', 'uuid', uuid)
            const localVarPath = `/v1/content/range/ghost-traffic/{uuid}/render`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a ghost traffic
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostTrafficRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('ghostTrafficRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/range/ghost-traffic/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a ghost traffic
         * @param {string} uuid 
         * @param {GhostTrafficUpdate} [ghostTrafficUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostTrafficUpdate: async (uuid: string, ghostTrafficUpdate?: GhostTrafficUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('ghostTrafficUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/range/ghost-traffic/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ghostTrafficUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RangeContentGhostTrafficApi - functional programming interface
 * @export
 */
export const RangeContentGhostTrafficApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RangeContentGhostTrafficApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a ghost traffic
         * @param {GhostTrafficCreate} [ghostTrafficCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ghostTrafficCreate(ghostTrafficCreate?: GhostTrafficCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GhostTraffic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ghostTrafficCreate(ghostTrafficCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentGhostTrafficApi.ghostTrafficCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Deletes a ghost traffic
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ghostTrafficDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ghostTrafficDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentGhostTrafficApi.ghostTrafficDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List of ghost traffic
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {GhostTrafficListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {GhostTrafficListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ghostTrafficList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: GhostTrafficListSortByEnum, sort?: GhostTrafficListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GhostTrafficList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ghostTrafficList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentGhostTrafficApi.ghostTrafficList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Renders a ghost traffic template
         * @param {string} uuid 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ghostTrafficRender(uuid: string, body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GhostTraffic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ghostTrafficRender(uuid, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentGhostTrafficApi.ghostTrafficRender']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves a ghost traffic
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ghostTrafficRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GhostTraffic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ghostTrafficRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentGhostTrafficApi.ghostTrafficRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates a ghost traffic
         * @param {string} uuid 
         * @param {GhostTrafficUpdate} [ghostTrafficUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ghostTrafficUpdate(uuid: string, ghostTrafficUpdate?: GhostTrafficUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GhostTraffic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ghostTrafficUpdate(uuid, ghostTrafficUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentGhostTrafficApi.ghostTrafficUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RangeContentGhostTrafficApi - factory interface
 * @export
 */
export const RangeContentGhostTrafficApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RangeContentGhostTrafficApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a ghost traffic
         * @param {GhostTrafficCreate} [ghostTrafficCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostTrafficCreate(ghostTrafficCreate?: GhostTrafficCreate, options?: RawAxiosRequestConfig): AxiosPromise<GhostTraffic> {
            return localVarFp.ghostTrafficCreate(ghostTrafficCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a ghost traffic
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostTrafficDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.ghostTrafficDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List of ghost traffic
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {GhostTrafficListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {GhostTrafficListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostTrafficList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: GhostTrafficListSortByEnum, sort?: GhostTrafficListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<GhostTrafficList200Response> {
            return localVarFp.ghostTrafficList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Renders a ghost traffic template
         * @param {string} uuid 
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostTrafficRender(uuid: string, body?: object, options?: RawAxiosRequestConfig): AxiosPromise<GhostTraffic> {
            return localVarFp.ghostTrafficRender(uuid, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves a ghost traffic
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostTrafficRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<GhostTraffic> {
            return localVarFp.ghostTrafficRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a ghost traffic
         * @param {string} uuid 
         * @param {GhostTrafficUpdate} [ghostTrafficUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostTrafficUpdate(uuid: string, ghostTrafficUpdate?: GhostTrafficUpdate, options?: RawAxiosRequestConfig): AxiosPromise<GhostTraffic> {
            return localVarFp.ghostTrafficUpdate(uuid, ghostTrafficUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RangeContentGhostTrafficApi - object-oriented interface
 * @export
 * @class RangeContentGhostTrafficApi
 * @extends {BaseAPI}
 */
export class RangeContentGhostTrafficApi extends BaseAPI {
    /**
     * 
     * @summary Create a ghost traffic
     * @param {GhostTrafficCreate} [ghostTrafficCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentGhostTrafficApi
     */
    public ghostTrafficCreate(ghostTrafficCreate?: GhostTrafficCreate, options?: RawAxiosRequestConfig) {
        return RangeContentGhostTrafficApiFp(this.configuration).ghostTrafficCreate(ghostTrafficCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a ghost traffic
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentGhostTrafficApi
     */
    public ghostTrafficDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentGhostTrafficApiFp(this.configuration).ghostTrafficDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List of ghost traffic
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {GhostTrafficListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {GhostTrafficListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentGhostTrafficApi
     */
    public ghostTrafficList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: GhostTrafficListSortByEnum, sort?: GhostTrafficListSortEnum, options?: RawAxiosRequestConfig) {
        return RangeContentGhostTrafficApiFp(this.configuration).ghostTrafficList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Renders a ghost traffic template
     * @param {string} uuid 
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentGhostTrafficApi
     */
    public ghostTrafficRender(uuid: string, body?: object, options?: RawAxiosRequestConfig) {
        return RangeContentGhostTrafficApiFp(this.configuration).ghostTrafficRender(uuid, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves a ghost traffic
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentGhostTrafficApi
     */
    public ghostTrafficRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentGhostTrafficApiFp(this.configuration).ghostTrafficRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a ghost traffic
     * @param {string} uuid 
     * @param {GhostTrafficUpdate} [ghostTrafficUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentGhostTrafficApi
     */
    public ghostTrafficUpdate(uuid: string, ghostTrafficUpdate?: GhostTrafficUpdate, options?: RawAxiosRequestConfig) {
        return RangeContentGhostTrafficApiFp(this.configuration).ghostTrafficUpdate(uuid, ghostTrafficUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GhostTrafficListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author'
} as const;
export type GhostTrafficListSortByEnum = typeof GhostTrafficListSortByEnum[keyof typeof GhostTrafficListSortByEnum];
/**
 * @export
 */
export const GhostTrafficListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GhostTrafficListSortEnum = typeof GhostTrafficListSortEnum[keyof typeof GhostTrafficListSortEnum];


/**
 * RangeContentGhostTrafficProfileApi - axios parameter creator
 * @export
 */
export const RangeContentGhostTrafficProfileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a ghost traffic profile
         * @param {GhostTrafficProfileCreate} [ghostTrafficProfileCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostTrafficProfileCreate: async (ghostTrafficProfileCreate?: GhostTrafficProfileCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/ghost-traffic-profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ghostTrafficProfileCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a ghost traffic profile
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostTrafficProfileDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('ghostTrafficProfileDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/range/ghost-traffic-profile/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of ghost traffic profile
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {GhostTrafficProfileListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {GhostTrafficProfileListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostTrafficProfileList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: GhostTrafficProfileListSortByEnum, sort?: GhostTrafficProfileListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/ghost-traffic-profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a ghost traffic profile
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostTrafficProfileRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('ghostTrafficProfileRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/range/ghost-traffic-profile/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a ghost traffic profile in timeline JSON format
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostTrafficProfileRetrieveTimeline: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('ghostTrafficProfileRetrieveTimeline', 'uuid', uuid)
            const localVarPath = `/v1/content/range/ghost-traffic-profile/{uuid}/timeline.json`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a ghost traffic profile
         * @param {string} uuid 
         * @param {GhostTrafficProfileUpdate} [ghostTrafficProfileUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostTrafficProfileUpdate: async (uuid: string, ghostTrafficProfileUpdate?: GhostTrafficProfileUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('ghostTrafficProfileUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/range/ghost-traffic-profile/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ghostTrafficProfileUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RangeContentGhostTrafficProfileApi - functional programming interface
 * @export
 */
export const RangeContentGhostTrafficProfileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RangeContentGhostTrafficProfileApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a ghost traffic profile
         * @param {GhostTrafficProfileCreate} [ghostTrafficProfileCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ghostTrafficProfileCreate(ghostTrafficProfileCreate?: GhostTrafficProfileCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GhostTrafficProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ghostTrafficProfileCreate(ghostTrafficProfileCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentGhostTrafficProfileApi.ghostTrafficProfileCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Deletes a ghost traffic profile
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ghostTrafficProfileDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ghostTrafficProfileDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentGhostTrafficProfileApi.ghostTrafficProfileDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List of ghost traffic profile
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {GhostTrafficProfileListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {GhostTrafficProfileListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ghostTrafficProfileList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: GhostTrafficProfileListSortByEnum, sort?: GhostTrafficProfileListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GhostTrafficProfileList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ghostTrafficProfileList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentGhostTrafficProfileApi.ghostTrafficProfileList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves a ghost traffic profile
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ghostTrafficProfileRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GhostTrafficProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ghostTrafficProfileRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentGhostTrafficProfileApi.ghostTrafficProfileRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves a ghost traffic profile in timeline JSON format
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ghostTrafficProfileRetrieveTimeline(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ghostTrafficProfileRetrieveTimeline(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentGhostTrafficProfileApi.ghostTrafficProfileRetrieveTimeline']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates a ghost traffic profile
         * @param {string} uuid 
         * @param {GhostTrafficProfileUpdate} [ghostTrafficProfileUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ghostTrafficProfileUpdate(uuid: string, ghostTrafficProfileUpdate?: GhostTrafficProfileUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GhostTrafficProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ghostTrafficProfileUpdate(uuid, ghostTrafficProfileUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentGhostTrafficProfileApi.ghostTrafficProfileUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RangeContentGhostTrafficProfileApi - factory interface
 * @export
 */
export const RangeContentGhostTrafficProfileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RangeContentGhostTrafficProfileApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a ghost traffic profile
         * @param {GhostTrafficProfileCreate} [ghostTrafficProfileCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostTrafficProfileCreate(ghostTrafficProfileCreate?: GhostTrafficProfileCreate, options?: RawAxiosRequestConfig): AxiosPromise<GhostTrafficProfile> {
            return localVarFp.ghostTrafficProfileCreate(ghostTrafficProfileCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a ghost traffic profile
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostTrafficProfileDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.ghostTrafficProfileDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List of ghost traffic profile
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {GhostTrafficProfileListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {GhostTrafficProfileListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostTrafficProfileList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: GhostTrafficProfileListSortByEnum, sort?: GhostTrafficProfileListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<GhostTrafficProfileList200Response> {
            return localVarFp.ghostTrafficProfileList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves a ghost traffic profile
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostTrafficProfileRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<GhostTrafficProfile> {
            return localVarFp.ghostTrafficProfileRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves a ghost traffic profile in timeline JSON format
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostTrafficProfileRetrieveTimeline(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.ghostTrafficProfileRetrieveTimeline(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a ghost traffic profile
         * @param {string} uuid 
         * @param {GhostTrafficProfileUpdate} [ghostTrafficProfileUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ghostTrafficProfileUpdate(uuid: string, ghostTrafficProfileUpdate?: GhostTrafficProfileUpdate, options?: RawAxiosRequestConfig): AxiosPromise<GhostTrafficProfile> {
            return localVarFp.ghostTrafficProfileUpdate(uuid, ghostTrafficProfileUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RangeContentGhostTrafficProfileApi - object-oriented interface
 * @export
 * @class RangeContentGhostTrafficProfileApi
 * @extends {BaseAPI}
 */
export class RangeContentGhostTrafficProfileApi extends BaseAPI {
    /**
     * 
     * @summary Create a ghost traffic profile
     * @param {GhostTrafficProfileCreate} [ghostTrafficProfileCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentGhostTrafficProfileApi
     */
    public ghostTrafficProfileCreate(ghostTrafficProfileCreate?: GhostTrafficProfileCreate, options?: RawAxiosRequestConfig) {
        return RangeContentGhostTrafficProfileApiFp(this.configuration).ghostTrafficProfileCreate(ghostTrafficProfileCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a ghost traffic profile
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentGhostTrafficProfileApi
     */
    public ghostTrafficProfileDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentGhostTrafficProfileApiFp(this.configuration).ghostTrafficProfileDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List of ghost traffic profile
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {GhostTrafficProfileListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {GhostTrafficProfileListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentGhostTrafficProfileApi
     */
    public ghostTrafficProfileList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: GhostTrafficProfileListSortByEnum, sort?: GhostTrafficProfileListSortEnum, options?: RawAxiosRequestConfig) {
        return RangeContentGhostTrafficProfileApiFp(this.configuration).ghostTrafficProfileList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves a ghost traffic profile
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentGhostTrafficProfileApi
     */
    public ghostTrafficProfileRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentGhostTrafficProfileApiFp(this.configuration).ghostTrafficProfileRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves a ghost traffic profile in timeline JSON format
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentGhostTrafficProfileApi
     */
    public ghostTrafficProfileRetrieveTimeline(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentGhostTrafficProfileApiFp(this.configuration).ghostTrafficProfileRetrieveTimeline(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a ghost traffic profile
     * @param {string} uuid 
     * @param {GhostTrafficProfileUpdate} [ghostTrafficProfileUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentGhostTrafficProfileApi
     */
    public ghostTrafficProfileUpdate(uuid: string, ghostTrafficProfileUpdate?: GhostTrafficProfileUpdate, options?: RawAxiosRequestConfig) {
        return RangeContentGhostTrafficProfileApiFp(this.configuration).ghostTrafficProfileUpdate(uuid, ghostTrafficProfileUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GhostTrafficProfileListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author'
} as const;
export type GhostTrafficProfileListSortByEnum = typeof GhostTrafficProfileListSortByEnum[keyof typeof GhostTrafficProfileListSortByEnum];
/**
 * @export
 */
export const GhostTrafficProfileListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GhostTrafficProfileListSortEnum = typeof GhostTrafficProfileListSortEnum[keyof typeof GhostTrafficProfileListSortEnum];


/**
 * RangeContentInternetGatewaysApi - axios parameter creator
 * @export
 */
export const RangeContentInternetGatewaysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create an internet gateway
         * @param {InternetGatewayCreate} [internetGatewayCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internetGatewaysCreate: async (internetGatewayCreate?: InternetGatewayCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/internet-gateways`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(internetGatewayCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes an internet gateway
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internetGatewaysDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('internetGatewaysDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/range/internet-gateways/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of internet gateways
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {InternetGatewaysListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {InternetGatewaysListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internetGatewaysList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: InternetGatewaysListSortByEnum, sort?: InternetGatewaysListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/internet-gateways`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves an internet gateway
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internetGatewaysRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('internetGatewaysRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/range/internet-gateways/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an internet gateway
         * @param {string} uuid 
         * @param {InternetGatewayUpdate} [internetGatewayUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internetGatewaysUpdate: async (uuid: string, internetGatewayUpdate?: InternetGatewayUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('internetGatewaysUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/range/internet-gateways/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(internetGatewayUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RangeContentInternetGatewaysApi - functional programming interface
 * @export
 */
export const RangeContentInternetGatewaysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RangeContentInternetGatewaysApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create an internet gateway
         * @param {InternetGatewayCreate} [internetGatewayCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async internetGatewaysCreate(internetGatewayCreate?: InternetGatewayCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternetGateway>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.internetGatewaysCreate(internetGatewayCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentInternetGatewaysApi.internetGatewaysCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Deletes an internet gateway
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async internetGatewaysDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.internetGatewaysDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentInternetGatewaysApi.internetGatewaysDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List of internet gateways
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {InternetGatewaysListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {InternetGatewaysListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async internetGatewaysList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: InternetGatewaysListSortByEnum, sort?: InternetGatewaysListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternetGatewaysList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.internetGatewaysList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentInternetGatewaysApi.internetGatewaysList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves an internet gateway
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async internetGatewaysRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternetGateway>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.internetGatewaysRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentInternetGatewaysApi.internetGatewaysRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates an internet gateway
         * @param {string} uuid 
         * @param {InternetGatewayUpdate} [internetGatewayUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async internetGatewaysUpdate(uuid: string, internetGatewayUpdate?: InternetGatewayUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InternetGateway>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.internetGatewaysUpdate(uuid, internetGatewayUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentInternetGatewaysApi.internetGatewaysUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RangeContentInternetGatewaysApi - factory interface
 * @export
 */
export const RangeContentInternetGatewaysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RangeContentInternetGatewaysApiFp(configuration)
    return {
        /**
         * 
         * @summary Create an internet gateway
         * @param {InternetGatewayCreate} [internetGatewayCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internetGatewaysCreate(internetGatewayCreate?: InternetGatewayCreate, options?: RawAxiosRequestConfig): AxiosPromise<InternetGateway> {
            return localVarFp.internetGatewaysCreate(internetGatewayCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes an internet gateway
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internetGatewaysDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.internetGatewaysDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List of internet gateways
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {InternetGatewaysListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {InternetGatewaysListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internetGatewaysList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: InternetGatewaysListSortByEnum, sort?: InternetGatewaysListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<InternetGatewaysList200Response> {
            return localVarFp.internetGatewaysList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves an internet gateway
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internetGatewaysRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<InternetGateway> {
            return localVarFp.internetGatewaysRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates an internet gateway
         * @param {string} uuid 
         * @param {InternetGatewayUpdate} [internetGatewayUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internetGatewaysUpdate(uuid: string, internetGatewayUpdate?: InternetGatewayUpdate, options?: RawAxiosRequestConfig): AxiosPromise<InternetGateway> {
            return localVarFp.internetGatewaysUpdate(uuid, internetGatewayUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RangeContentInternetGatewaysApi - object-oriented interface
 * @export
 * @class RangeContentInternetGatewaysApi
 * @extends {BaseAPI}
 */
export class RangeContentInternetGatewaysApi extends BaseAPI {
    /**
     * 
     * @summary Create an internet gateway
     * @param {InternetGatewayCreate} [internetGatewayCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentInternetGatewaysApi
     */
    public internetGatewaysCreate(internetGatewayCreate?: InternetGatewayCreate, options?: RawAxiosRequestConfig) {
        return RangeContentInternetGatewaysApiFp(this.configuration).internetGatewaysCreate(internetGatewayCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes an internet gateway
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentInternetGatewaysApi
     */
    public internetGatewaysDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentInternetGatewaysApiFp(this.configuration).internetGatewaysDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List of internet gateways
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {InternetGatewaysListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {InternetGatewaysListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentInternetGatewaysApi
     */
    public internetGatewaysList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: InternetGatewaysListSortByEnum, sort?: InternetGatewaysListSortEnum, options?: RawAxiosRequestConfig) {
        return RangeContentInternetGatewaysApiFp(this.configuration).internetGatewaysList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves an internet gateway
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentInternetGatewaysApi
     */
    public internetGatewaysRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentInternetGatewaysApiFp(this.configuration).internetGatewaysRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates an internet gateway
     * @param {string} uuid 
     * @param {InternetGatewayUpdate} [internetGatewayUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentInternetGatewaysApi
     */
    public internetGatewaysUpdate(uuid: string, internetGatewayUpdate?: InternetGatewayUpdate, options?: RawAxiosRequestConfig) {
        return RangeContentInternetGatewaysApiFp(this.configuration).internetGatewaysUpdate(uuid, internetGatewayUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const InternetGatewaysListSortByEnum = {
    Author: 'author',
    Description: 'description',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Name: 'name'
} as const;
export type InternetGatewaysListSortByEnum = typeof InternetGatewaysListSortByEnum[keyof typeof InternetGatewaysListSortByEnum];
/**
 * @export
 */
export const InternetGatewaysListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type InternetGatewaysListSortEnum = typeof InternetGatewaysListSortEnum[keyof typeof InternetGatewaysListSortEnum];


/**
 * RangeContentNetworkOverrideApi - axios parameter creator
 * @export
 */
export const RangeContentNetworkOverrideApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a NetworkOverride
         * @param {NetworkOverrideCreate} [networkOverrideCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkOverrideCreate: async (networkOverrideCreate?: NetworkOverrideCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/network-override`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkOverrideCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a NetworkOverride
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkOverrideDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('networkOverrideDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/range/network-override/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of existing NetworkOverrides
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {NetworkOverrideListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {NetworkOverrideListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkOverrideList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: NetworkOverrideListSortByEnum, sort?: NetworkOverrideListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/network-override`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a NetworkOverride
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkOverrideRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('networkOverrideRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/range/network-override/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a NetworkOverride
         * @param {string} uuid 
         * @param {NetworkOverrideUpdate} [networkOverrideUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkOverrideUpdate: async (uuid: string, networkOverrideUpdate?: NetworkOverrideUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('networkOverrideUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/range/network-override/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkOverrideUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RangeContentNetworkOverrideApi - functional programming interface
 * @export
 */
export const RangeContentNetworkOverrideApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RangeContentNetworkOverrideApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a NetworkOverride
         * @param {NetworkOverrideCreate} [networkOverrideCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkOverrideCreate(networkOverrideCreate?: NetworkOverrideCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkOverride>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkOverrideCreate(networkOverrideCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentNetworkOverrideApi.networkOverrideCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a NetworkOverride
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkOverrideDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkOverrideDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentNetworkOverrideApi.networkOverrideDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List of existing NetworkOverrides
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {NetworkOverrideListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {NetworkOverrideListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkOverrideList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: NetworkOverrideListSortByEnum, sort?: NetworkOverrideListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkOverrideList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkOverrideList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentNetworkOverrideApi.networkOverrideList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a NetworkOverride
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkOverrideRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkOverride>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkOverrideRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentNetworkOverrideApi.networkOverrideRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a NetworkOverride
         * @param {string} uuid 
         * @param {NetworkOverrideUpdate} [networkOverrideUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkOverrideUpdate(uuid: string, networkOverrideUpdate?: NetworkOverrideUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkOverride>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkOverrideUpdate(uuid, networkOverrideUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentNetworkOverrideApi.networkOverrideUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RangeContentNetworkOverrideApi - factory interface
 * @export
 */
export const RangeContentNetworkOverrideApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RangeContentNetworkOverrideApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a NetworkOverride
         * @param {NetworkOverrideCreate} [networkOverrideCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkOverrideCreate(networkOverrideCreate?: NetworkOverrideCreate, options?: RawAxiosRequestConfig): AxiosPromise<NetworkOverride> {
            return localVarFp.networkOverrideCreate(networkOverrideCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a NetworkOverride
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkOverrideDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.networkOverrideDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List of existing NetworkOverrides
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {NetworkOverrideListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {NetworkOverrideListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkOverrideList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: NetworkOverrideListSortByEnum, sort?: NetworkOverrideListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<NetworkOverrideList200Response> {
            return localVarFp.networkOverrideList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a NetworkOverride
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkOverrideRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<NetworkOverride> {
            return localVarFp.networkOverrideRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a NetworkOverride
         * @param {string} uuid 
         * @param {NetworkOverrideUpdate} [networkOverrideUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkOverrideUpdate(uuid: string, networkOverrideUpdate?: NetworkOverrideUpdate, options?: RawAxiosRequestConfig): AxiosPromise<NetworkOverride> {
            return localVarFp.networkOverrideUpdate(uuid, networkOverrideUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RangeContentNetworkOverrideApi - object-oriented interface
 * @export
 * @class RangeContentNetworkOverrideApi
 * @extends {BaseAPI}
 */
export class RangeContentNetworkOverrideApi extends BaseAPI {
    /**
     * 
     * @summary Create a NetworkOverride
     * @param {NetworkOverrideCreate} [networkOverrideCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentNetworkOverrideApi
     */
    public networkOverrideCreate(networkOverrideCreate?: NetworkOverrideCreate, options?: RawAxiosRequestConfig) {
        return RangeContentNetworkOverrideApiFp(this.configuration).networkOverrideCreate(networkOverrideCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a NetworkOverride
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentNetworkOverrideApi
     */
    public networkOverrideDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentNetworkOverrideApiFp(this.configuration).networkOverrideDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List of existing NetworkOverrides
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {NetworkOverrideListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {NetworkOverrideListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentNetworkOverrideApi
     */
    public networkOverrideList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: NetworkOverrideListSortByEnum, sort?: NetworkOverrideListSortEnum, options?: RawAxiosRequestConfig) {
        return RangeContentNetworkOverrideApiFp(this.configuration).networkOverrideList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a NetworkOverride
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentNetworkOverrideApi
     */
    public networkOverrideRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentNetworkOverrideApiFp(this.configuration).networkOverrideRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a NetworkOverride
     * @param {string} uuid 
     * @param {NetworkOverrideUpdate} [networkOverrideUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentNetworkOverrideApi
     */
    public networkOverrideUpdate(uuid: string, networkOverrideUpdate?: NetworkOverrideUpdate, options?: RawAxiosRequestConfig) {
        return RangeContentNetworkOverrideApiFp(this.configuration).networkOverrideUpdate(uuid, networkOverrideUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const NetworkOverrideListSortByEnum = {
    Author: 'author',
    Description: 'description',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Name: 'name'
} as const;
export type NetworkOverrideListSortByEnum = typeof NetworkOverrideListSortByEnum[keyof typeof NetworkOverrideListSortByEnum];
/**
 * @export
 */
export const NetworkOverrideListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type NetworkOverrideListSortEnum = typeof NetworkOverrideListSortEnum[keyof typeof NetworkOverrideListSortEnum];


/**
 * RangeContentPCTEStandardNetspecApi - axios parameter creator
 * @export
 */
export const RangeContentPCTEStandardNetspecApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Convert the PCTE Standard Netspec into a scenario.
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pcteStandardNetspecCreate: async (requestBody?: { [key: string]: any; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/generics/pcte-standard-netspec`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a PCTE standard netspec
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pcteStandardNetspecDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('pcteStandardNetspecDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/generics/pcte-standard-netspec/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List existing PCTE standard netspecs
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {PcteStandardNetspecListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {PcteStandardNetspecListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pcteStandardNetspecList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: PcteStandardNetspecListSortByEnum, sort?: PcteStandardNetspecListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/generics/pcte-standard-netspec`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a PCTE standard netspec
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pcteStandardNetspecRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('pcteStandardNetspecRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/generics/pcte-standard-netspec/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a PCTE standard netspec
         * @param {string} uuid 
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pcteStandardNetspecUpdate: async (uuid: string, requestBody?: { [key: string]: any; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('pcteStandardNetspecUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/generics/pcte-standard-netspec/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RangeContentPCTEStandardNetspecApi - functional programming interface
 * @export
 */
export const RangeContentPCTEStandardNetspecApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RangeContentPCTEStandardNetspecApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Convert the PCTE Standard Netspec into a scenario.
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pcteStandardNetspecCreate(requestBody?: { [key: string]: any; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PcteStandardNetspec>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pcteStandardNetspecCreate(requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentPCTEStandardNetspecApi.pcteStandardNetspecCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a PCTE standard netspec
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pcteStandardNetspecDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pcteStandardNetspecDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentPCTEStandardNetspecApi.pcteStandardNetspecDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List existing PCTE standard netspecs
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {PcteStandardNetspecListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {PcteStandardNetspecListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pcteStandardNetspecList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: PcteStandardNetspecListSortByEnum, sort?: PcteStandardNetspecListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PcteStandardNetspecList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pcteStandardNetspecList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentPCTEStandardNetspecApi.pcteStandardNetspecList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a PCTE standard netspec
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pcteStandardNetspecRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PcteStandardNetspec>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pcteStandardNetspecRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentPCTEStandardNetspecApi.pcteStandardNetspecRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a PCTE standard netspec
         * @param {string} uuid 
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pcteStandardNetspecUpdate(uuid: string, requestBody?: { [key: string]: any; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PcteStandardNetspec>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pcteStandardNetspecUpdate(uuid, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentPCTEStandardNetspecApi.pcteStandardNetspecUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RangeContentPCTEStandardNetspecApi - factory interface
 * @export
 */
export const RangeContentPCTEStandardNetspecApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RangeContentPCTEStandardNetspecApiFp(configuration)
    return {
        /**
         * 
         * @summary Convert the PCTE Standard Netspec into a scenario.
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pcteStandardNetspecCreate(requestBody?: { [key: string]: any; }, options?: RawAxiosRequestConfig): AxiosPromise<PcteStandardNetspec> {
            return localVarFp.pcteStandardNetspecCreate(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a PCTE standard netspec
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pcteStandardNetspecDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.pcteStandardNetspecDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List existing PCTE standard netspecs
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {PcteStandardNetspecListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {PcteStandardNetspecListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pcteStandardNetspecList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: PcteStandardNetspecListSortByEnum, sort?: PcteStandardNetspecListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<PcteStandardNetspecList200Response> {
            return localVarFp.pcteStandardNetspecList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a PCTE standard netspec
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pcteStandardNetspecRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<PcteStandardNetspec> {
            return localVarFp.pcteStandardNetspecRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a PCTE standard netspec
         * @param {string} uuid 
         * @param {{ [key: string]: any; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pcteStandardNetspecUpdate(uuid: string, requestBody?: { [key: string]: any; }, options?: RawAxiosRequestConfig): AxiosPromise<PcteStandardNetspec> {
            return localVarFp.pcteStandardNetspecUpdate(uuid, requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RangeContentPCTEStandardNetspecApi - object-oriented interface
 * @export
 * @class RangeContentPCTEStandardNetspecApi
 * @extends {BaseAPI}
 */
export class RangeContentPCTEStandardNetspecApi extends BaseAPI {
    /**
     * 
     * @summary Convert the PCTE Standard Netspec into a scenario.
     * @param {{ [key: string]: any; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentPCTEStandardNetspecApi
     */
    public pcteStandardNetspecCreate(requestBody?: { [key: string]: any; }, options?: RawAxiosRequestConfig) {
        return RangeContentPCTEStandardNetspecApiFp(this.configuration).pcteStandardNetspecCreate(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a PCTE standard netspec
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentPCTEStandardNetspecApi
     */
    public pcteStandardNetspecDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentPCTEStandardNetspecApiFp(this.configuration).pcteStandardNetspecDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List existing PCTE standard netspecs
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {PcteStandardNetspecListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {PcteStandardNetspecListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentPCTEStandardNetspecApi
     */
    public pcteStandardNetspecList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: PcteStandardNetspecListSortByEnum, sort?: PcteStandardNetspecListSortEnum, options?: RawAxiosRequestConfig) {
        return RangeContentPCTEStandardNetspecApiFp(this.configuration).pcteStandardNetspecList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a PCTE standard netspec
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentPCTEStandardNetspecApi
     */
    public pcteStandardNetspecRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentPCTEStandardNetspecApiFp(this.configuration).pcteStandardNetspecRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a PCTE standard netspec
     * @param {string} uuid 
     * @param {{ [key: string]: any; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentPCTEStandardNetspecApi
     */
    public pcteStandardNetspecUpdate(uuid: string, requestBody?: { [key: string]: any; }, options?: RawAxiosRequestConfig) {
        return RangeContentPCTEStandardNetspecApiFp(this.configuration).pcteStandardNetspecUpdate(uuid, requestBody, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const PcteStandardNetspecListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author'
} as const;
export type PcteStandardNetspecListSortByEnum = typeof PcteStandardNetspecListSortByEnum[keyof typeof PcteStandardNetspecListSortByEnum];
/**
 * @export
 */
export const PcteStandardNetspecListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type PcteStandardNetspecListSortEnum = typeof PcteStandardNetspecListSortEnum[keyof typeof PcteStandardNetspecListSortEnum];


/**
 * RangeContentPackagesApi - axios parameter creator
 * @export
 */
export const RangeContentPackagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a package
         * @param {PackageCreate} [packageCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesCreate: async (packageCreate?: PackageCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/packages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(packageCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates package ACLs
         * @param {string} uuid 
         * @param {AclPackageCreate} [aclPackageCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesCreateAcl: async (uuid: string, aclPackageCreate?: AclPackageCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('packagesCreateAcl', 'uuid', uuid)
            const localVarPath = `/v1/content/range/packages/{uuid}/acls`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aclPackageCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a package
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('packagesDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/range/packages/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of packages
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {PackagesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {PackagesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: PackagesListSortByEnum, sort?: PackagesListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/packages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a package
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('packagesRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/range/packages/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves scenario ACLs
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesRetrieveAcl: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('packagesRetrieveAcl', 'uuid', uuid)
            const localVarPath = `/v1/content/range/packages/{uuid}/acls`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a package
         * @param {string} uuid 
         * @param {PackageUpdate} [packageUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesUpdate: async (uuid: string, packageUpdate?: PackageUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('packagesUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/range/packages/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(packageUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RangeContentPackagesApi - functional programming interface
 * @export
 */
export const RangeContentPackagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RangeContentPackagesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a package
         * @param {PackageCreate} [packageCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async packagesCreate(packageCreate?: PackageCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Package>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.packagesCreate(packageCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentPackagesApi.packagesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates package ACLs
         * @param {string} uuid 
         * @param {AclPackageCreate} [aclPackageCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async packagesCreateAcl(uuid: string, aclPackageCreate?: AclPackageCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AclPackage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.packagesCreateAcl(uuid, aclPackageCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentPackagesApi.packagesCreateAcl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Deletes a package
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async packagesDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.packagesDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentPackagesApi.packagesDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List of packages
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {PackagesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {PackagesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async packagesList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: PackagesListSortByEnum, sort?: PackagesListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PackagesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.packagesList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentPackagesApi.packagesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves a package
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async packagesRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Package>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.packagesRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentPackagesApi.packagesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves scenario ACLs
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async packagesRetrieveAcl(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AclPackage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.packagesRetrieveAcl(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentPackagesApi.packagesRetrieveAcl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates a package
         * @param {string} uuid 
         * @param {PackageUpdate} [packageUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async packagesUpdate(uuid: string, packageUpdate?: PackageUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Package>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.packagesUpdate(uuid, packageUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentPackagesApi.packagesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RangeContentPackagesApi - factory interface
 * @export
 */
export const RangeContentPackagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RangeContentPackagesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a package
         * @param {PackageCreate} [packageCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesCreate(packageCreate?: PackageCreate, options?: RawAxiosRequestConfig): AxiosPromise<Package> {
            return localVarFp.packagesCreate(packageCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates package ACLs
         * @param {string} uuid 
         * @param {AclPackageCreate} [aclPackageCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesCreateAcl(uuid: string, aclPackageCreate?: AclPackageCreate, options?: RawAxiosRequestConfig): AxiosPromise<AclPackage> {
            return localVarFp.packagesCreateAcl(uuid, aclPackageCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a package
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.packagesDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List of packages
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {PackagesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {PackagesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: PackagesListSortByEnum, sort?: PackagesListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<PackagesList200Response> {
            return localVarFp.packagesList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves a package
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<Package> {
            return localVarFp.packagesRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves scenario ACLs
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesRetrieveAcl(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<AclPackage> {
            return localVarFp.packagesRetrieveAcl(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a package
         * @param {string} uuid 
         * @param {PackageUpdate} [packageUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        packagesUpdate(uuid: string, packageUpdate?: PackageUpdate, options?: RawAxiosRequestConfig): AxiosPromise<Package> {
            return localVarFp.packagesUpdate(uuid, packageUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RangeContentPackagesApi - object-oriented interface
 * @export
 * @class RangeContentPackagesApi
 * @extends {BaseAPI}
 */
export class RangeContentPackagesApi extends BaseAPI {
    /**
     * 
     * @summary Create a package
     * @param {PackageCreate} [packageCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentPackagesApi
     */
    public packagesCreate(packageCreate?: PackageCreate, options?: RawAxiosRequestConfig) {
        return RangeContentPackagesApiFp(this.configuration).packagesCreate(packageCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates package ACLs
     * @param {string} uuid 
     * @param {AclPackageCreate} [aclPackageCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentPackagesApi
     */
    public packagesCreateAcl(uuid: string, aclPackageCreate?: AclPackageCreate, options?: RawAxiosRequestConfig) {
        return RangeContentPackagesApiFp(this.configuration).packagesCreateAcl(uuid, aclPackageCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a package
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentPackagesApi
     */
    public packagesDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentPackagesApiFp(this.configuration).packagesDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List of packages
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {PackagesListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {PackagesListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentPackagesApi
     */
    public packagesList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: PackagesListSortByEnum, sort?: PackagesListSortEnum, options?: RawAxiosRequestConfig) {
        return RangeContentPackagesApiFp(this.configuration).packagesList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves a package
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentPackagesApi
     */
    public packagesRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentPackagesApiFp(this.configuration).packagesRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves scenario ACLs
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentPackagesApi
     */
    public packagesRetrieveAcl(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentPackagesApiFp(this.configuration).packagesRetrieveAcl(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a package
     * @param {string} uuid 
     * @param {PackageUpdate} [packageUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentPackagesApi
     */
    public packagesUpdate(uuid: string, packageUpdate?: PackageUpdate, options?: RawAxiosRequestConfig) {
        return RangeContentPackagesApiFp(this.configuration).packagesUpdate(uuid, packageUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const PackagesListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author'
} as const;
export type PackagesListSortByEnum = typeof PackagesListSortByEnum[keyof typeof PackagesListSortByEnum];
/**
 * @export
 */
export const PackagesListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type PackagesListSortEnum = typeof PackagesListSortEnum[keyof typeof PackagesListSortEnum];


/**
 * RangeContentRangeAutoIPsApi - axios parameter creator
 * @export
 */
export const RangeContentRangeAutoIPsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a range auto IP
         * @param {RangeAutoIpCreate} [rangeAutoIpCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeAutoIPsCreate: async (rangeAutoIpCreate?: RangeAutoIpCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/range-auto-ips`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeAutoIpCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a range auto IP
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeAutoIPsDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeAutoIPsDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-auto-ips/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List range auto IPs
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [address] 
         * @param {string} [countryCode] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeAutoIPsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeAutoIPsListSortOrderEnum} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeAutoIPsList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, address?: string, countryCode?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeAutoIPsListSortByEnum, sortOrder?: RangeAutoIPsListSortOrderEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/range-auto-ips`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (countryCode !== undefined) {
                localVarQueryParameter['countryCode'] = countryCode;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a range auto IP
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeAutoIPsRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeAutoIPsRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-auto-ips/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a range auto IP
         * @param {string} uuid 
         * @param {RangeAutoIpUpdate} [rangeAutoIpUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeAutoIPsUpdate: async (uuid: string, rangeAutoIpUpdate?: RangeAutoIpUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeAutoIPsUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-auto-ips/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeAutoIpUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RangeContentRangeAutoIPsApi - functional programming interface
 * @export
 */
export const RangeContentRangeAutoIPsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RangeContentRangeAutoIPsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a range auto IP
         * @param {RangeAutoIpCreate} [rangeAutoIpCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeAutoIPsCreate(rangeAutoIpCreate?: RangeAutoIpCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeAutoIP>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeAutoIPsCreate(rangeAutoIpCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeAutoIPsApi.rangeAutoIPsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a range auto IP
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeAutoIPsDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeAutoIPsDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeAutoIPsApi.rangeAutoIPsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List range auto IPs
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [address] 
         * @param {string} [countryCode] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeAutoIPsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeAutoIPsListSortOrderEnum} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeAutoIPsList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, address?: string, countryCode?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeAutoIPsListSortByEnum, sortOrder?: RangeAutoIPsListSortOrderEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeAutoIPsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeAutoIPsList(uuid, name, description, author, metadata, address, countryCode, offset, limit, search, sortBy, sortOrder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeAutoIPsApi.rangeAutoIPsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a range auto IP
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeAutoIPsRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeAutoIP>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeAutoIPsRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeAutoIPsApi.rangeAutoIPsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a range auto IP
         * @param {string} uuid 
         * @param {RangeAutoIpUpdate} [rangeAutoIpUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeAutoIPsUpdate(uuid: string, rangeAutoIpUpdate?: RangeAutoIpUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeAutoIP>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeAutoIPsUpdate(uuid, rangeAutoIpUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeAutoIPsApi.rangeAutoIPsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RangeContentRangeAutoIPsApi - factory interface
 * @export
 */
export const RangeContentRangeAutoIPsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RangeContentRangeAutoIPsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a range auto IP
         * @param {RangeAutoIpCreate} [rangeAutoIpCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeAutoIPsCreate(rangeAutoIpCreate?: RangeAutoIpCreate, options?: RawAxiosRequestConfig): AxiosPromise<RangeAutoIP> {
            return localVarFp.rangeAutoIPsCreate(rangeAutoIpCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a range auto IP
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeAutoIPsDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rangeAutoIPsDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List range auto IPs
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [address] 
         * @param {string} [countryCode] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeAutoIPsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeAutoIPsListSortOrderEnum} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeAutoIPsList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, address?: string, countryCode?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeAutoIPsListSortByEnum, sortOrder?: RangeAutoIPsListSortOrderEnum, options?: RawAxiosRequestConfig): AxiosPromise<RangeAutoIPsList200Response> {
            return localVarFp.rangeAutoIPsList(uuid, name, description, author, metadata, address, countryCode, offset, limit, search, sortBy, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a range auto IP
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeAutoIPsRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<RangeAutoIP> {
            return localVarFp.rangeAutoIPsRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a range auto IP
         * @param {string} uuid 
         * @param {RangeAutoIpUpdate} [rangeAutoIpUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeAutoIPsUpdate(uuid: string, rangeAutoIpUpdate?: RangeAutoIpUpdate, options?: RawAxiosRequestConfig): AxiosPromise<RangeAutoIP> {
            return localVarFp.rangeAutoIPsUpdate(uuid, rangeAutoIpUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RangeContentRangeAutoIPsApi - object-oriented interface
 * @export
 * @class RangeContentRangeAutoIPsApi
 * @extends {BaseAPI}
 */
export class RangeContentRangeAutoIPsApi extends BaseAPI {
    /**
     * 
     * @summary Create a range auto IP
     * @param {RangeAutoIpCreate} [rangeAutoIpCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeAutoIPsApi
     */
    public rangeAutoIPsCreate(rangeAutoIpCreate?: RangeAutoIpCreate, options?: RawAxiosRequestConfig) {
        return RangeContentRangeAutoIPsApiFp(this.configuration).rangeAutoIPsCreate(rangeAutoIpCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a range auto IP
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeAutoIPsApi
     */
    public rangeAutoIPsDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentRangeAutoIPsApiFp(this.configuration).rangeAutoIPsDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List range auto IPs
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {string} [address] 
     * @param {string} [countryCode] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {RangeAutoIPsListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {RangeAutoIPsListSortOrderEnum} [sortOrder] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeAutoIPsApi
     */
    public rangeAutoIPsList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, address?: string, countryCode?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeAutoIPsListSortByEnum, sortOrder?: RangeAutoIPsListSortOrderEnum, options?: RawAxiosRequestConfig) {
        return RangeContentRangeAutoIPsApiFp(this.configuration).rangeAutoIPsList(uuid, name, description, author, metadata, address, countryCode, offset, limit, search, sortBy, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a range auto IP
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeAutoIPsApi
     */
    public rangeAutoIPsRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentRangeAutoIPsApiFp(this.configuration).rangeAutoIPsRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a range auto IP
     * @param {string} uuid 
     * @param {RangeAutoIpUpdate} [rangeAutoIpUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeAutoIPsApi
     */
    public rangeAutoIPsUpdate(uuid: string, rangeAutoIpUpdate?: RangeAutoIpUpdate, options?: RawAxiosRequestConfig) {
        return RangeContentRangeAutoIPsApiFp(this.configuration).rangeAutoIPsUpdate(uuid, rangeAutoIpUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RangeAutoIPsListSortByEnum = {
    Author: 'author',
    Description: 'description',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Name: 'name',
    Address: 'address',
    CountryCode: 'countryCode'
} as const;
export type RangeAutoIPsListSortByEnum = typeof RangeAutoIPsListSortByEnum[keyof typeof RangeAutoIPsListSortByEnum];
/**
 * @export
 */
export const RangeAutoIPsListSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type RangeAutoIPsListSortOrderEnum = typeof RangeAutoIPsListSortOrderEnum[keyof typeof RangeAutoIPsListSortOrderEnum];


/**
 * RangeContentRangeAutoL3NetworksApi - axios parameter creator
 * @export
 */
export const RangeContentRangeAutoL3NetworksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a range auto L3 network
         * @param {RangeAutoL3NetworkCreate} [rangeAutoL3NetworkCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeAutoL3NetworksCreate: async (rangeAutoL3NetworkCreate?: RangeAutoL3NetworkCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/range-auto-l3-networks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeAutoL3NetworkCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a range auto L3 network
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeAutoL3NetworksDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeAutoL3NetworksDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-auto-l3-networks/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List range auto L3 networks
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [cidr] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeAutoL3NetworksListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeAutoL3NetworksListSortOrderEnum} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeAutoL3NetworksList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, cidr?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeAutoL3NetworksListSortByEnum, sortOrder?: RangeAutoL3NetworksListSortOrderEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/range-auto-l3-networks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (cidr !== undefined) {
                localVarQueryParameter['cidr'] = cidr;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a range auto L3 network
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeAutoL3NetworksRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeAutoL3NetworksRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-auto-l3-networks/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a range auto L3 network
         * @param {string} uuid 
         * @param {RangeAutoL3NetworkUpdate} [rangeAutoL3NetworkUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeAutoL3NetworksUpdate: async (uuid: string, rangeAutoL3NetworkUpdate?: RangeAutoL3NetworkUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeAutoL3NetworksUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-auto-l3-networks/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeAutoL3NetworkUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RangeContentRangeAutoL3NetworksApi - functional programming interface
 * @export
 */
export const RangeContentRangeAutoL3NetworksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RangeContentRangeAutoL3NetworksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a range auto L3 network
         * @param {RangeAutoL3NetworkCreate} [rangeAutoL3NetworkCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeAutoL3NetworksCreate(rangeAutoL3NetworkCreate?: RangeAutoL3NetworkCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeAutoL3Network>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeAutoL3NetworksCreate(rangeAutoL3NetworkCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeAutoL3NetworksApi.rangeAutoL3NetworksCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a range auto L3 network
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeAutoL3NetworksDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeAutoL3NetworksDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeAutoL3NetworksApi.rangeAutoL3NetworksDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List range auto L3 networks
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [cidr] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeAutoL3NetworksListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeAutoL3NetworksListSortOrderEnum} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeAutoL3NetworksList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, cidr?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeAutoL3NetworksListSortByEnum, sortOrder?: RangeAutoL3NetworksListSortOrderEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeAutoL3NetworksList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeAutoL3NetworksList(uuid, name, description, author, metadata, cidr, offset, limit, search, sortBy, sortOrder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeAutoL3NetworksApi.rangeAutoL3NetworksList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a range auto L3 network
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeAutoL3NetworksRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeAutoL3Network>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeAutoL3NetworksRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeAutoL3NetworksApi.rangeAutoL3NetworksRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a range auto L3 network
         * @param {string} uuid 
         * @param {RangeAutoL3NetworkUpdate} [rangeAutoL3NetworkUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeAutoL3NetworksUpdate(uuid: string, rangeAutoL3NetworkUpdate?: RangeAutoL3NetworkUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeAutoL3Network>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeAutoL3NetworksUpdate(uuid, rangeAutoL3NetworkUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeAutoL3NetworksApi.rangeAutoL3NetworksUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RangeContentRangeAutoL3NetworksApi - factory interface
 * @export
 */
export const RangeContentRangeAutoL3NetworksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RangeContentRangeAutoL3NetworksApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a range auto L3 network
         * @param {RangeAutoL3NetworkCreate} [rangeAutoL3NetworkCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeAutoL3NetworksCreate(rangeAutoL3NetworkCreate?: RangeAutoL3NetworkCreate, options?: RawAxiosRequestConfig): AxiosPromise<RangeAutoL3Network> {
            return localVarFp.rangeAutoL3NetworksCreate(rangeAutoL3NetworkCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a range auto L3 network
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeAutoL3NetworksDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rangeAutoL3NetworksDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List range auto L3 networks
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [cidr] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeAutoL3NetworksListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeAutoL3NetworksListSortOrderEnum} [sortOrder] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeAutoL3NetworksList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, cidr?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeAutoL3NetworksListSortByEnum, sortOrder?: RangeAutoL3NetworksListSortOrderEnum, options?: RawAxiosRequestConfig): AxiosPromise<RangeAutoL3NetworksList200Response> {
            return localVarFp.rangeAutoL3NetworksList(uuid, name, description, author, metadata, cidr, offset, limit, search, sortBy, sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a range auto L3 network
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeAutoL3NetworksRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<RangeAutoL3Network> {
            return localVarFp.rangeAutoL3NetworksRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a range auto L3 network
         * @param {string} uuid 
         * @param {RangeAutoL3NetworkUpdate} [rangeAutoL3NetworkUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeAutoL3NetworksUpdate(uuid: string, rangeAutoL3NetworkUpdate?: RangeAutoL3NetworkUpdate, options?: RawAxiosRequestConfig): AxiosPromise<RangeAutoL3Network> {
            return localVarFp.rangeAutoL3NetworksUpdate(uuid, rangeAutoL3NetworkUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RangeContentRangeAutoL3NetworksApi - object-oriented interface
 * @export
 * @class RangeContentRangeAutoL3NetworksApi
 * @extends {BaseAPI}
 */
export class RangeContentRangeAutoL3NetworksApi extends BaseAPI {
    /**
     * 
     * @summary Create a range auto L3 network
     * @param {RangeAutoL3NetworkCreate} [rangeAutoL3NetworkCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeAutoL3NetworksApi
     */
    public rangeAutoL3NetworksCreate(rangeAutoL3NetworkCreate?: RangeAutoL3NetworkCreate, options?: RawAxiosRequestConfig) {
        return RangeContentRangeAutoL3NetworksApiFp(this.configuration).rangeAutoL3NetworksCreate(rangeAutoL3NetworkCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a range auto L3 network
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeAutoL3NetworksApi
     */
    public rangeAutoL3NetworksDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentRangeAutoL3NetworksApiFp(this.configuration).rangeAutoL3NetworksDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List range auto L3 networks
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {string} [cidr] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {RangeAutoL3NetworksListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {RangeAutoL3NetworksListSortOrderEnum} [sortOrder] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeAutoL3NetworksApi
     */
    public rangeAutoL3NetworksList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, cidr?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeAutoL3NetworksListSortByEnum, sortOrder?: RangeAutoL3NetworksListSortOrderEnum, options?: RawAxiosRequestConfig) {
        return RangeContentRangeAutoL3NetworksApiFp(this.configuration).rangeAutoL3NetworksList(uuid, name, description, author, metadata, cidr, offset, limit, search, sortBy, sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a range auto L3 network
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeAutoL3NetworksApi
     */
    public rangeAutoL3NetworksRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentRangeAutoL3NetworksApiFp(this.configuration).rangeAutoL3NetworksRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a range auto L3 network
     * @param {string} uuid 
     * @param {RangeAutoL3NetworkUpdate} [rangeAutoL3NetworkUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeAutoL3NetworksApi
     */
    public rangeAutoL3NetworksUpdate(uuid: string, rangeAutoL3NetworkUpdate?: RangeAutoL3NetworkUpdate, options?: RawAxiosRequestConfig) {
        return RangeContentRangeAutoL3NetworksApiFp(this.configuration).rangeAutoL3NetworksUpdate(uuid, rangeAutoL3NetworkUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RangeAutoL3NetworksListSortByEnum = {
    Author: 'author',
    Description: 'description',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Name: 'name',
    Cidr: 'cidr'
} as const;
export type RangeAutoL3NetworksListSortByEnum = typeof RangeAutoL3NetworksListSortByEnum[keyof typeof RangeAutoL3NetworksListSortByEnum];
/**
 * @export
 */
export const RangeAutoL3NetworksListSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type RangeAutoL3NetworksListSortOrderEnum = typeof RangeAutoL3NetworksListSortOrderEnum[keyof typeof RangeAutoL3NetworksListSortOrderEnum];


/**
 * RangeContentRangeBGPLinksApi - axios parameter creator
 * @export
 */
export const RangeContentRangeBGPLinksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a range BGPLink
         * @param {RangeBgpLinkCreate} [rangeBgpLinkCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeBgpLinksCreate: async (rangeBgpLinkCreate?: RangeBgpLinkCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/range-bgp-links`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeBgpLinkCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a range BGPLink
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeBgpLinksDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeBgpLinksDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-bgp-links/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List range BGPLinks
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [node1] 
         * @param {number} [node1ASN] 
         * @param {string} [node2] 
         * @param {number} [node2ASN] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeBgpLinksListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeBgpLinksListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeBgpLinksList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, node1?: string, node1ASN?: number, node2?: string, node2ASN?: number, offset?: number, limit?: number, search?: string, sortBy?: RangeBgpLinksListSortByEnum, sort?: RangeBgpLinksListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/range-bgp-links`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (node1 !== undefined) {
                localVarQueryParameter['node1'] = node1;
            }

            if (node1ASN !== undefined) {
                localVarQueryParameter['node1ASN'] = node1ASN;
            }

            if (node2 !== undefined) {
                localVarQueryParameter['node2'] = node2;
            }

            if (node2ASN !== undefined) {
                localVarQueryParameter['node2ASN'] = node2ASN;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a range BGPLink
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeBgpLinksRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeBgpLinksRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-bgp-links/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a range BGPLink
         * @param {string} uuid 
         * @param {RangeBgpLinkUpdate} [rangeBgpLinkUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeBgpLinksUpdate: async (uuid: string, rangeBgpLinkUpdate?: RangeBgpLinkUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeBgpLinksUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-bgp-links/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeBgpLinkUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RangeContentRangeBGPLinksApi - functional programming interface
 * @export
 */
export const RangeContentRangeBGPLinksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RangeContentRangeBGPLinksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a range BGPLink
         * @param {RangeBgpLinkCreate} [rangeBgpLinkCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeBgpLinksCreate(rangeBgpLinkCreate?: RangeBgpLinkCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeBGPLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeBgpLinksCreate(rangeBgpLinkCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeBGPLinksApi.rangeBgpLinksCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a range BGPLink
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeBgpLinksDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeBgpLinksDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeBGPLinksApi.rangeBgpLinksDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List range BGPLinks
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [node1] 
         * @param {number} [node1ASN] 
         * @param {string} [node2] 
         * @param {number} [node2ASN] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeBgpLinksListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeBgpLinksListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeBgpLinksList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, node1?: string, node1ASN?: number, node2?: string, node2ASN?: number, offset?: number, limit?: number, search?: string, sortBy?: RangeBgpLinksListSortByEnum, sort?: RangeBgpLinksListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeBgpLinksList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeBgpLinksList(uuid, name, description, author, metadata, node1, node1ASN, node2, node2ASN, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeBGPLinksApi.rangeBgpLinksList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a range BGPLink
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeBgpLinksRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeBGPLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeBgpLinksRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeBGPLinksApi.rangeBgpLinksRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a range BGPLink
         * @param {string} uuid 
         * @param {RangeBgpLinkUpdate} [rangeBgpLinkUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeBgpLinksUpdate(uuid: string, rangeBgpLinkUpdate?: RangeBgpLinkUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeBGPLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeBgpLinksUpdate(uuid, rangeBgpLinkUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeBGPLinksApi.rangeBgpLinksUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RangeContentRangeBGPLinksApi - factory interface
 * @export
 */
export const RangeContentRangeBGPLinksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RangeContentRangeBGPLinksApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a range BGPLink
         * @param {RangeBgpLinkCreate} [rangeBgpLinkCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeBgpLinksCreate(rangeBgpLinkCreate?: RangeBgpLinkCreate, options?: RawAxiosRequestConfig): AxiosPromise<RangeBGPLink> {
            return localVarFp.rangeBgpLinksCreate(rangeBgpLinkCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a range BGPLink
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeBgpLinksDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rangeBgpLinksDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List range BGPLinks
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [node1] 
         * @param {number} [node1ASN] 
         * @param {string} [node2] 
         * @param {number} [node2ASN] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeBgpLinksListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeBgpLinksListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeBgpLinksList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, node1?: string, node1ASN?: number, node2?: string, node2ASN?: number, offset?: number, limit?: number, search?: string, sortBy?: RangeBgpLinksListSortByEnum, sort?: RangeBgpLinksListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<RangeBgpLinksList200Response> {
            return localVarFp.rangeBgpLinksList(uuid, name, description, author, metadata, node1, node1ASN, node2, node2ASN, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a range BGPLink
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeBgpLinksRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<RangeBGPLink> {
            return localVarFp.rangeBgpLinksRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a range BGPLink
         * @param {string} uuid 
         * @param {RangeBgpLinkUpdate} [rangeBgpLinkUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeBgpLinksUpdate(uuid: string, rangeBgpLinkUpdate?: RangeBgpLinkUpdate, options?: RawAxiosRequestConfig): AxiosPromise<RangeBGPLink> {
            return localVarFp.rangeBgpLinksUpdate(uuid, rangeBgpLinkUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RangeContentRangeBGPLinksApi - object-oriented interface
 * @export
 * @class RangeContentRangeBGPLinksApi
 * @extends {BaseAPI}
 */
export class RangeContentRangeBGPLinksApi extends BaseAPI {
    /**
     * 
     * @summary Create a range BGPLink
     * @param {RangeBgpLinkCreate} [rangeBgpLinkCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeBGPLinksApi
     */
    public rangeBgpLinksCreate(rangeBgpLinkCreate?: RangeBgpLinkCreate, options?: RawAxiosRequestConfig) {
        return RangeContentRangeBGPLinksApiFp(this.configuration).rangeBgpLinksCreate(rangeBgpLinkCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a range BGPLink
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeBGPLinksApi
     */
    public rangeBgpLinksDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentRangeBGPLinksApiFp(this.configuration).rangeBgpLinksDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List range BGPLinks
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {string} [node1] 
     * @param {number} [node1ASN] 
     * @param {string} [node2] 
     * @param {number} [node2ASN] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {RangeBgpLinksListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {RangeBgpLinksListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeBGPLinksApi
     */
    public rangeBgpLinksList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, node1?: string, node1ASN?: number, node2?: string, node2ASN?: number, offset?: number, limit?: number, search?: string, sortBy?: RangeBgpLinksListSortByEnum, sort?: RangeBgpLinksListSortEnum, options?: RawAxiosRequestConfig) {
        return RangeContentRangeBGPLinksApiFp(this.configuration).rangeBgpLinksList(uuid, name, description, author, metadata, node1, node1ASN, node2, node2ASN, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a range BGPLink
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeBGPLinksApi
     */
    public rangeBgpLinksRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentRangeBGPLinksApiFp(this.configuration).rangeBgpLinksRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a range BGPLink
     * @param {string} uuid 
     * @param {RangeBgpLinkUpdate} [rangeBgpLinkUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeBGPLinksApi
     */
    public rangeBgpLinksUpdate(uuid: string, rangeBgpLinkUpdate?: RangeBgpLinkUpdate, options?: RawAxiosRequestConfig) {
        return RangeContentRangeBGPLinksApiFp(this.configuration).rangeBgpLinksUpdate(uuid, rangeBgpLinkUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RangeBgpLinksListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author',
    Node1Asn: 'node1ASN',
    Node2Asn: 'node2ASN'
} as const;
export type RangeBgpLinksListSortByEnum = typeof RangeBgpLinksListSortByEnum[keyof typeof RangeBgpLinksListSortByEnum];
/**
 * @export
 */
export const RangeBgpLinksListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type RangeBgpLinksListSortEnum = typeof RangeBgpLinksListSortEnum[keyof typeof RangeBgpLinksListSortEnum];


/**
 * RangeContentRangeBGPsApi - axios parameter creator
 * @export
 */
export const RangeContentRangeBGPsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a range BGP
         * @param {RangeBgpCreate} [rangeBgpCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeBgPsCreate: async (rangeBgpCreate?: RangeBgpCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/range-bgps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeBgpCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a range BGP
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeBgPsDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeBgPsDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-bgps/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List range BGPs
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [asn] 
         * @param {string} [rangeRouter] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeBgPsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeBgPsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeBgPsList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, asn?: number, rangeRouter?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeBgPsListSortByEnum, sort?: RangeBgPsListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/range-bgps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (asn !== undefined) {
                localVarQueryParameter['asn'] = asn;
            }

            if (rangeRouter !== undefined) {
                localVarQueryParameter['rangeRouter'] = rangeRouter;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a range BGP
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeBgPsRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeBgPsRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-bgps/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a range BGP
         * @param {string} uuid 
         * @param {RangeBgpUpdate} [rangeBgpUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeBgPsUpdate: async (uuid: string, rangeBgpUpdate?: RangeBgpUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeBgPsUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-bgps/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeBgpUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RangeContentRangeBGPsApi - functional programming interface
 * @export
 */
export const RangeContentRangeBGPsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RangeContentRangeBGPsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a range BGP
         * @param {RangeBgpCreate} [rangeBgpCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeBgPsCreate(rangeBgpCreate?: RangeBgpCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeBGP>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeBgPsCreate(rangeBgpCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeBGPsApi.rangeBgPsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a range BGP
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeBgPsDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeBgPsDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeBGPsApi.rangeBgPsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List range BGPs
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [asn] 
         * @param {string} [rangeRouter] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeBgPsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeBgPsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeBgPsList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, asn?: number, rangeRouter?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeBgPsListSortByEnum, sort?: RangeBgPsListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeBgPsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeBgPsList(uuid, name, description, author, metadata, asn, rangeRouter, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeBGPsApi.rangeBgPsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a range BGP
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeBgPsRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeBGP>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeBgPsRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeBGPsApi.rangeBgPsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a range BGP
         * @param {string} uuid 
         * @param {RangeBgpUpdate} [rangeBgpUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeBgPsUpdate(uuid: string, rangeBgpUpdate?: RangeBgpUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeBGP>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeBgPsUpdate(uuid, rangeBgpUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeBGPsApi.rangeBgPsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RangeContentRangeBGPsApi - factory interface
 * @export
 */
export const RangeContentRangeBGPsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RangeContentRangeBGPsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a range BGP
         * @param {RangeBgpCreate} [rangeBgpCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeBgPsCreate(rangeBgpCreate?: RangeBgpCreate, options?: RawAxiosRequestConfig): AxiosPromise<RangeBGP> {
            return localVarFp.rangeBgPsCreate(rangeBgpCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a range BGP
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeBgPsDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rangeBgPsDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List range BGPs
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [asn] 
         * @param {string} [rangeRouter] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeBgPsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeBgPsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeBgPsList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, asn?: number, rangeRouter?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeBgPsListSortByEnum, sort?: RangeBgPsListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<RangeBgPsList200Response> {
            return localVarFp.rangeBgPsList(uuid, name, description, author, metadata, asn, rangeRouter, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a range BGP
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeBgPsRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<RangeBGP> {
            return localVarFp.rangeBgPsRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a range BGP
         * @param {string} uuid 
         * @param {RangeBgpUpdate} [rangeBgpUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeBgPsUpdate(uuid: string, rangeBgpUpdate?: RangeBgpUpdate, options?: RawAxiosRequestConfig): AxiosPromise<RangeBGP> {
            return localVarFp.rangeBgPsUpdate(uuid, rangeBgpUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RangeContentRangeBGPsApi - object-oriented interface
 * @export
 * @class RangeContentRangeBGPsApi
 * @extends {BaseAPI}
 */
export class RangeContentRangeBGPsApi extends BaseAPI {
    /**
     * 
     * @summary Create a range BGP
     * @param {RangeBgpCreate} [rangeBgpCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeBGPsApi
     */
    public rangeBgPsCreate(rangeBgpCreate?: RangeBgpCreate, options?: RawAxiosRequestConfig) {
        return RangeContentRangeBGPsApiFp(this.configuration).rangeBgPsCreate(rangeBgpCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a range BGP
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeBGPsApi
     */
    public rangeBgPsDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentRangeBGPsApiFp(this.configuration).rangeBgPsDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List range BGPs
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {number} [asn] 
     * @param {string} [rangeRouter] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {RangeBgPsListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {RangeBgPsListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeBGPsApi
     */
    public rangeBgPsList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, asn?: number, rangeRouter?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeBgPsListSortByEnum, sort?: RangeBgPsListSortEnum, options?: RawAxiosRequestConfig) {
        return RangeContentRangeBGPsApiFp(this.configuration).rangeBgPsList(uuid, name, description, author, metadata, asn, rangeRouter, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a range BGP
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeBGPsApi
     */
    public rangeBgPsRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentRangeBGPsApiFp(this.configuration).rangeBgPsRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a range BGP
     * @param {string} uuid 
     * @param {RangeBgpUpdate} [rangeBgpUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeBGPsApi
     */
    public rangeBgPsUpdate(uuid: string, rangeBgpUpdate?: RangeBgpUpdate, options?: RawAxiosRequestConfig) {
        return RangeContentRangeBGPsApiFp(this.configuration).rangeBgPsUpdate(uuid, rangeBgpUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RangeBgPsListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author',
    Asn: 'asn'
} as const;
export type RangeBgPsListSortByEnum = typeof RangeBgPsListSortByEnum[keyof typeof RangeBgPsListSortByEnum];
/**
 * @export
 */
export const RangeBgPsListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type RangeBgPsListSortEnum = typeof RangeBgPsListSortEnum[keyof typeof RangeBgPsListSortEnum];


/**
 * RangeContentRangeCertificatesApi - axios parameter creator
 * @export
 */
export const RangeContentRangeCertificatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a range certificate
         * @param {RangeCertCreate} [rangeCertCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeCertificatesCreate: async (rangeCertCreate?: RangeCertCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/range-certificates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeCertCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a range certificate
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeCertificatesDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeCertificatesDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-certificates/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List range certificates
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [cn] 
         * @param {string} [host] 
         * @param {string} [profile] 
         * @param {string} [rangePki] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeCertificatesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeCertificatesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeCertificatesList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, cn?: string, host?: string, profile?: string, rangePki?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeCertificatesListSortByEnum, sort?: RangeCertificatesListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/range-certificates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (cn !== undefined) {
                localVarQueryParameter['cn'] = cn;
            }

            if (host !== undefined) {
                localVarQueryParameter['host'] = host;
            }

            if (profile !== undefined) {
                localVarQueryParameter['profile'] = profile;
            }

            if (rangePki !== undefined) {
                localVarQueryParameter['rangePki'] = rangePki;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a range certificate
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeCertificatesRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeCertificatesRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-certificates/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a range certificate
         * @param {string} uuid 
         * @param {RangeCertUpdate} [rangeCertUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeCertificatesUpdate: async (uuid: string, rangeCertUpdate?: RangeCertUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeCertificatesUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-certificates/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeCertUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RangeContentRangeCertificatesApi - functional programming interface
 * @export
 */
export const RangeContentRangeCertificatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RangeContentRangeCertificatesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a range certificate
         * @param {RangeCertCreate} [rangeCertCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeCertificatesCreate(rangeCertCreate?: RangeCertCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeCert>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeCertificatesCreate(rangeCertCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeCertificatesApi.rangeCertificatesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a range certificate
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeCertificatesDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeCertificatesDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeCertificatesApi.rangeCertificatesDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List range certificates
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [cn] 
         * @param {string} [host] 
         * @param {string} [profile] 
         * @param {string} [rangePki] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeCertificatesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeCertificatesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeCertificatesList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, cn?: string, host?: string, profile?: string, rangePki?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeCertificatesListSortByEnum, sort?: RangeCertificatesListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeCertificatesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeCertificatesList(uuid, name, description, author, metadata, cn, host, profile, rangePki, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeCertificatesApi.rangeCertificatesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a range certificate
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeCertificatesRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeCert>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeCertificatesRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeCertificatesApi.rangeCertificatesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a range certificate
         * @param {string} uuid 
         * @param {RangeCertUpdate} [rangeCertUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeCertificatesUpdate(uuid: string, rangeCertUpdate?: RangeCertUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeCert>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeCertificatesUpdate(uuid, rangeCertUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeCertificatesApi.rangeCertificatesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RangeContentRangeCertificatesApi - factory interface
 * @export
 */
export const RangeContentRangeCertificatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RangeContentRangeCertificatesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a range certificate
         * @param {RangeCertCreate} [rangeCertCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeCertificatesCreate(rangeCertCreate?: RangeCertCreate, options?: RawAxiosRequestConfig): AxiosPromise<RangeCert> {
            return localVarFp.rangeCertificatesCreate(rangeCertCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a range certificate
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeCertificatesDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rangeCertificatesDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List range certificates
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [cn] 
         * @param {string} [host] 
         * @param {string} [profile] 
         * @param {string} [rangePki] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeCertificatesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeCertificatesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeCertificatesList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, cn?: string, host?: string, profile?: string, rangePki?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeCertificatesListSortByEnum, sort?: RangeCertificatesListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<RangeCertificatesList200Response> {
            return localVarFp.rangeCertificatesList(uuid, name, description, author, metadata, cn, host, profile, rangePki, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a range certificate
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeCertificatesRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<RangeCert> {
            return localVarFp.rangeCertificatesRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a range certificate
         * @param {string} uuid 
         * @param {RangeCertUpdate} [rangeCertUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeCertificatesUpdate(uuid: string, rangeCertUpdate?: RangeCertUpdate, options?: RawAxiosRequestConfig): AxiosPromise<RangeCert> {
            return localVarFp.rangeCertificatesUpdate(uuid, rangeCertUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RangeContentRangeCertificatesApi - object-oriented interface
 * @export
 * @class RangeContentRangeCertificatesApi
 * @extends {BaseAPI}
 */
export class RangeContentRangeCertificatesApi extends BaseAPI {
    /**
     * 
     * @summary Create a range certificate
     * @param {RangeCertCreate} [rangeCertCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeCertificatesApi
     */
    public rangeCertificatesCreate(rangeCertCreate?: RangeCertCreate, options?: RawAxiosRequestConfig) {
        return RangeContentRangeCertificatesApiFp(this.configuration).rangeCertificatesCreate(rangeCertCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a range certificate
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeCertificatesApi
     */
    public rangeCertificatesDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentRangeCertificatesApiFp(this.configuration).rangeCertificatesDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List range certificates
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {string} [cn] 
     * @param {string} [host] 
     * @param {string} [profile] 
     * @param {string} [rangePki] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {RangeCertificatesListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {RangeCertificatesListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeCertificatesApi
     */
    public rangeCertificatesList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, cn?: string, host?: string, profile?: string, rangePki?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeCertificatesListSortByEnum, sort?: RangeCertificatesListSortEnum, options?: RawAxiosRequestConfig) {
        return RangeContentRangeCertificatesApiFp(this.configuration).rangeCertificatesList(uuid, name, description, author, metadata, cn, host, profile, rangePki, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a range certificate
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeCertificatesApi
     */
    public rangeCertificatesRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentRangeCertificatesApiFp(this.configuration).rangeCertificatesRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a range certificate
     * @param {string} uuid 
     * @param {RangeCertUpdate} [rangeCertUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeCertificatesApi
     */
    public rangeCertificatesUpdate(uuid: string, rangeCertUpdate?: RangeCertUpdate, options?: RawAxiosRequestConfig) {
        return RangeContentRangeCertificatesApiFp(this.configuration).rangeCertificatesUpdate(uuid, rangeCertUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RangeCertificatesListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author',
    Cn: 'cn',
    RangePki: 'rangePki',
    Profile: 'profile'
} as const;
export type RangeCertificatesListSortByEnum = typeof RangeCertificatesListSortByEnum[keyof typeof RangeCertificatesListSortByEnum];
/**
 * @export
 */
export const RangeCertificatesListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type RangeCertificatesListSortEnum = typeof RangeCertificatesListSortEnum[keyof typeof RangeCertificatesListSortEnum];


/**
 * RangeContentRangeConsolesApi - axios parameter creator
 * @export
 */
export const RangeContentRangeConsolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a range console
         * @param {RangeConsoleCreate} [rangeConsoleCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeConsolesCreate: async (rangeConsoleCreate?: RangeConsoleCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/range-consoles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeConsoleCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a range console
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeConsolesDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeConsolesDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-consoles/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of existing range consoles
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeConsolesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeConsolesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeConsolesList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: RangeConsolesListSortByEnum, sort?: RangeConsolesListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/range-consoles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a range console
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeConsolesRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeConsolesRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-consoles/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a range console
         * @param {string} uuid 
         * @param {RangeConsoleUpdate} [rangeConsoleUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeConsolesUpdate: async (uuid: string, rangeConsoleUpdate?: RangeConsoleUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeConsolesUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-consoles/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeConsoleUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RangeContentRangeConsolesApi - functional programming interface
 * @export
 */
export const RangeContentRangeConsolesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RangeContentRangeConsolesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a range console
         * @param {RangeConsoleCreate} [rangeConsoleCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeConsolesCreate(rangeConsoleCreate?: RangeConsoleCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeConsole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeConsolesCreate(rangeConsoleCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeConsolesApi.rangeConsolesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a range console
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeConsolesDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeConsolesDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeConsolesApi.rangeConsolesDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List of existing range consoles
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeConsolesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeConsolesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeConsolesList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: RangeConsolesListSortByEnum, sort?: RangeConsolesListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeConsolesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeConsolesList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeConsolesApi.rangeConsolesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a range console
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeConsolesRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeConsole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeConsolesRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeConsolesApi.rangeConsolesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a range console
         * @param {string} uuid 
         * @param {RangeConsoleUpdate} [rangeConsoleUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeConsolesUpdate(uuid: string, rangeConsoleUpdate?: RangeConsoleUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeConsole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeConsolesUpdate(uuid, rangeConsoleUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeConsolesApi.rangeConsolesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RangeContentRangeConsolesApi - factory interface
 * @export
 */
export const RangeContentRangeConsolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RangeContentRangeConsolesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a range console
         * @param {RangeConsoleCreate} [rangeConsoleCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeConsolesCreate(rangeConsoleCreate?: RangeConsoleCreate, options?: RawAxiosRequestConfig): AxiosPromise<RangeConsole> {
            return localVarFp.rangeConsolesCreate(rangeConsoleCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a range console
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeConsolesDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rangeConsolesDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List of existing range consoles
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeConsolesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeConsolesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeConsolesList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: RangeConsolesListSortByEnum, sort?: RangeConsolesListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<RangeConsolesList200Response> {
            return localVarFp.rangeConsolesList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a range console
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeConsolesRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<RangeConsole> {
            return localVarFp.rangeConsolesRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a range console
         * @param {string} uuid 
         * @param {RangeConsoleUpdate} [rangeConsoleUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeConsolesUpdate(uuid: string, rangeConsoleUpdate?: RangeConsoleUpdate, options?: RawAxiosRequestConfig): AxiosPromise<RangeConsole> {
            return localVarFp.rangeConsolesUpdate(uuid, rangeConsoleUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RangeContentRangeConsolesApi - object-oriented interface
 * @export
 * @class RangeContentRangeConsolesApi
 * @extends {BaseAPI}
 */
export class RangeContentRangeConsolesApi extends BaseAPI {
    /**
     * 
     * @summary Create a range console
     * @param {RangeConsoleCreate} [rangeConsoleCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeConsolesApi
     */
    public rangeConsolesCreate(rangeConsoleCreate?: RangeConsoleCreate, options?: RawAxiosRequestConfig) {
        return RangeContentRangeConsolesApiFp(this.configuration).rangeConsolesCreate(rangeConsoleCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a range console
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeConsolesApi
     */
    public rangeConsolesDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentRangeConsolesApiFp(this.configuration).rangeConsolesDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List of existing range consoles
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {RangeConsolesListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {RangeConsolesListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeConsolesApi
     */
    public rangeConsolesList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: RangeConsolesListSortByEnum, sort?: RangeConsolesListSortEnum, options?: RawAxiosRequestConfig) {
        return RangeContentRangeConsolesApiFp(this.configuration).rangeConsolesList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a range console
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeConsolesApi
     */
    public rangeConsolesRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentRangeConsolesApiFp(this.configuration).rangeConsolesRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a range console
     * @param {string} uuid 
     * @param {RangeConsoleUpdate} [rangeConsoleUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeConsolesApi
     */
    public rangeConsolesUpdate(uuid: string, rangeConsoleUpdate?: RangeConsoleUpdate, options?: RawAxiosRequestConfig) {
        return RangeContentRangeConsolesApiFp(this.configuration).rangeConsolesUpdate(uuid, rangeConsoleUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RangeConsolesListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author',
    Url: 'url'
} as const;
export type RangeConsolesListSortByEnum = typeof RangeConsolesListSortByEnum[keyof typeof RangeConsolesListSortByEnum];
/**
 * @export
 */
export const RangeConsolesListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type RangeConsolesListSortEnum = typeof RangeConsolesListSortEnum[keyof typeof RangeConsolesListSortEnum];


/**
 * RangeContentRangeDNSRecordsApi - axios parameter creator
 * @export
 */
export const RangeContentRangeDNSRecordsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a range DNS record
         * @param {RangeDnsRecordCreate} [rangeDnsRecordCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeDnsRecordsCreate: async (rangeDnsRecordCreate?: RangeDnsRecordCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/range-dns-records`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeDnsRecordCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a range DNS record
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeDnsRecordsDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeDnsRecordsDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-dns-records/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List range DNS records
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [rangeDNSZone] 
         * @param {string} [recordClass] 
         * @param {string} [type] 
         * @param {string} [data] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeDnsRecordsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeDnsRecordsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeDnsRecordsList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, rangeDNSZone?: string, recordClass?: string, type?: string, data?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeDnsRecordsListSortByEnum, sort?: RangeDnsRecordsListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/range-dns-records`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (rangeDNSZone !== undefined) {
                localVarQueryParameter['rangeDNSZone'] = rangeDNSZone;
            }

            if (recordClass !== undefined) {
                localVarQueryParameter['recordClass'] = recordClass;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (data !== undefined) {
                localVarQueryParameter['data'] = data;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a range DNS record
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeDnsRecordsRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeDnsRecordsRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-dns-records/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a range DNS record
         * @param {string} uuid 
         * @param {RangeDnsRecordUpdate} [rangeDnsRecordUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeDnsRecordsUpdate: async (uuid: string, rangeDnsRecordUpdate?: RangeDnsRecordUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeDnsRecordsUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-dns-records/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeDnsRecordUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RangeContentRangeDNSRecordsApi - functional programming interface
 * @export
 */
export const RangeContentRangeDNSRecordsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RangeContentRangeDNSRecordsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a range DNS record
         * @param {RangeDnsRecordCreate} [rangeDnsRecordCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeDnsRecordsCreate(rangeDnsRecordCreate?: RangeDnsRecordCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeDNSRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeDnsRecordsCreate(rangeDnsRecordCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeDNSRecordsApi.rangeDnsRecordsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a range DNS record
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeDnsRecordsDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeDnsRecordsDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeDNSRecordsApi.rangeDnsRecordsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List range DNS records
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [rangeDNSZone] 
         * @param {string} [recordClass] 
         * @param {string} [type] 
         * @param {string} [data] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeDnsRecordsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeDnsRecordsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeDnsRecordsList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, rangeDNSZone?: string, recordClass?: string, type?: string, data?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeDnsRecordsListSortByEnum, sort?: RangeDnsRecordsListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeDnsRecordsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeDnsRecordsList(uuid, name, description, author, metadata, rangeDNSZone, recordClass, type, data, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeDNSRecordsApi.rangeDnsRecordsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a range DNS record
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeDnsRecordsRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeDNSRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeDnsRecordsRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeDNSRecordsApi.rangeDnsRecordsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a range DNS record
         * @param {string} uuid 
         * @param {RangeDnsRecordUpdate} [rangeDnsRecordUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeDnsRecordsUpdate(uuid: string, rangeDnsRecordUpdate?: RangeDnsRecordUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeDNSRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeDnsRecordsUpdate(uuid, rangeDnsRecordUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeDNSRecordsApi.rangeDnsRecordsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RangeContentRangeDNSRecordsApi - factory interface
 * @export
 */
export const RangeContentRangeDNSRecordsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RangeContentRangeDNSRecordsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a range DNS record
         * @param {RangeDnsRecordCreate} [rangeDnsRecordCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeDnsRecordsCreate(rangeDnsRecordCreate?: RangeDnsRecordCreate, options?: RawAxiosRequestConfig): AxiosPromise<RangeDNSRecord> {
            return localVarFp.rangeDnsRecordsCreate(rangeDnsRecordCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a range DNS record
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeDnsRecordsDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rangeDnsRecordsDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List range DNS records
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [rangeDNSZone] 
         * @param {string} [recordClass] 
         * @param {string} [type] 
         * @param {string} [data] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeDnsRecordsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeDnsRecordsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeDnsRecordsList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, rangeDNSZone?: string, recordClass?: string, type?: string, data?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeDnsRecordsListSortByEnum, sort?: RangeDnsRecordsListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<RangeDnsRecordsList200Response> {
            return localVarFp.rangeDnsRecordsList(uuid, name, description, author, metadata, rangeDNSZone, recordClass, type, data, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a range DNS record
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeDnsRecordsRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<RangeDNSRecord> {
            return localVarFp.rangeDnsRecordsRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a range DNS record
         * @param {string} uuid 
         * @param {RangeDnsRecordUpdate} [rangeDnsRecordUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeDnsRecordsUpdate(uuid: string, rangeDnsRecordUpdate?: RangeDnsRecordUpdate, options?: RawAxiosRequestConfig): AxiosPromise<RangeDNSRecord> {
            return localVarFp.rangeDnsRecordsUpdate(uuid, rangeDnsRecordUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RangeContentRangeDNSRecordsApi - object-oriented interface
 * @export
 * @class RangeContentRangeDNSRecordsApi
 * @extends {BaseAPI}
 */
export class RangeContentRangeDNSRecordsApi extends BaseAPI {
    /**
     * 
     * @summary Create a range DNS record
     * @param {RangeDnsRecordCreate} [rangeDnsRecordCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeDNSRecordsApi
     */
    public rangeDnsRecordsCreate(rangeDnsRecordCreate?: RangeDnsRecordCreate, options?: RawAxiosRequestConfig) {
        return RangeContentRangeDNSRecordsApiFp(this.configuration).rangeDnsRecordsCreate(rangeDnsRecordCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a range DNS record
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeDNSRecordsApi
     */
    public rangeDnsRecordsDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentRangeDNSRecordsApiFp(this.configuration).rangeDnsRecordsDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List range DNS records
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {string} [rangeDNSZone] 
     * @param {string} [recordClass] 
     * @param {string} [type] 
     * @param {string} [data] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {RangeDnsRecordsListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {RangeDnsRecordsListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeDNSRecordsApi
     */
    public rangeDnsRecordsList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, rangeDNSZone?: string, recordClass?: string, type?: string, data?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeDnsRecordsListSortByEnum, sort?: RangeDnsRecordsListSortEnum, options?: RawAxiosRequestConfig) {
        return RangeContentRangeDNSRecordsApiFp(this.configuration).rangeDnsRecordsList(uuid, name, description, author, metadata, rangeDNSZone, recordClass, type, data, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a range DNS record
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeDNSRecordsApi
     */
    public rangeDnsRecordsRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentRangeDNSRecordsApiFp(this.configuration).rangeDnsRecordsRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a range DNS record
     * @param {string} uuid 
     * @param {RangeDnsRecordUpdate} [rangeDnsRecordUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeDNSRecordsApi
     */
    public rangeDnsRecordsUpdate(uuid: string, rangeDnsRecordUpdate?: RangeDnsRecordUpdate, options?: RawAxiosRequestConfig) {
        return RangeContentRangeDNSRecordsApiFp(this.configuration).rangeDnsRecordsUpdate(uuid, rangeDnsRecordUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RangeDnsRecordsListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author',
    RecordClass: 'recordClass',
    Ttl: 'ttl',
    Type: 'type',
    Data: 'data'
} as const;
export type RangeDnsRecordsListSortByEnum = typeof RangeDnsRecordsListSortByEnum[keyof typeof RangeDnsRecordsListSortByEnum];
/**
 * @export
 */
export const RangeDnsRecordsListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type RangeDnsRecordsListSortEnum = typeof RangeDnsRecordsListSortEnum[keyof typeof RangeDnsRecordsListSortEnum];


/**
 * RangeContentRangeDNSServersApi - axios parameter creator
 * @export
 */
export const RangeContentRangeDNSServersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a range DNS server
         * @param {RangeDnsServerCreate} [rangeDnsServerCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeDnsServersCreate: async (rangeDnsServerCreate?: RangeDnsServerCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/range-dns-servers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeDnsServerCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a range DNS server
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeDnsServersDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeDnsServersDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-dns-servers/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List range DNS servers
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [type] 
         * @param {string} [tag] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeDnsServersListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeDnsServersListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeDnsServersList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, type?: string, tag?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeDnsServersListSortByEnum, sort?: RangeDnsServersListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/range-dns-servers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List range DNS server tags
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeDnsServersListTagSelectors: async (offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/range-dns-servers/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a range DNS server
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeDnsServersRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeDnsServersRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-dns-servers/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a range DNS server
         * @param {string} uuid 
         * @param {RangeDnsServerUpdate} [rangeDnsServerUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeDnsServersUpdate: async (uuid: string, rangeDnsServerUpdate?: RangeDnsServerUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeDnsServersUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-dns-servers/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeDnsServerUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RangeContentRangeDNSServersApi - functional programming interface
 * @export
 */
export const RangeContentRangeDNSServersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RangeContentRangeDNSServersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a range DNS server
         * @param {RangeDnsServerCreate} [rangeDnsServerCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeDnsServersCreate(rangeDnsServerCreate?: RangeDnsServerCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeDNSServer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeDnsServersCreate(rangeDnsServerCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeDNSServersApi.rangeDnsServersCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a range DNS server
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeDnsServersDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeDnsServersDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeDNSServersApi.rangeDnsServersDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List range DNS servers
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [type] 
         * @param {string} [tag] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeDnsServersListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeDnsServersListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeDnsServersList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, type?: string, tag?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeDnsServersListSortByEnum, sort?: RangeDnsServersListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeDnsServersList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeDnsServersList(uuid, name, description, author, metadata, type, tag, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeDNSServersApi.rangeDnsServersList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List range DNS server tags
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeDnsServersListTagSelectors(offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeDnsServersListTagSelectors200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeDnsServersListTagSelectors(offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeDNSServersApi.rangeDnsServersListTagSelectors']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a range DNS server
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeDnsServersRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeDNSServer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeDnsServersRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeDNSServersApi.rangeDnsServersRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a range DNS server
         * @param {string} uuid 
         * @param {RangeDnsServerUpdate} [rangeDnsServerUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeDnsServersUpdate(uuid: string, rangeDnsServerUpdate?: RangeDnsServerUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeDNSServer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeDnsServersUpdate(uuid, rangeDnsServerUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeDNSServersApi.rangeDnsServersUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RangeContentRangeDNSServersApi - factory interface
 * @export
 */
export const RangeContentRangeDNSServersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RangeContentRangeDNSServersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a range DNS server
         * @param {RangeDnsServerCreate} [rangeDnsServerCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeDnsServersCreate(rangeDnsServerCreate?: RangeDnsServerCreate, options?: RawAxiosRequestConfig): AxiosPromise<RangeDNSServer> {
            return localVarFp.rangeDnsServersCreate(rangeDnsServerCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a range DNS server
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeDnsServersDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rangeDnsServersDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List range DNS servers
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [type] 
         * @param {string} [tag] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeDnsServersListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeDnsServersListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeDnsServersList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, type?: string, tag?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeDnsServersListSortByEnum, sort?: RangeDnsServersListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<RangeDnsServersList200Response> {
            return localVarFp.rangeDnsServersList(uuid, name, description, author, metadata, type, tag, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List range DNS server tags
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeDnsServersListTagSelectors(offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<RangeDnsServersListTagSelectors200Response> {
            return localVarFp.rangeDnsServersListTagSelectors(offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a range DNS server
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeDnsServersRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<RangeDNSServer> {
            return localVarFp.rangeDnsServersRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a range DNS server
         * @param {string} uuid 
         * @param {RangeDnsServerUpdate} [rangeDnsServerUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeDnsServersUpdate(uuid: string, rangeDnsServerUpdate?: RangeDnsServerUpdate, options?: RawAxiosRequestConfig): AxiosPromise<RangeDNSServer> {
            return localVarFp.rangeDnsServersUpdate(uuid, rangeDnsServerUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RangeContentRangeDNSServersApi - object-oriented interface
 * @export
 * @class RangeContentRangeDNSServersApi
 * @extends {BaseAPI}
 */
export class RangeContentRangeDNSServersApi extends BaseAPI {
    /**
     * 
     * @summary Create a range DNS server
     * @param {RangeDnsServerCreate} [rangeDnsServerCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeDNSServersApi
     */
    public rangeDnsServersCreate(rangeDnsServerCreate?: RangeDnsServerCreate, options?: RawAxiosRequestConfig) {
        return RangeContentRangeDNSServersApiFp(this.configuration).rangeDnsServersCreate(rangeDnsServerCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a range DNS server
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeDNSServersApi
     */
    public rangeDnsServersDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentRangeDNSServersApiFp(this.configuration).rangeDnsServersDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List range DNS servers
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {string} [type] 
     * @param {string} [tag] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {RangeDnsServersListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {RangeDnsServersListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeDNSServersApi
     */
    public rangeDnsServersList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, type?: string, tag?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeDnsServersListSortByEnum, sort?: RangeDnsServersListSortEnum, options?: RawAxiosRequestConfig) {
        return RangeContentRangeDNSServersApiFp(this.configuration).rangeDnsServersList(uuid, name, description, author, metadata, type, tag, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List range DNS server tags
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeDNSServersApi
     */
    public rangeDnsServersListTagSelectors(offset?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return RangeContentRangeDNSServersApiFp(this.configuration).rangeDnsServersListTagSelectors(offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a range DNS server
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeDNSServersApi
     */
    public rangeDnsServersRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentRangeDNSServersApiFp(this.configuration).rangeDnsServersRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a range DNS server
     * @param {string} uuid 
     * @param {RangeDnsServerUpdate} [rangeDnsServerUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeDNSServersApi
     */
    public rangeDnsServersUpdate(uuid: string, rangeDnsServerUpdate?: RangeDnsServerUpdate, options?: RawAxiosRequestConfig) {
        return RangeContentRangeDNSServersApiFp(this.configuration).rangeDnsServersUpdate(uuid, rangeDnsServerUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RangeDnsServersListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author',
    Type: 'type'
} as const;
export type RangeDnsServersListSortByEnum = typeof RangeDnsServersListSortByEnum[keyof typeof RangeDnsServersListSortByEnum];
/**
 * @export
 */
export const RangeDnsServersListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type RangeDnsServersListSortEnum = typeof RangeDnsServersListSortEnum[keyof typeof RangeDnsServersListSortEnum];


/**
 * RangeContentRangeDNSZonesApi - axios parameter creator
 * @export
 */
export const RangeContentRangeDNSZonesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a range DNS zone
         * @param {RangeDnsZoneCreate} [rangeDnsZoneCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeDnsZonesCreate: async (rangeDnsZoneCreate?: RangeDnsZoneCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/range-dns-zones`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeDnsZoneCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a range DNS zone
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeDnsZonesDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeDnsZonesDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-dns-zones/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List range DNS zones
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [masterNs] 
         * @param {string} [email] 
         * @param {string} [tagSelector] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeDnsZonesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeDnsZonesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeDnsZonesList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, masterNs?: string, email?: string, tagSelector?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeDnsZonesListSortByEnum, sort?: RangeDnsZonesListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/range-dns-zones`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (masterNs !== undefined) {
                localVarQueryParameter['masterNs'] = masterNs;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (tagSelector !== undefined) {
                localVarQueryParameter['tagSelector'] = tagSelector;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List range DNS zone tag selectors
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeDnsZonesListTagSelectors: async (offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/range-dns-zones/tag-selectors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a range DNS zone
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeDnsZonesRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeDnsZonesRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-dns-zones/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a range DNS zone
         * @param {string} uuid 
         * @param {RangeDnsZoneUpdate} [rangeDnsZoneUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeDnsZonesUpdate: async (uuid: string, rangeDnsZoneUpdate?: RangeDnsZoneUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeDnsZonesUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-dns-zones/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeDnsZoneUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RangeContentRangeDNSZonesApi - functional programming interface
 * @export
 */
export const RangeContentRangeDNSZonesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RangeContentRangeDNSZonesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a range DNS zone
         * @param {RangeDnsZoneCreate} [rangeDnsZoneCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeDnsZonesCreate(rangeDnsZoneCreate?: RangeDnsZoneCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeDNSZone>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeDnsZonesCreate(rangeDnsZoneCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeDNSZonesApi.rangeDnsZonesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a range DNS zone
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeDnsZonesDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeDnsZonesDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeDNSZonesApi.rangeDnsZonesDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List range DNS zones
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [masterNs] 
         * @param {string} [email] 
         * @param {string} [tagSelector] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeDnsZonesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeDnsZonesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeDnsZonesList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, masterNs?: string, email?: string, tagSelector?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeDnsZonesListSortByEnum, sort?: RangeDnsZonesListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeDnsZonesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeDnsZonesList(uuid, name, description, author, metadata, masterNs, email, tagSelector, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeDNSZonesApi.rangeDnsZonesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List range DNS zone tag selectors
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeDnsZonesListTagSelectors(offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeDnsServersListTagSelectors200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeDnsZonesListTagSelectors(offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeDNSZonesApi.rangeDnsZonesListTagSelectors']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a range DNS zone
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeDnsZonesRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeDNSZone>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeDnsZonesRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeDNSZonesApi.rangeDnsZonesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a range DNS zone
         * @param {string} uuid 
         * @param {RangeDnsZoneUpdate} [rangeDnsZoneUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeDnsZonesUpdate(uuid: string, rangeDnsZoneUpdate?: RangeDnsZoneUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeDNSZone>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeDnsZonesUpdate(uuid, rangeDnsZoneUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeDNSZonesApi.rangeDnsZonesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RangeContentRangeDNSZonesApi - factory interface
 * @export
 */
export const RangeContentRangeDNSZonesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RangeContentRangeDNSZonesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a range DNS zone
         * @param {RangeDnsZoneCreate} [rangeDnsZoneCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeDnsZonesCreate(rangeDnsZoneCreate?: RangeDnsZoneCreate, options?: RawAxiosRequestConfig): AxiosPromise<RangeDNSZone> {
            return localVarFp.rangeDnsZonesCreate(rangeDnsZoneCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a range DNS zone
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeDnsZonesDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rangeDnsZonesDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List range DNS zones
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [masterNs] 
         * @param {string} [email] 
         * @param {string} [tagSelector] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeDnsZonesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeDnsZonesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeDnsZonesList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, masterNs?: string, email?: string, tagSelector?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeDnsZonesListSortByEnum, sort?: RangeDnsZonesListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<RangeDnsZonesList200Response> {
            return localVarFp.rangeDnsZonesList(uuid, name, description, author, metadata, masterNs, email, tagSelector, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List range DNS zone tag selectors
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeDnsZonesListTagSelectors(offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<RangeDnsServersListTagSelectors200Response> {
            return localVarFp.rangeDnsZonesListTagSelectors(offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a range DNS zone
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeDnsZonesRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<RangeDNSZone> {
            return localVarFp.rangeDnsZonesRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a range DNS zone
         * @param {string} uuid 
         * @param {RangeDnsZoneUpdate} [rangeDnsZoneUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeDnsZonesUpdate(uuid: string, rangeDnsZoneUpdate?: RangeDnsZoneUpdate, options?: RawAxiosRequestConfig): AxiosPromise<RangeDNSZone> {
            return localVarFp.rangeDnsZonesUpdate(uuid, rangeDnsZoneUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RangeContentRangeDNSZonesApi - object-oriented interface
 * @export
 * @class RangeContentRangeDNSZonesApi
 * @extends {BaseAPI}
 */
export class RangeContentRangeDNSZonesApi extends BaseAPI {
    /**
     * 
     * @summary Create a range DNS zone
     * @param {RangeDnsZoneCreate} [rangeDnsZoneCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeDNSZonesApi
     */
    public rangeDnsZonesCreate(rangeDnsZoneCreate?: RangeDnsZoneCreate, options?: RawAxiosRequestConfig) {
        return RangeContentRangeDNSZonesApiFp(this.configuration).rangeDnsZonesCreate(rangeDnsZoneCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a range DNS zone
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeDNSZonesApi
     */
    public rangeDnsZonesDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentRangeDNSZonesApiFp(this.configuration).rangeDnsZonesDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List range DNS zones
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {string} [masterNs] 
     * @param {string} [email] 
     * @param {string} [tagSelector] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {RangeDnsZonesListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {RangeDnsZonesListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeDNSZonesApi
     */
    public rangeDnsZonesList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, masterNs?: string, email?: string, tagSelector?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeDnsZonesListSortByEnum, sort?: RangeDnsZonesListSortEnum, options?: RawAxiosRequestConfig) {
        return RangeContentRangeDNSZonesApiFp(this.configuration).rangeDnsZonesList(uuid, name, description, author, metadata, masterNs, email, tagSelector, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List range DNS zone tag selectors
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeDNSZonesApi
     */
    public rangeDnsZonesListTagSelectors(offset?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return RangeContentRangeDNSZonesApiFp(this.configuration).rangeDnsZonesListTagSelectors(offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a range DNS zone
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeDNSZonesApi
     */
    public rangeDnsZonesRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentRangeDNSZonesApiFp(this.configuration).rangeDnsZonesRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a range DNS zone
     * @param {string} uuid 
     * @param {RangeDnsZoneUpdate} [rangeDnsZoneUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeDNSZonesApi
     */
    public rangeDnsZonesUpdate(uuid: string, rangeDnsZoneUpdate?: RangeDnsZoneUpdate, options?: RawAxiosRequestConfig) {
        return RangeContentRangeDNSZonesApiFp(this.configuration).rangeDnsZonesUpdate(uuid, rangeDnsZoneUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RangeDnsZonesListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author'
} as const;
export type RangeDnsZonesListSortByEnum = typeof RangeDnsZonesListSortByEnum[keyof typeof RangeDnsZonesListSortByEnum];
/**
 * @export
 */
export const RangeDnsZonesListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type RangeDnsZonesListSortEnum = typeof RangeDnsZonesListSortEnum[keyof typeof RangeDnsZonesListSortEnum];


/**
 * RangeContentRangeHostNetworksApi - axios parameter creator
 * @export
 */
export const RangeContentRangeHostNetworksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a range host network
         * @param {RangeHostNetworkCreate} [rangeHostNetworkCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeHostNetworksCreate: async (rangeHostNetworkCreate?: RangeHostNetworkCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/range-host-networks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeHostNetworkCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a range host network
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeHostNetworksDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeHostNetworksDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-host-networks/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List range host networks
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeHostNetworksListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeHostNetworksListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeHostNetworksList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: RangeHostNetworksListSortByEnum, sort?: RangeHostNetworksListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/range-host-networks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a range host network
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeHostNetworksRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeHostNetworksRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-host-networks/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a range host network
         * @param {string} uuid 
         * @param {RangeHostNetworkUpdate} [rangeHostNetworkUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeHostNetworksUpdate: async (uuid: string, rangeHostNetworkUpdate?: RangeHostNetworkUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeHostNetworksUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-host-networks/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeHostNetworkUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RangeContentRangeHostNetworksApi - functional programming interface
 * @export
 */
export const RangeContentRangeHostNetworksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RangeContentRangeHostNetworksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a range host network
         * @param {RangeHostNetworkCreate} [rangeHostNetworkCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeHostNetworksCreate(rangeHostNetworkCreate?: RangeHostNetworkCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeHostNetwork>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeHostNetworksCreate(rangeHostNetworkCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeHostNetworksApi.rangeHostNetworksCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a range host network
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeHostNetworksDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeHostNetworksDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeHostNetworksApi.rangeHostNetworksDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List range host networks
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeHostNetworksListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeHostNetworksListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeHostNetworksList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: RangeHostNetworksListSortByEnum, sort?: RangeHostNetworksListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeHostNetworksList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeHostNetworksList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeHostNetworksApi.rangeHostNetworksList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a range host network
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeHostNetworksRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeHostNetwork>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeHostNetworksRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeHostNetworksApi.rangeHostNetworksRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a range host network
         * @param {string} uuid 
         * @param {RangeHostNetworkUpdate} [rangeHostNetworkUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeHostNetworksUpdate(uuid: string, rangeHostNetworkUpdate?: RangeHostNetworkUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeHostNetwork>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeHostNetworksUpdate(uuid, rangeHostNetworkUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeHostNetworksApi.rangeHostNetworksUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RangeContentRangeHostNetworksApi - factory interface
 * @export
 */
export const RangeContentRangeHostNetworksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RangeContentRangeHostNetworksApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a range host network
         * @param {RangeHostNetworkCreate} [rangeHostNetworkCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeHostNetworksCreate(rangeHostNetworkCreate?: RangeHostNetworkCreate, options?: RawAxiosRequestConfig): AxiosPromise<RangeHostNetwork> {
            return localVarFp.rangeHostNetworksCreate(rangeHostNetworkCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a range host network
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeHostNetworksDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rangeHostNetworksDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List range host networks
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeHostNetworksListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeHostNetworksListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeHostNetworksList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: RangeHostNetworksListSortByEnum, sort?: RangeHostNetworksListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<RangeHostNetworksList200Response> {
            return localVarFp.rangeHostNetworksList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a range host network
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeHostNetworksRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<RangeHostNetwork> {
            return localVarFp.rangeHostNetworksRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a range host network
         * @param {string} uuid 
         * @param {RangeHostNetworkUpdate} [rangeHostNetworkUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeHostNetworksUpdate(uuid: string, rangeHostNetworkUpdate?: RangeHostNetworkUpdate, options?: RawAxiosRequestConfig): AxiosPromise<RangeHostNetwork> {
            return localVarFp.rangeHostNetworksUpdate(uuid, rangeHostNetworkUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RangeContentRangeHostNetworksApi - object-oriented interface
 * @export
 * @class RangeContentRangeHostNetworksApi
 * @extends {BaseAPI}
 */
export class RangeContentRangeHostNetworksApi extends BaseAPI {
    /**
     * 
     * @summary Create a range host network
     * @param {RangeHostNetworkCreate} [rangeHostNetworkCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeHostNetworksApi
     */
    public rangeHostNetworksCreate(rangeHostNetworkCreate?: RangeHostNetworkCreate, options?: RawAxiosRequestConfig) {
        return RangeContentRangeHostNetworksApiFp(this.configuration).rangeHostNetworksCreate(rangeHostNetworkCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a range host network
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeHostNetworksApi
     */
    public rangeHostNetworksDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentRangeHostNetworksApiFp(this.configuration).rangeHostNetworksDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List range host networks
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {RangeHostNetworksListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {RangeHostNetworksListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeHostNetworksApi
     */
    public rangeHostNetworksList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: RangeHostNetworksListSortByEnum, sort?: RangeHostNetworksListSortEnum, options?: RawAxiosRequestConfig) {
        return RangeContentRangeHostNetworksApiFp(this.configuration).rangeHostNetworksList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a range host network
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeHostNetworksApi
     */
    public rangeHostNetworksRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentRangeHostNetworksApiFp(this.configuration).rangeHostNetworksRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a range host network
     * @param {string} uuid 
     * @param {RangeHostNetworkUpdate} [rangeHostNetworkUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeHostNetworksApi
     */
    public rangeHostNetworksUpdate(uuid: string, rangeHostNetworkUpdate?: RangeHostNetworkUpdate, options?: RawAxiosRequestConfig) {
        return RangeContentRangeHostNetworksApiFp(this.configuration).rangeHostNetworksUpdate(uuid, rangeHostNetworkUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RangeHostNetworksListSortByEnum = {
    Author: 'author',
    Description: 'description',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Name: 'name'
} as const;
export type RangeHostNetworksListSortByEnum = typeof RangeHostNetworksListSortByEnum[keyof typeof RangeHostNetworksListSortByEnum];
/**
 * @export
 */
export const RangeHostNetworksListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type RangeHostNetworksListSortEnum = typeof RangeHostNetworksListSortEnum[keyof typeof RangeHostNetworksListSortEnum];


/**
 * RangeContentRangeIPsApi - axios parameter creator
 * @export
 */
export const RangeContentRangeIPsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a range IP
         * @param {RangeIpCreate} [rangeIpCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeIPsCreate: async (rangeIpCreate?: RangeIpCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/range-ips`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeIpCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a range IP
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeIPsDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeIPsDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-ips/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List range IPs
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [address] 
         * @param {string} [countryCode] 
         * @param {boolean} [controlNet] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeIPsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeIPsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeIPsList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, address?: string, countryCode?: string, controlNet?: boolean, offset?: number, limit?: number, search?: string, sortBy?: RangeIPsListSortByEnum, sort?: RangeIPsListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/range-ips`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (countryCode !== undefined) {
                localVarQueryParameter['countryCode'] = countryCode;
            }

            if (controlNet !== undefined) {
                localVarQueryParameter['controlNet'] = controlNet;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a range IP
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeIPsRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeIPsRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-ips/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a range IP
         * @param {string} uuid 
         * @param {RangeIpUpdate} [rangeIpUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeIPsUpdate: async (uuid: string, rangeIpUpdate?: RangeIpUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeIPsUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-ips/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeIpUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RangeContentRangeIPsApi - functional programming interface
 * @export
 */
export const RangeContentRangeIPsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RangeContentRangeIPsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a range IP
         * @param {RangeIpCreate} [rangeIpCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeIPsCreate(rangeIpCreate?: RangeIpCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeIP>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeIPsCreate(rangeIpCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeIPsApi.rangeIPsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a range IP
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeIPsDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeIPsDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeIPsApi.rangeIPsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List range IPs
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [address] 
         * @param {string} [countryCode] 
         * @param {boolean} [controlNet] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeIPsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeIPsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeIPsList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, address?: string, countryCode?: string, controlNet?: boolean, offset?: number, limit?: number, search?: string, sortBy?: RangeIPsListSortByEnum, sort?: RangeIPsListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeIPsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeIPsList(uuid, name, description, author, metadata, address, countryCode, controlNet, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeIPsApi.rangeIPsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a range IP
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeIPsRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeIP>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeIPsRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeIPsApi.rangeIPsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a range IP
         * @param {string} uuid 
         * @param {RangeIpUpdate} [rangeIpUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeIPsUpdate(uuid: string, rangeIpUpdate?: RangeIpUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeIP>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeIPsUpdate(uuid, rangeIpUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeIPsApi.rangeIPsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RangeContentRangeIPsApi - factory interface
 * @export
 */
export const RangeContentRangeIPsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RangeContentRangeIPsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a range IP
         * @param {RangeIpCreate} [rangeIpCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeIPsCreate(rangeIpCreate?: RangeIpCreate, options?: RawAxiosRequestConfig): AxiosPromise<RangeIP> {
            return localVarFp.rangeIPsCreate(rangeIpCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a range IP
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeIPsDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rangeIPsDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List range IPs
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [address] 
         * @param {string} [countryCode] 
         * @param {boolean} [controlNet] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeIPsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeIPsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeIPsList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, address?: string, countryCode?: string, controlNet?: boolean, offset?: number, limit?: number, search?: string, sortBy?: RangeIPsListSortByEnum, sort?: RangeIPsListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<RangeIPsList200Response> {
            return localVarFp.rangeIPsList(uuid, name, description, author, metadata, address, countryCode, controlNet, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a range IP
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeIPsRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<RangeIP> {
            return localVarFp.rangeIPsRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a range IP
         * @param {string} uuid 
         * @param {RangeIpUpdate} [rangeIpUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeIPsUpdate(uuid: string, rangeIpUpdate?: RangeIpUpdate, options?: RawAxiosRequestConfig): AxiosPromise<RangeIP> {
            return localVarFp.rangeIPsUpdate(uuid, rangeIpUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RangeContentRangeIPsApi - object-oriented interface
 * @export
 * @class RangeContentRangeIPsApi
 * @extends {BaseAPI}
 */
export class RangeContentRangeIPsApi extends BaseAPI {
    /**
     * 
     * @summary Create a range IP
     * @param {RangeIpCreate} [rangeIpCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeIPsApi
     */
    public rangeIPsCreate(rangeIpCreate?: RangeIpCreate, options?: RawAxiosRequestConfig) {
        return RangeContentRangeIPsApiFp(this.configuration).rangeIPsCreate(rangeIpCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a range IP
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeIPsApi
     */
    public rangeIPsDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentRangeIPsApiFp(this.configuration).rangeIPsDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List range IPs
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {string} [address] 
     * @param {string} [countryCode] 
     * @param {boolean} [controlNet] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {RangeIPsListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {RangeIPsListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeIPsApi
     */
    public rangeIPsList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, address?: string, countryCode?: string, controlNet?: boolean, offset?: number, limit?: number, search?: string, sortBy?: RangeIPsListSortByEnum, sort?: RangeIPsListSortEnum, options?: RawAxiosRequestConfig) {
        return RangeContentRangeIPsApiFp(this.configuration).rangeIPsList(uuid, name, description, author, metadata, address, countryCode, controlNet, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a range IP
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeIPsApi
     */
    public rangeIPsRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentRangeIPsApiFp(this.configuration).rangeIPsRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a range IP
     * @param {string} uuid 
     * @param {RangeIpUpdate} [rangeIpUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeIPsApi
     */
    public rangeIPsUpdate(uuid: string, rangeIpUpdate?: RangeIpUpdate, options?: RawAxiosRequestConfig) {
        return RangeContentRangeIPsApiFp(this.configuration).rangeIPsUpdate(uuid, rangeIpUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RangeIPsListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author',
    Address: 'address',
    CountryCode: 'countryCode'
} as const;
export type RangeIPsListSortByEnum = typeof RangeIPsListSortByEnum[keyof typeof RangeIPsListSortByEnum];
/**
 * @export
 */
export const RangeIPsListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type RangeIPsListSortEnum = typeof RangeIPsListSortEnum[keyof typeof RangeIPsListSortEnum];


/**
 * RangeContentRangeL3NetworksApi - axios parameter creator
 * @export
 */
export const RangeContentRangeL3NetworksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a range L3 network
         * @param {RangeL3NetworkCreate} [rangeL3NetworkCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeL3NetworksCreate: async (rangeL3NetworkCreate?: RangeL3NetworkCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/range-l3-networks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeL3NetworkCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a range L3 network
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeL3NetworksDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeL3NetworksDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-l3-networks/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List range L3 networks
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [cidr] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeL3NetworksListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeL3NetworksListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeL3NetworksList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, cidr?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeL3NetworksListSortByEnum, sort?: RangeL3NetworksListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/range-l3-networks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (cidr !== undefined) {
                localVarQueryParameter['cidr'] = cidr;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a range L3 network
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeL3NetworksRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeL3NetworksRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-l3-networks/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a range L3 network
         * @param {string} uuid 
         * @param {RangeL3NetworkUpdate} [rangeL3NetworkUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeL3NetworksUpdate: async (uuid: string, rangeL3NetworkUpdate?: RangeL3NetworkUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeL3NetworksUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-l3-networks/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeL3NetworkUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RangeContentRangeL3NetworksApi - functional programming interface
 * @export
 */
export const RangeContentRangeL3NetworksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RangeContentRangeL3NetworksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a range L3 network
         * @param {RangeL3NetworkCreate} [rangeL3NetworkCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeL3NetworksCreate(rangeL3NetworkCreate?: RangeL3NetworkCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeL3Network>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeL3NetworksCreate(rangeL3NetworkCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeL3NetworksApi.rangeL3NetworksCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a range L3 network
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeL3NetworksDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeL3NetworksDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeL3NetworksApi.rangeL3NetworksDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List range L3 networks
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [cidr] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeL3NetworksListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeL3NetworksListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeL3NetworksList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, cidr?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeL3NetworksListSortByEnum, sort?: RangeL3NetworksListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeL3NetworksList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeL3NetworksList(uuid, name, description, author, metadata, cidr, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeL3NetworksApi.rangeL3NetworksList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a range L3 network
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeL3NetworksRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeL3Network>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeL3NetworksRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeL3NetworksApi.rangeL3NetworksRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a range L3 network
         * @param {string} uuid 
         * @param {RangeL3NetworkUpdate} [rangeL3NetworkUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeL3NetworksUpdate(uuid: string, rangeL3NetworkUpdate?: RangeL3NetworkUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeL3Network>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeL3NetworksUpdate(uuid, rangeL3NetworkUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeL3NetworksApi.rangeL3NetworksUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RangeContentRangeL3NetworksApi - factory interface
 * @export
 */
export const RangeContentRangeL3NetworksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RangeContentRangeL3NetworksApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a range L3 network
         * @param {RangeL3NetworkCreate} [rangeL3NetworkCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeL3NetworksCreate(rangeL3NetworkCreate?: RangeL3NetworkCreate, options?: RawAxiosRequestConfig): AxiosPromise<RangeL3Network> {
            return localVarFp.rangeL3NetworksCreate(rangeL3NetworkCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a range L3 network
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeL3NetworksDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rangeL3NetworksDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List range L3 networks
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [cidr] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeL3NetworksListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeL3NetworksListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeL3NetworksList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, cidr?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeL3NetworksListSortByEnum, sort?: RangeL3NetworksListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<RangeL3NetworksList200Response> {
            return localVarFp.rangeL3NetworksList(uuid, name, description, author, metadata, cidr, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a range L3 network
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeL3NetworksRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<RangeL3Network> {
            return localVarFp.rangeL3NetworksRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a range L3 network
         * @param {string} uuid 
         * @param {RangeL3NetworkUpdate} [rangeL3NetworkUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeL3NetworksUpdate(uuid: string, rangeL3NetworkUpdate?: RangeL3NetworkUpdate, options?: RawAxiosRequestConfig): AxiosPromise<RangeL3Network> {
            return localVarFp.rangeL3NetworksUpdate(uuid, rangeL3NetworkUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RangeContentRangeL3NetworksApi - object-oriented interface
 * @export
 * @class RangeContentRangeL3NetworksApi
 * @extends {BaseAPI}
 */
export class RangeContentRangeL3NetworksApi extends BaseAPI {
    /**
     * 
     * @summary Create a range L3 network
     * @param {RangeL3NetworkCreate} [rangeL3NetworkCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeL3NetworksApi
     */
    public rangeL3NetworksCreate(rangeL3NetworkCreate?: RangeL3NetworkCreate, options?: RawAxiosRequestConfig) {
        return RangeContentRangeL3NetworksApiFp(this.configuration).rangeL3NetworksCreate(rangeL3NetworkCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a range L3 network
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeL3NetworksApi
     */
    public rangeL3NetworksDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentRangeL3NetworksApiFp(this.configuration).rangeL3NetworksDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List range L3 networks
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {string} [cidr] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {RangeL3NetworksListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {RangeL3NetworksListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeL3NetworksApi
     */
    public rangeL3NetworksList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, cidr?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeL3NetworksListSortByEnum, sort?: RangeL3NetworksListSortEnum, options?: RawAxiosRequestConfig) {
        return RangeContentRangeL3NetworksApiFp(this.configuration).rangeL3NetworksList(uuid, name, description, author, metadata, cidr, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a range L3 network
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeL3NetworksApi
     */
    public rangeL3NetworksRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentRangeL3NetworksApiFp(this.configuration).rangeL3NetworksRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a range L3 network
     * @param {string} uuid 
     * @param {RangeL3NetworkUpdate} [rangeL3NetworkUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeL3NetworksApi
     */
    public rangeL3NetworksUpdate(uuid: string, rangeL3NetworkUpdate?: RangeL3NetworkUpdate, options?: RawAxiosRequestConfig) {
        return RangeContentRangeL3NetworksApiFp(this.configuration).rangeL3NetworksUpdate(uuid, rangeL3NetworkUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RangeL3NetworksListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author',
    Cidr: 'cidr'
} as const;
export type RangeL3NetworksListSortByEnum = typeof RangeL3NetworksListSortByEnum[keyof typeof RangeL3NetworksListSortByEnum];
/**
 * @export
 */
export const RangeL3NetworksListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type RangeL3NetworksListSortEnum = typeof RangeL3NetworksListSortEnum[keyof typeof RangeL3NetworksListSortEnum];


/**
 * RangeContentRangeNetworksApi - axios parameter creator
 * @export
 */
export const RangeContentRangeNetworksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a range network
         * @param {RangeNetworkCreate} [rangeNetworkCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeNetworksCreate: async (rangeNetworkCreate?: RangeNetworkCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/range-networks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeNetworkCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a range network
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeNetworksDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeNetworksDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-networks/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List range networks
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeNetworksListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeNetworksListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeNetworksList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: RangeNetworksListSortByEnum, sort?: RangeNetworksListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/range-networks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a range network
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeNetworksRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeNetworksRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-networks/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a range network
         * @param {string} uuid 
         * @param {RangeNetworkUpdate} [rangeNetworkUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeNetworksUpdate: async (uuid: string, rangeNetworkUpdate?: RangeNetworkUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeNetworksUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-networks/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeNetworkUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RangeContentRangeNetworksApi - functional programming interface
 * @export
 */
export const RangeContentRangeNetworksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RangeContentRangeNetworksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a range network
         * @param {RangeNetworkCreate} [rangeNetworkCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeNetworksCreate(rangeNetworkCreate?: RangeNetworkCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeNetwork>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeNetworksCreate(rangeNetworkCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeNetworksApi.rangeNetworksCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a range network
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeNetworksDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeNetworksDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeNetworksApi.rangeNetworksDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List range networks
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeNetworksListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeNetworksListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeNetworksList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: RangeNetworksListSortByEnum, sort?: RangeNetworksListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeNetworksList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeNetworksList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeNetworksApi.rangeNetworksList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a range network
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeNetworksRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeNetwork>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeNetworksRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeNetworksApi.rangeNetworksRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a range network
         * @param {string} uuid 
         * @param {RangeNetworkUpdate} [rangeNetworkUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeNetworksUpdate(uuid: string, rangeNetworkUpdate?: RangeNetworkUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeNetwork>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeNetworksUpdate(uuid, rangeNetworkUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeNetworksApi.rangeNetworksUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RangeContentRangeNetworksApi - factory interface
 * @export
 */
export const RangeContentRangeNetworksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RangeContentRangeNetworksApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a range network
         * @param {RangeNetworkCreate} [rangeNetworkCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeNetworksCreate(rangeNetworkCreate?: RangeNetworkCreate, options?: RawAxiosRequestConfig): AxiosPromise<RangeNetwork> {
            return localVarFp.rangeNetworksCreate(rangeNetworkCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a range network
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeNetworksDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rangeNetworksDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List range networks
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeNetworksListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeNetworksListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeNetworksList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: RangeNetworksListSortByEnum, sort?: RangeNetworksListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<RangeNetworksList200Response> {
            return localVarFp.rangeNetworksList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a range network
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeNetworksRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<RangeNetwork> {
            return localVarFp.rangeNetworksRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a range network
         * @param {string} uuid 
         * @param {RangeNetworkUpdate} [rangeNetworkUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeNetworksUpdate(uuid: string, rangeNetworkUpdate?: RangeNetworkUpdate, options?: RawAxiosRequestConfig): AxiosPromise<RangeNetwork> {
            return localVarFp.rangeNetworksUpdate(uuid, rangeNetworkUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RangeContentRangeNetworksApi - object-oriented interface
 * @export
 * @class RangeContentRangeNetworksApi
 * @extends {BaseAPI}
 */
export class RangeContentRangeNetworksApi extends BaseAPI {
    /**
     * 
     * @summary Create a range network
     * @param {RangeNetworkCreate} [rangeNetworkCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeNetworksApi
     */
    public rangeNetworksCreate(rangeNetworkCreate?: RangeNetworkCreate, options?: RawAxiosRequestConfig) {
        return RangeContentRangeNetworksApiFp(this.configuration).rangeNetworksCreate(rangeNetworkCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a range network
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeNetworksApi
     */
    public rangeNetworksDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentRangeNetworksApiFp(this.configuration).rangeNetworksDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List range networks
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {RangeNetworksListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {RangeNetworksListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeNetworksApi
     */
    public rangeNetworksList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: RangeNetworksListSortByEnum, sort?: RangeNetworksListSortEnum, options?: RawAxiosRequestConfig) {
        return RangeContentRangeNetworksApiFp(this.configuration).rangeNetworksList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a range network
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeNetworksApi
     */
    public rangeNetworksRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentRangeNetworksApiFp(this.configuration).rangeNetworksRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a range network
     * @param {string} uuid 
     * @param {RangeNetworkUpdate} [rangeNetworkUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeNetworksApi
     */
    public rangeNetworksUpdate(uuid: string, rangeNetworkUpdate?: RangeNetworkUpdate, options?: RawAxiosRequestConfig) {
        return RangeContentRangeNetworksApiFp(this.configuration).rangeNetworksUpdate(uuid, rangeNetworkUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RangeNetworksListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author'
} as const;
export type RangeNetworksListSortByEnum = typeof RangeNetworksListSortByEnum[keyof typeof RangeNetworksListSortByEnum];
/**
 * @export
 */
export const RangeNetworksListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type RangeNetworksListSortEnum = typeof RangeNetworksListSortEnum[keyof typeof RangeNetworksListSortEnum];


/**
 * RangeContentRangePKIsApi - axios parameter creator
 * @export
 */
export const RangeContentRangePKIsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a range PKI
         * @param {RangePkiCreate} [rangePkiCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangePkIsCreate: async (rangePkiCreate?: RangePkiCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/range-pkis`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangePkiCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a range PKI
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangePkIsDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangePkIsDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-pkis/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List range PKIs
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [parentCAHost] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangePkIsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangePkIsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangePkIsList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, parentCAHost?: string, offset?: number, limit?: number, search?: string, sortBy?: RangePkIsListSortByEnum, sort?: RangePkIsListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/range-pkis`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (parentCAHost !== undefined) {
                localVarQueryParameter['parentCAHost'] = parentCAHost;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a range PKI
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangePkIsRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangePkIsRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-pkis/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a range PKI
         * @param {string} uuid 
         * @param {RangePkiUpdate} [rangePkiUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangePkIsUpdate: async (uuid: string, rangePkiUpdate?: RangePkiUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangePkIsUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-pkis/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangePkiUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RangeContentRangePKIsApi - functional programming interface
 * @export
 */
export const RangeContentRangePKIsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RangeContentRangePKIsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a range PKI
         * @param {RangePkiCreate} [rangePkiCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangePkIsCreate(rangePkiCreate?: RangePkiCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangePki>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangePkIsCreate(rangePkiCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangePKIsApi.rangePkIsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a range PKI
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangePkIsDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangePkIsDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangePKIsApi.rangePkIsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List range PKIs
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [parentCAHost] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangePkIsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangePkIsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangePkIsList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, parentCAHost?: string, offset?: number, limit?: number, search?: string, sortBy?: RangePkIsListSortByEnum, sort?: RangePkIsListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangePkIsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangePkIsList(uuid, name, description, author, metadata, parentCAHost, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangePKIsApi.rangePkIsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a range PKI
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangePkIsRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangePki>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangePkIsRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangePKIsApi.rangePkIsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a range PKI
         * @param {string} uuid 
         * @param {RangePkiUpdate} [rangePkiUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangePkIsUpdate(uuid: string, rangePkiUpdate?: RangePkiUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangePki>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangePkIsUpdate(uuid, rangePkiUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangePKIsApi.rangePkIsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RangeContentRangePKIsApi - factory interface
 * @export
 */
export const RangeContentRangePKIsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RangeContentRangePKIsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a range PKI
         * @param {RangePkiCreate} [rangePkiCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangePkIsCreate(rangePkiCreate?: RangePkiCreate, options?: RawAxiosRequestConfig): AxiosPromise<RangePki> {
            return localVarFp.rangePkIsCreate(rangePkiCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a range PKI
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangePkIsDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rangePkIsDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List range PKIs
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [parentCAHost] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangePkIsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangePkIsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangePkIsList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, parentCAHost?: string, offset?: number, limit?: number, search?: string, sortBy?: RangePkIsListSortByEnum, sort?: RangePkIsListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<RangePkIsList200Response> {
            return localVarFp.rangePkIsList(uuid, name, description, author, metadata, parentCAHost, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a range PKI
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangePkIsRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<RangePki> {
            return localVarFp.rangePkIsRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a range PKI
         * @param {string} uuid 
         * @param {RangePkiUpdate} [rangePkiUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangePkIsUpdate(uuid: string, rangePkiUpdate?: RangePkiUpdate, options?: RawAxiosRequestConfig): AxiosPromise<RangePki> {
            return localVarFp.rangePkIsUpdate(uuid, rangePkiUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RangeContentRangePKIsApi - object-oriented interface
 * @export
 * @class RangeContentRangePKIsApi
 * @extends {BaseAPI}
 */
export class RangeContentRangePKIsApi extends BaseAPI {
    /**
     * 
     * @summary Create a range PKI
     * @param {RangePkiCreate} [rangePkiCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangePKIsApi
     */
    public rangePkIsCreate(rangePkiCreate?: RangePkiCreate, options?: RawAxiosRequestConfig) {
        return RangeContentRangePKIsApiFp(this.configuration).rangePkIsCreate(rangePkiCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a range PKI
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangePKIsApi
     */
    public rangePkIsDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentRangePKIsApiFp(this.configuration).rangePkIsDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List range PKIs
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {string} [parentCAHost] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {RangePkIsListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {RangePkIsListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangePKIsApi
     */
    public rangePkIsList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, parentCAHost?: string, offset?: number, limit?: number, search?: string, sortBy?: RangePkIsListSortByEnum, sort?: RangePkIsListSortEnum, options?: RawAxiosRequestConfig) {
        return RangeContentRangePKIsApiFp(this.configuration).rangePkIsList(uuid, name, description, author, metadata, parentCAHost, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a range PKI
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangePKIsApi
     */
    public rangePkIsRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentRangePKIsApiFp(this.configuration).rangePkIsRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a range PKI
     * @param {string} uuid 
     * @param {RangePkiUpdate} [rangePkiUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangePKIsApi
     */
    public rangePkIsUpdate(uuid: string, rangePkiUpdate?: RangePkiUpdate, options?: RawAxiosRequestConfig) {
        return RangeContentRangePKIsApiFp(this.configuration).rangePkIsUpdate(uuid, rangePkiUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RangePkIsListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author',
    ParentCaHost: 'parentCAHost'
} as const;
export type RangePkIsListSortByEnum = typeof RangePkIsListSortByEnum[keyof typeof RangePkIsListSortByEnum];
/**
 * @export
 */
export const RangePkIsListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type RangePkIsListSortEnum = typeof RangePkIsListSortEnum[keyof typeof RangePkIsListSortEnum];


/**
 * RangeContentRangeRoutersApi - axios parameter creator
 * @export
 */
export const RangeContentRangeRoutersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a range router
         * @param {RangeRouterCreate} [rangeRouterCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeRoutersCreate: async (rangeRouterCreate?: RangeRouterCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/range-routers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeRouterCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a range router
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeRoutersDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeRoutersDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-routers/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List range routers
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [countryCode] 
         * @param {string} [hostname] 
         * @param {string} [protocol] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeRoutersListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeRoutersListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeRoutersList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, countryCode?: string, hostname?: string, protocol?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeRoutersListSortByEnum, sort?: RangeRoutersListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/range-routers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (countryCode !== undefined) {
                localVarQueryParameter['countryCode'] = countryCode;
            }

            if (hostname !== undefined) {
                localVarQueryParameter['hostname'] = hostname;
            }

            if (protocol !== undefined) {
                localVarQueryParameter['protocol'] = protocol;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a range router
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeRoutersRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeRoutersRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-routers/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a range router
         * @param {string} uuid 
         * @param {RangeRouterUpdate} [rangeRouterUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeRoutersUpdate: async (uuid: string, rangeRouterUpdate?: RangeRouterUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeRoutersUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-routers/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeRouterUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RangeContentRangeRoutersApi - functional programming interface
 * @export
 */
export const RangeContentRangeRoutersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RangeContentRangeRoutersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a range router
         * @param {RangeRouterCreate} [rangeRouterCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeRoutersCreate(rangeRouterCreate?: RangeRouterCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeRouter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeRoutersCreate(rangeRouterCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeRoutersApi.rangeRoutersCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a range router
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeRoutersDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeRoutersDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeRoutersApi.rangeRoutersDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List range routers
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [countryCode] 
         * @param {string} [hostname] 
         * @param {string} [protocol] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeRoutersListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeRoutersListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeRoutersList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, countryCode?: string, hostname?: string, protocol?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeRoutersListSortByEnum, sort?: RangeRoutersListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeRoutersList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeRoutersList(uuid, name, description, author, metadata, countryCode, hostname, protocol, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeRoutersApi.rangeRoutersList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a range router
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeRoutersRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeRouter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeRoutersRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeRoutersApi.rangeRoutersRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a range router
         * @param {string} uuid 
         * @param {RangeRouterUpdate} [rangeRouterUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeRoutersUpdate(uuid: string, rangeRouterUpdate?: RangeRouterUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeRouter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeRoutersUpdate(uuid, rangeRouterUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeRoutersApi.rangeRoutersUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RangeContentRangeRoutersApi - factory interface
 * @export
 */
export const RangeContentRangeRoutersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RangeContentRangeRoutersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a range router
         * @param {RangeRouterCreate} [rangeRouterCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeRoutersCreate(rangeRouterCreate?: RangeRouterCreate, options?: RawAxiosRequestConfig): AxiosPromise<RangeRouter> {
            return localVarFp.rangeRoutersCreate(rangeRouterCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a range router
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeRoutersDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rangeRoutersDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List range routers
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [countryCode] 
         * @param {string} [hostname] 
         * @param {string} [protocol] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeRoutersListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeRoutersListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeRoutersList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, countryCode?: string, hostname?: string, protocol?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeRoutersListSortByEnum, sort?: RangeRoutersListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<RangeRoutersList200Response> {
            return localVarFp.rangeRoutersList(uuid, name, description, author, metadata, countryCode, hostname, protocol, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a range router
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeRoutersRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<RangeRouter> {
            return localVarFp.rangeRoutersRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a range router
         * @param {string} uuid 
         * @param {RangeRouterUpdate} [rangeRouterUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeRoutersUpdate(uuid: string, rangeRouterUpdate?: RangeRouterUpdate, options?: RawAxiosRequestConfig): AxiosPromise<RangeRouter> {
            return localVarFp.rangeRoutersUpdate(uuid, rangeRouterUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RangeContentRangeRoutersApi - object-oriented interface
 * @export
 * @class RangeContentRangeRoutersApi
 * @extends {BaseAPI}
 */
export class RangeContentRangeRoutersApi extends BaseAPI {
    /**
     * 
     * @summary Create a range router
     * @param {RangeRouterCreate} [rangeRouterCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeRoutersApi
     */
    public rangeRoutersCreate(rangeRouterCreate?: RangeRouterCreate, options?: RawAxiosRequestConfig) {
        return RangeContentRangeRoutersApiFp(this.configuration).rangeRoutersCreate(rangeRouterCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a range router
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeRoutersApi
     */
    public rangeRoutersDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentRangeRoutersApiFp(this.configuration).rangeRoutersDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List range routers
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {string} [countryCode] 
     * @param {string} [hostname] 
     * @param {string} [protocol] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {RangeRoutersListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {RangeRoutersListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeRoutersApi
     */
    public rangeRoutersList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, countryCode?: string, hostname?: string, protocol?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeRoutersListSortByEnum, sort?: RangeRoutersListSortEnum, options?: RawAxiosRequestConfig) {
        return RangeContentRangeRoutersApiFp(this.configuration).rangeRoutersList(uuid, name, description, author, metadata, countryCode, hostname, protocol, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a range router
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeRoutersApi
     */
    public rangeRoutersRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentRangeRoutersApiFp(this.configuration).rangeRoutersRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a range router
     * @param {string} uuid 
     * @param {RangeRouterUpdate} [rangeRouterUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeRoutersApi
     */
    public rangeRoutersUpdate(uuid: string, rangeRouterUpdate?: RangeRouterUpdate, options?: RawAxiosRequestConfig) {
        return RangeContentRangeRoutersApiFp(this.configuration).rangeRoutersUpdate(uuid, rangeRouterUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RangeRoutersListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author',
    CountryCode: 'countryCode'
} as const;
export type RangeRoutersListSortByEnum = typeof RangeRoutersListSortByEnum[keyof typeof RangeRoutersListSortByEnum];
/**
 * @export
 */
export const RangeRoutersListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type RangeRoutersListSortEnum = typeof RangeRoutersListSortEnum[keyof typeof RangeRoutersListSortEnum];


/**
 * RangeContentRangeTorNetsApi - axios parameter creator
 * @export
 */
export const RangeContentRangeTorNetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a range tor net
         * @param {RangeTorNetCreate} [rangeTorNetCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeTorNetsCreate: async (rangeTorNetCreate?: RangeTorNetCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/range-tor-nets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeTorNetCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a range tor net
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeTorNetsDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeTorNetsDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-tor-nets/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List range tor nets
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {RangeTorNetsListVersionEnum} [version] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeTorNetsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeTorNetsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeTorNetsList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, version?: RangeTorNetsListVersionEnum, offset?: number, limit?: number, search?: string, sortBy?: RangeTorNetsListSortByEnum, sort?: RangeTorNetsListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/range-tor-nets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a range tor net
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeTorNetsRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeTorNetsRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-tor-nets/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a range tor net
         * @param {string} uuid 
         * @param {RangeTorNetUpdate} [rangeTorNetUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeTorNetsUpdate: async (uuid: string, rangeTorNetUpdate?: RangeTorNetUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeTorNetsUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-tor-nets/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeTorNetUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RangeContentRangeTorNetsApi - functional programming interface
 * @export
 */
export const RangeContentRangeTorNetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RangeContentRangeTorNetsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a range tor net
         * @param {RangeTorNetCreate} [rangeTorNetCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeTorNetsCreate(rangeTorNetCreate?: RangeTorNetCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeTorNet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeTorNetsCreate(rangeTorNetCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeTorNetsApi.rangeTorNetsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a range tor net
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeTorNetsDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeTorNetsDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeTorNetsApi.rangeTorNetsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List range tor nets
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {RangeTorNetsListVersionEnum} [version] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeTorNetsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeTorNetsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeTorNetsList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, version?: RangeTorNetsListVersionEnum, offset?: number, limit?: number, search?: string, sortBy?: RangeTorNetsListSortByEnum, sort?: RangeTorNetsListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeTorNetsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeTorNetsList(uuid, name, description, author, metadata, version, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeTorNetsApi.rangeTorNetsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a range tor net
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeTorNetsRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeTorNet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeTorNetsRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeTorNetsApi.rangeTorNetsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a range tor net
         * @param {string} uuid 
         * @param {RangeTorNetUpdate} [rangeTorNetUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeTorNetsUpdate(uuid: string, rangeTorNetUpdate?: RangeTorNetUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeTorNet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeTorNetsUpdate(uuid, rangeTorNetUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeTorNetsApi.rangeTorNetsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RangeContentRangeTorNetsApi - factory interface
 * @export
 */
export const RangeContentRangeTorNetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RangeContentRangeTorNetsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a range tor net
         * @param {RangeTorNetCreate} [rangeTorNetCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeTorNetsCreate(rangeTorNetCreate?: RangeTorNetCreate, options?: RawAxiosRequestConfig): AxiosPromise<RangeTorNet> {
            return localVarFp.rangeTorNetsCreate(rangeTorNetCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a range tor net
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeTorNetsDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rangeTorNetsDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List range tor nets
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {RangeTorNetsListVersionEnum} [version] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeTorNetsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeTorNetsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeTorNetsList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, version?: RangeTorNetsListVersionEnum, offset?: number, limit?: number, search?: string, sortBy?: RangeTorNetsListSortByEnum, sort?: RangeTorNetsListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<RangeTorNetsList200Response> {
            return localVarFp.rangeTorNetsList(uuid, name, description, author, metadata, version, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a range tor net
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeTorNetsRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<RangeTorNet> {
            return localVarFp.rangeTorNetsRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a range tor net
         * @param {string} uuid 
         * @param {RangeTorNetUpdate} [rangeTorNetUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeTorNetsUpdate(uuid: string, rangeTorNetUpdate?: RangeTorNetUpdate, options?: RawAxiosRequestConfig): AxiosPromise<RangeTorNet> {
            return localVarFp.rangeTorNetsUpdate(uuid, rangeTorNetUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RangeContentRangeTorNetsApi - object-oriented interface
 * @export
 * @class RangeContentRangeTorNetsApi
 * @extends {BaseAPI}
 */
export class RangeContentRangeTorNetsApi extends BaseAPI {
    /**
     * 
     * @summary Create a range tor net
     * @param {RangeTorNetCreate} [rangeTorNetCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeTorNetsApi
     */
    public rangeTorNetsCreate(rangeTorNetCreate?: RangeTorNetCreate, options?: RawAxiosRequestConfig) {
        return RangeContentRangeTorNetsApiFp(this.configuration).rangeTorNetsCreate(rangeTorNetCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a range tor net
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeTorNetsApi
     */
    public rangeTorNetsDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentRangeTorNetsApiFp(this.configuration).rangeTorNetsDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List range tor nets
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {RangeTorNetsListVersionEnum} [version] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {RangeTorNetsListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {RangeTorNetsListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeTorNetsApi
     */
    public rangeTorNetsList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, version?: RangeTorNetsListVersionEnum, offset?: number, limit?: number, search?: string, sortBy?: RangeTorNetsListSortByEnum, sort?: RangeTorNetsListSortEnum, options?: RawAxiosRequestConfig) {
        return RangeContentRangeTorNetsApiFp(this.configuration).rangeTorNetsList(uuid, name, description, author, metadata, version, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a range tor net
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeTorNetsApi
     */
    public rangeTorNetsRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentRangeTorNetsApiFp(this.configuration).rangeTorNetsRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a range tor net
     * @param {string} uuid 
     * @param {RangeTorNetUpdate} [rangeTorNetUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeTorNetsApi
     */
    public rangeTorNetsUpdate(uuid: string, rangeTorNetUpdate?: RangeTorNetUpdate, options?: RawAxiosRequestConfig) {
        return RangeContentRangeTorNetsApiFp(this.configuration).rangeTorNetsUpdate(uuid, rangeTorNetUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RangeTorNetsListVersionEnum = {
    _04711: '0.4.7.11'
} as const;
export type RangeTorNetsListVersionEnum = typeof RangeTorNetsListVersionEnum[keyof typeof RangeTorNetsListVersionEnum];
/**
 * @export
 */
export const RangeTorNetsListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author',
    Version: 'version'
} as const;
export type RangeTorNetsListSortByEnum = typeof RangeTorNetsListSortByEnum[keyof typeof RangeTorNetsListSortByEnum];
/**
 * @export
 */
export const RangeTorNetsListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type RangeTorNetsListSortEnum = typeof RangeTorNetsListSortEnum[keyof typeof RangeTorNetsListSortEnum];


/**
 * RangeContentRangeVolumesApi - axios parameter creator
 * @export
 */
export const RangeContentRangeVolumesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a range volume
         * @param {RangeVolumeCreate} [rangeVolumeCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeVolumesCreate: async (rangeVolumeCreate?: RangeVolumeCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/range-volumes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeVolumeCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a range volume
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeVolumesDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeVolumesDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-volumes/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List range volumes
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [volume] 
         * @param {string} [volumeType] 
         * @param {string} [storageClass] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeVolumesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeVolumesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeVolumesList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, volume?: string, volumeType?: string, storageClass?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeVolumesListSortByEnum, sort?: RangeVolumesListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/range-volumes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (volume !== undefined) {
                localVarQueryParameter['volume'] = volume;
            }

            if (volumeType !== undefined) {
                localVarQueryParameter['volumeType'] = volumeType;
            }

            if (storageClass !== undefined) {
                localVarQueryParameter['storageClass'] = storageClass;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a range volume
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeVolumesRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeVolumesRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-volumes/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a range volume
         * @param {string} uuid 
         * @param {RangeVolumeUpdate} [rangeVolumeUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeVolumesUpdate: async (uuid: string, rangeVolumeUpdate?: RangeVolumeUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('rangeVolumesUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/range/range-volumes/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rangeVolumeUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RangeContentRangeVolumesApi - functional programming interface
 * @export
 */
export const RangeContentRangeVolumesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RangeContentRangeVolumesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a range volume
         * @param {RangeVolumeCreate} [rangeVolumeCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeVolumesCreate(rangeVolumeCreate?: RangeVolumeCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeVolume>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeVolumesCreate(rangeVolumeCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeVolumesApi.rangeVolumesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a range volume
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeVolumesDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeVolumesDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeVolumesApi.rangeVolumesDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List range volumes
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [volume] 
         * @param {string} [volumeType] 
         * @param {string} [storageClass] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeVolumesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeVolumesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeVolumesList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, volume?: string, volumeType?: string, storageClass?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeVolumesListSortByEnum, sort?: RangeVolumesListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeVolumesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeVolumesList(uuid, name, description, author, metadata, volume, volumeType, storageClass, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeVolumesApi.rangeVolumesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a range volume
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeVolumesRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeVolume>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeVolumesRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeVolumesApi.rangeVolumesRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a range volume
         * @param {string} uuid 
         * @param {RangeVolumeUpdate} [rangeVolumeUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rangeVolumesUpdate(uuid: string, rangeVolumeUpdate?: RangeVolumeUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeVolume>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rangeVolumesUpdate(uuid, rangeVolumeUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentRangeVolumesApi.rangeVolumesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RangeContentRangeVolumesApi - factory interface
 * @export
 */
export const RangeContentRangeVolumesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RangeContentRangeVolumesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a range volume
         * @param {RangeVolumeCreate} [rangeVolumeCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeVolumesCreate(rangeVolumeCreate?: RangeVolumeCreate, options?: RawAxiosRequestConfig): AxiosPromise<RangeVolume> {
            return localVarFp.rangeVolumesCreate(rangeVolumeCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a range volume
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeVolumesDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.rangeVolumesDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List range volumes
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [volume] 
         * @param {string} [volumeType] 
         * @param {string} [storageClass] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {RangeVolumesListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {RangeVolumesListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeVolumesList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, volume?: string, volumeType?: string, storageClass?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeVolumesListSortByEnum, sort?: RangeVolumesListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<RangeVolumesList200Response> {
            return localVarFp.rangeVolumesList(uuid, name, description, author, metadata, volume, volumeType, storageClass, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a range volume
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeVolumesRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<RangeVolume> {
            return localVarFp.rangeVolumesRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a range volume
         * @param {string} uuid 
         * @param {RangeVolumeUpdate} [rangeVolumeUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rangeVolumesUpdate(uuid: string, rangeVolumeUpdate?: RangeVolumeUpdate, options?: RawAxiosRequestConfig): AxiosPromise<RangeVolume> {
            return localVarFp.rangeVolumesUpdate(uuid, rangeVolumeUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RangeContentRangeVolumesApi - object-oriented interface
 * @export
 * @class RangeContentRangeVolumesApi
 * @extends {BaseAPI}
 */
export class RangeContentRangeVolumesApi extends BaseAPI {
    /**
     * 
     * @summary Create a range volume
     * @param {RangeVolumeCreate} [rangeVolumeCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeVolumesApi
     */
    public rangeVolumesCreate(rangeVolumeCreate?: RangeVolumeCreate, options?: RawAxiosRequestConfig) {
        return RangeContentRangeVolumesApiFp(this.configuration).rangeVolumesCreate(rangeVolumeCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a range volume
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeVolumesApi
     */
    public rangeVolumesDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentRangeVolumesApiFp(this.configuration).rangeVolumesDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List range volumes
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {string} [volume] 
     * @param {string} [volumeType] 
     * @param {string} [storageClass] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {RangeVolumesListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {RangeVolumesListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeVolumesApi
     */
    public rangeVolumesList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, volume?: string, volumeType?: string, storageClass?: string, offset?: number, limit?: number, search?: string, sortBy?: RangeVolumesListSortByEnum, sort?: RangeVolumesListSortEnum, options?: RawAxiosRequestConfig) {
        return RangeContentRangeVolumesApiFp(this.configuration).rangeVolumesList(uuid, name, description, author, metadata, volume, volumeType, storageClass, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a range volume
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeVolumesApi
     */
    public rangeVolumesRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentRangeVolumesApiFp(this.configuration).rangeVolumesRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a range volume
     * @param {string} uuid 
     * @param {RangeVolumeUpdate} [rangeVolumeUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentRangeVolumesApi
     */
    public rangeVolumesUpdate(uuid: string, rangeVolumeUpdate?: RangeVolumeUpdate, options?: RawAxiosRequestConfig) {
        return RangeContentRangeVolumesApiFp(this.configuration).rangeVolumesUpdate(uuid, rangeVolumeUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RangeVolumesListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author',
    Volume: 'volume',
    StorageClass: 'storageClass',
    Storage: 'storage'
} as const;
export type RangeVolumesListSortByEnum = typeof RangeVolumesListSortByEnum[keyof typeof RangeVolumesListSortByEnum];
/**
 * @export
 */
export const RangeVolumesListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type RangeVolumesListSortEnum = typeof RangeVolumesListSortEnum[keyof typeof RangeVolumesListSortEnum];


/**
 * RangeContentScenariosApi - axios parameter creator
 * @export
 */
export const RangeContentScenariosApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a scenario
         * @param {ScenarioCreate} [scenarioCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosCreate: async (scenarioCreate?: ScenarioCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/scenarios`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scenarioCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates scenario ACLs
         * @param {string} uuid 
         * @param {AclScenarioCreate} [aclScenarioCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosCreateAcl: async (uuid: string, aclScenarioCreate?: AclScenarioCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('scenariosCreateAcl', 'uuid', uuid)
            const localVarPath = `/v1/content/range/scenarios/{uuid}/acls`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aclScenarioCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a scenario
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('scenariosDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/range/scenarios/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of scenarios
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [tag] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {ScenariosListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {ScenariosListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, tag?: string, offset?: number, limit?: number, search?: string, sortBy?: ScenariosListSortByEnum, sort?: ScenariosListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/scenarios`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        scenariosListMetadataTags: async (offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/scenarios/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves a scenario
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('scenariosRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/range/scenarios/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves scenario ACLs
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosRetrieveAcl: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('scenariosRetrieveAcl', 'uuid', uuid)
            const localVarPath = `/v1/content/range/scenarios/{uuid}/acls`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves an archived scenario in PCTE standard netspec format
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosRetrievePcteStandardNetspec: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('scenariosRetrievePcteStandardNetspec', 'uuid', uuid)
            const localVarPath = `/v1/content/range/scenarios/{uuid}/pcte-standard-netspec`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve scenario schema
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosRetrieveSchema: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('scenariosRetrieveSchema', 'uuid', uuid)
            const localVarPath = `/v1/content/range/scenarios/{uuid}/schema`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieves an archived scenario in terraform format
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosRetrieveTerraform: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('scenariosRetrieveTerraform', 'uuid', uuid)
            const localVarPath = `/v1/content/range/scenarios/{uuid}/terraform`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a scenario
         * @param {string} uuid 
         * @param {ScenarioUpdate} [scenarioUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosUpdate: async (uuid: string, scenarioUpdate?: ScenarioUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('scenariosUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/range/scenarios/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scenarioUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validates an existing scenario
         * @param {string} uuid 
         * @param {ScenariosValidateRequest} [scenariosValidateRequest] Optional runtime scenario specific overrides
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosValidate: async (uuid: string, scenariosValidateRequest?: ScenariosValidateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('scenariosValidate', 'uuid', uuid)
            const localVarPath = `/v1/content/range/scenarios/{uuid}/validate`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scenariosValidateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validates a scenario before creation
         * @param {ScenariosValidateBeforeCreateRequest} [scenariosValidateBeforeCreateRequest] Optional runtime scenario specific overrides
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosValidateBeforeCreate: async (scenariosValidateBeforeCreateRequest?: ScenariosValidateBeforeCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/scenarios/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scenariosValidateBeforeCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RangeContentScenariosApi - functional programming interface
 * @export
 */
export const RangeContentScenariosApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RangeContentScenariosApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a scenario
         * @param {ScenarioCreate} [scenarioCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scenariosCreate(scenarioCreate?: ScenarioCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scenario>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scenariosCreate(scenarioCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentScenariosApi.scenariosCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates scenario ACLs
         * @param {string} uuid 
         * @param {AclScenarioCreate} [aclScenarioCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scenariosCreateAcl(uuid: string, aclScenarioCreate?: AclScenarioCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AclScenario>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scenariosCreateAcl(uuid, aclScenarioCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentScenariosApi.scenariosCreateAcl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Deletes a scenario
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scenariosDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scenariosDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentScenariosApi.scenariosDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List of scenarios
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [tag] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {ScenariosListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {ScenariosListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scenariosList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, tag?: string, offset?: number, limit?: number, search?: string, sortBy?: ScenariosListSortByEnum, sort?: ScenariosListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScenariosList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scenariosList(uuid, name, description, author, metadata, tag, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentScenariosApi.scenariosList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async scenariosListMetadataTags(offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RangeDnsServersListTagSelectors200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scenariosListMetadataTags(offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentScenariosApi.scenariosListMetadataTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves a scenario
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scenariosRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scenario>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scenariosRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentScenariosApi.scenariosRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves scenario ACLs
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scenariosRetrieveAcl(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AclScenario>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scenariosRetrieveAcl(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentScenariosApi.scenariosRetrieveAcl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves an archived scenario in PCTE standard netspec format
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scenariosRetrievePcteStandardNetspec(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scenariosRetrievePcteStandardNetspec(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentScenariosApi.scenariosRetrievePcteStandardNetspec']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve scenario schema
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scenariosRetrieveSchema(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scenariosRetrieveSchema(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentScenariosApi.scenariosRetrieveSchema']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieves an archived scenario in terraform format
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scenariosRetrieveTerraform(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scenariosRetrieveTerraform(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentScenariosApi.scenariosRetrieveTerraform']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Updates a scenario
         * @param {string} uuid 
         * @param {ScenarioUpdate} [scenarioUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scenariosUpdate(uuid: string, scenarioUpdate?: ScenarioUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scenario>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scenariosUpdate(uuid, scenarioUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentScenariosApi.scenariosUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Validates an existing scenario
         * @param {string} uuid 
         * @param {ScenariosValidateRequest} [scenariosValidateRequest] Optional runtime scenario specific overrides
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scenariosValidate(uuid: string, scenariosValidateRequest?: ScenariosValidateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Validation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scenariosValidate(uuid, scenariosValidateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentScenariosApi.scenariosValidate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Validates a scenario before creation
         * @param {ScenariosValidateBeforeCreateRequest} [scenariosValidateBeforeCreateRequest] Optional runtime scenario specific overrides
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scenariosValidateBeforeCreate(scenariosValidateBeforeCreateRequest?: ScenariosValidateBeforeCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Validation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scenariosValidateBeforeCreate(scenariosValidateBeforeCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentScenariosApi.scenariosValidateBeforeCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RangeContentScenariosApi - factory interface
 * @export
 */
export const RangeContentScenariosApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RangeContentScenariosApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a scenario
         * @param {ScenarioCreate} [scenarioCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosCreate(scenarioCreate?: ScenarioCreate, options?: RawAxiosRequestConfig): AxiosPromise<Scenario> {
            return localVarFp.scenariosCreate(scenarioCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates scenario ACLs
         * @param {string} uuid 
         * @param {AclScenarioCreate} [aclScenarioCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosCreateAcl(uuid: string, aclScenarioCreate?: AclScenarioCreate, options?: RawAxiosRequestConfig): AxiosPromise<AclScenario> {
            return localVarFp.scenariosCreateAcl(uuid, aclScenarioCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a scenario
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.scenariosDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List of scenarios
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {string} [tag] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {ScenariosListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {ScenariosListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, tag?: string, offset?: number, limit?: number, search?: string, sortBy?: ScenariosListSortByEnum, sort?: ScenariosListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<ScenariosList200Response> {
            return localVarFp.scenariosList(uuid, name, description, author, metadata, tag, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        scenariosListMetadataTags(offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<RangeDnsServersListTagSelectors200Response> {
            return localVarFp.scenariosListMetadataTags(offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves a scenario
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<Scenario> {
            return localVarFp.scenariosRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves scenario ACLs
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosRetrieveAcl(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<AclScenario> {
            return localVarFp.scenariosRetrieveAcl(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves an archived scenario in PCTE standard netspec format
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosRetrievePcteStandardNetspec(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.scenariosRetrievePcteStandardNetspec(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve scenario schema
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosRetrieveSchema(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.scenariosRetrieveSchema(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieves an archived scenario in terraform format
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosRetrieveTerraform(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.scenariosRetrieveTerraform(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a scenario
         * @param {string} uuid 
         * @param {ScenarioUpdate} [scenarioUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosUpdate(uuid: string, scenarioUpdate?: ScenarioUpdate, options?: RawAxiosRequestConfig): AxiosPromise<Scenario> {
            return localVarFp.scenariosUpdate(uuid, scenarioUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validates an existing scenario
         * @param {string} uuid 
         * @param {ScenariosValidateRequest} [scenariosValidateRequest] Optional runtime scenario specific overrides
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosValidate(uuid: string, scenariosValidateRequest?: ScenariosValidateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Validation>> {
            return localVarFp.scenariosValidate(uuid, scenariosValidateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validates a scenario before creation
         * @param {ScenariosValidateBeforeCreateRequest} [scenariosValidateBeforeCreateRequest] Optional runtime scenario specific overrides
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scenariosValidateBeforeCreate(scenariosValidateBeforeCreateRequest?: ScenariosValidateBeforeCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Validation>> {
            return localVarFp.scenariosValidateBeforeCreate(scenariosValidateBeforeCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RangeContentScenariosApi - object-oriented interface
 * @export
 * @class RangeContentScenariosApi
 * @extends {BaseAPI}
 */
export class RangeContentScenariosApi extends BaseAPI {
    /**
     * 
     * @summary Create a scenario
     * @param {ScenarioCreate} [scenarioCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentScenariosApi
     */
    public scenariosCreate(scenarioCreate?: ScenarioCreate, options?: RawAxiosRequestConfig) {
        return RangeContentScenariosApiFp(this.configuration).scenariosCreate(scenarioCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates scenario ACLs
     * @param {string} uuid 
     * @param {AclScenarioCreate} [aclScenarioCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentScenariosApi
     */
    public scenariosCreateAcl(uuid: string, aclScenarioCreate?: AclScenarioCreate, options?: RawAxiosRequestConfig) {
        return RangeContentScenariosApiFp(this.configuration).scenariosCreateAcl(uuid, aclScenarioCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a scenario
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentScenariosApi
     */
    public scenariosDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentScenariosApiFp(this.configuration).scenariosDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List of scenarios
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {string} [tag] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {ScenariosListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {ScenariosListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentScenariosApi
     */
    public scenariosList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, tag?: string, offset?: number, limit?: number, search?: string, sortBy?: ScenariosListSortByEnum, sort?: ScenariosListSortEnum, options?: RawAxiosRequestConfig) {
        return RangeContentScenariosApiFp(this.configuration).scenariosList(uuid, name, description, author, metadata, tag, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof RangeContentScenariosApi
     */
    public scenariosListMetadataTags(offset?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return RangeContentScenariosApiFp(this.configuration).scenariosListMetadataTags(offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves a scenario
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentScenariosApi
     */
    public scenariosRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentScenariosApiFp(this.configuration).scenariosRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves scenario ACLs
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentScenariosApi
     */
    public scenariosRetrieveAcl(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentScenariosApiFp(this.configuration).scenariosRetrieveAcl(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves an archived scenario in PCTE standard netspec format
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentScenariosApi
     */
    public scenariosRetrievePcteStandardNetspec(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentScenariosApiFp(this.configuration).scenariosRetrievePcteStandardNetspec(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve scenario schema
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentScenariosApi
     */
    public scenariosRetrieveSchema(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentScenariosApiFp(this.configuration).scenariosRetrieveSchema(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieves an archived scenario in terraform format
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentScenariosApi
     */
    public scenariosRetrieveTerraform(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentScenariosApiFp(this.configuration).scenariosRetrieveTerraform(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a scenario
     * @param {string} uuid 
     * @param {ScenarioUpdate} [scenarioUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentScenariosApi
     */
    public scenariosUpdate(uuid: string, scenarioUpdate?: ScenarioUpdate, options?: RawAxiosRequestConfig) {
        return RangeContentScenariosApiFp(this.configuration).scenariosUpdate(uuid, scenarioUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Validates an existing scenario
     * @param {string} uuid 
     * @param {ScenariosValidateRequest} [scenariosValidateRequest] Optional runtime scenario specific overrides
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentScenariosApi
     */
    public scenariosValidate(uuid: string, scenariosValidateRequest?: ScenariosValidateRequest, options?: RawAxiosRequestConfig) {
        return RangeContentScenariosApiFp(this.configuration).scenariosValidate(uuid, scenariosValidateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Validates a scenario before creation
     * @param {ScenariosValidateBeforeCreateRequest} [scenariosValidateBeforeCreateRequest] Optional runtime scenario specific overrides
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentScenariosApi
     */
    public scenariosValidateBeforeCreate(scenariosValidateBeforeCreateRequest?: ScenariosValidateBeforeCreateRequest, options?: RawAxiosRequestConfig) {
        return RangeContentScenariosApiFp(this.configuration).scenariosValidateBeforeCreate(scenariosValidateBeforeCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ScenariosListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author'
} as const;
export type ScenariosListSortByEnum = typeof ScenariosListSortByEnum[keyof typeof ScenariosListSortByEnum];
/**
 * @export
 */
export const ScenariosListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ScenariosListSortEnum = typeof ScenariosListSortEnum[keyof typeof ScenariosListSortEnum];


/**
 * RangeContentTelemetryAgentsApi - axios parameter creator
 * @export
 */
export const RangeContentTelemetryAgentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a Telemetry Agent
         * @param {TelemetryAgentCreate} [telemetryAgentCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telemetryAgentsCreate: async (telemetryAgentCreate?: TelemetryAgentCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/telemetry-agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(telemetryAgentCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Telemetry Agent
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telemetryAgentsDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('telemetryAgentsDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/range/telemetry-agents/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List telemetry agents
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {TelemetryAgentsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {TelemetryAgentsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telemetryAgentsList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: TelemetryAgentsListSortByEnum, sort?: TelemetryAgentsListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/telemetry-agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a Telemetry Agent
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telemetryAgentsRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('telemetryAgentsRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/range/telemetry-agents/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Telemetry Agent
         * @param {string} uuid 
         * @param {TelemetryAgentUpdate} [telemetryAgentUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telemetryAgentsUpdate: async (uuid: string, telemetryAgentUpdate?: TelemetryAgentUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('telemetryAgentsUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/range/telemetry-agents/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(telemetryAgentUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RangeContentTelemetryAgentsApi - functional programming interface
 * @export
 */
export const RangeContentTelemetryAgentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RangeContentTelemetryAgentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a Telemetry Agent
         * @param {TelemetryAgentCreate} [telemetryAgentCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async telemetryAgentsCreate(telemetryAgentCreate?: TelemetryAgentCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TelemetryAgent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.telemetryAgentsCreate(telemetryAgentCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentTelemetryAgentsApi.telemetryAgentsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a Telemetry Agent
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async telemetryAgentsDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.telemetryAgentsDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentTelemetryAgentsApi.telemetryAgentsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List telemetry agents
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {TelemetryAgentsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {TelemetryAgentsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async telemetryAgentsList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: TelemetryAgentsListSortByEnum, sort?: TelemetryAgentsListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TelemetryAgentsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.telemetryAgentsList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentTelemetryAgentsApi.telemetryAgentsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a Telemetry Agent
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async telemetryAgentsRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TelemetryAgent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.telemetryAgentsRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentTelemetryAgentsApi.telemetryAgentsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a Telemetry Agent
         * @param {string} uuid 
         * @param {TelemetryAgentUpdate} [telemetryAgentUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async telemetryAgentsUpdate(uuid: string, telemetryAgentUpdate?: TelemetryAgentUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TelemetryAgent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.telemetryAgentsUpdate(uuid, telemetryAgentUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentTelemetryAgentsApi.telemetryAgentsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RangeContentTelemetryAgentsApi - factory interface
 * @export
 */
export const RangeContentTelemetryAgentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RangeContentTelemetryAgentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a Telemetry Agent
         * @param {TelemetryAgentCreate} [telemetryAgentCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telemetryAgentsCreate(telemetryAgentCreate?: TelemetryAgentCreate, options?: RawAxiosRequestConfig): AxiosPromise<TelemetryAgent> {
            return localVarFp.telemetryAgentsCreate(telemetryAgentCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Telemetry Agent
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telemetryAgentsDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.telemetryAgentsDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List telemetry agents
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {TelemetryAgentsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {TelemetryAgentsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telemetryAgentsList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: TelemetryAgentsListSortByEnum, sort?: TelemetryAgentsListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<TelemetryAgentsList200Response> {
            return localVarFp.telemetryAgentsList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a Telemetry Agent
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telemetryAgentsRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<TelemetryAgent> {
            return localVarFp.telemetryAgentsRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Telemetry Agent
         * @param {string} uuid 
         * @param {TelemetryAgentUpdate} [telemetryAgentUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        telemetryAgentsUpdate(uuid: string, telemetryAgentUpdate?: TelemetryAgentUpdate, options?: RawAxiosRequestConfig): AxiosPromise<TelemetryAgent> {
            return localVarFp.telemetryAgentsUpdate(uuid, telemetryAgentUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RangeContentTelemetryAgentsApi - object-oriented interface
 * @export
 * @class RangeContentTelemetryAgentsApi
 * @extends {BaseAPI}
 */
export class RangeContentTelemetryAgentsApi extends BaseAPI {
    /**
     * 
     * @summary Create a Telemetry Agent
     * @param {TelemetryAgentCreate} [telemetryAgentCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentTelemetryAgentsApi
     */
    public telemetryAgentsCreate(telemetryAgentCreate?: TelemetryAgentCreate, options?: RawAxiosRequestConfig) {
        return RangeContentTelemetryAgentsApiFp(this.configuration).telemetryAgentsCreate(telemetryAgentCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Telemetry Agent
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentTelemetryAgentsApi
     */
    public telemetryAgentsDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentTelemetryAgentsApiFp(this.configuration).telemetryAgentsDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List telemetry agents
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {TelemetryAgentsListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {TelemetryAgentsListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentTelemetryAgentsApi
     */
    public telemetryAgentsList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: TelemetryAgentsListSortByEnum, sort?: TelemetryAgentsListSortEnum, options?: RawAxiosRequestConfig) {
        return RangeContentTelemetryAgentsApiFp(this.configuration).telemetryAgentsList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a Telemetry Agent
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentTelemetryAgentsApi
     */
    public telemetryAgentsRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentTelemetryAgentsApiFp(this.configuration).telemetryAgentsRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Telemetry Agent
     * @param {string} uuid 
     * @param {TelemetryAgentUpdate} [telemetryAgentUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentTelemetryAgentsApi
     */
    public telemetryAgentsUpdate(uuid: string, telemetryAgentUpdate?: TelemetryAgentUpdate, options?: RawAxiosRequestConfig) {
        return RangeContentTelemetryAgentsApiFp(this.configuration).telemetryAgentsUpdate(uuid, telemetryAgentUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const TelemetryAgentsListSortByEnum = {
    Author: 'author',
    Description: 'description',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Name: 'name'
} as const;
export type TelemetryAgentsListSortByEnum = typeof TelemetryAgentsListSortByEnum[keyof typeof TelemetryAgentsListSortByEnum];
/**
 * @export
 */
export const TelemetryAgentsListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type TelemetryAgentsListSortEnum = typeof TelemetryAgentsListSortEnum[keyof typeof TelemetryAgentsListSortEnum];


/**
 * RangeContentTrafficTrackersApi - axios parameter creator
 * @export
 */
export const RangeContentTrafficTrackersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a Traffic Tracker
         * @param {TrafficTrackerCreate} [trafficTrackerCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trafficTrackersCreate: async (trafficTrackerCreate?: TrafficTrackerCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/traffic-trackers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trafficTrackerCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Traffic Tracker
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trafficTrackersDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('trafficTrackersDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/range/traffic-trackers/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List traffic trackers
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {TrafficTrackersListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {TrafficTrackersListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trafficTrackersList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: TrafficTrackersListSortByEnum, sort?: TrafficTrackersListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/traffic-trackers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a Traffic Tracker
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trafficTrackersRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('trafficTrackersRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/range/traffic-trackers/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a Traffic Tracker
         * @param {string} uuid 
         * @param {TrafficTrackerUpdate} [trafficTrackerUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trafficTrackersUpdate: async (uuid: string, trafficTrackerUpdate?: TrafficTrackerUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('trafficTrackersUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/range/traffic-trackers/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trafficTrackerUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RangeContentTrafficTrackersApi - functional programming interface
 * @export
 */
export const RangeContentTrafficTrackersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RangeContentTrafficTrackersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a Traffic Tracker
         * @param {TrafficTrackerCreate} [trafficTrackerCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trafficTrackersCreate(trafficTrackerCreate?: TrafficTrackerCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrafficTracker>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trafficTrackersCreate(trafficTrackerCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentTrafficTrackersApi.trafficTrackersCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a Traffic Tracker
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trafficTrackersDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trafficTrackersDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentTrafficTrackersApi.trafficTrackersDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List traffic trackers
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {TrafficTrackersListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {TrafficTrackersListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trafficTrackersList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: TrafficTrackersListSortByEnum, sort?: TrafficTrackersListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrafficTrackersList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trafficTrackersList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentTrafficTrackersApi.trafficTrackersList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a Traffic Tracker
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trafficTrackersRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrafficTracker>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trafficTrackersRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentTrafficTrackersApi.trafficTrackersRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a Traffic Tracker
         * @param {string} uuid 
         * @param {TrafficTrackerUpdate} [trafficTrackerUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trafficTrackersUpdate(uuid: string, trafficTrackerUpdate?: TrafficTrackerUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrafficTracker>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trafficTrackersUpdate(uuid, trafficTrackerUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentTrafficTrackersApi.trafficTrackersUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RangeContentTrafficTrackersApi - factory interface
 * @export
 */
export const RangeContentTrafficTrackersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RangeContentTrafficTrackersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a Traffic Tracker
         * @param {TrafficTrackerCreate} [trafficTrackerCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trafficTrackersCreate(trafficTrackerCreate?: TrafficTrackerCreate, options?: RawAxiosRequestConfig): AxiosPromise<TrafficTracker> {
            return localVarFp.trafficTrackersCreate(trafficTrackerCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Traffic Tracker
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trafficTrackersDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.trafficTrackersDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List traffic trackers
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {TrafficTrackersListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {TrafficTrackersListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trafficTrackersList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: TrafficTrackersListSortByEnum, sort?: TrafficTrackersListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<TrafficTrackersList200Response> {
            return localVarFp.trafficTrackersList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a Traffic Tracker
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trafficTrackersRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<TrafficTracker> {
            return localVarFp.trafficTrackersRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a Traffic Tracker
         * @param {string} uuid 
         * @param {TrafficTrackerUpdate} [trafficTrackerUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trafficTrackersUpdate(uuid: string, trafficTrackerUpdate?: TrafficTrackerUpdate, options?: RawAxiosRequestConfig): AxiosPromise<TrafficTracker> {
            return localVarFp.trafficTrackersUpdate(uuid, trafficTrackerUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RangeContentTrafficTrackersApi - object-oriented interface
 * @export
 * @class RangeContentTrafficTrackersApi
 * @extends {BaseAPI}
 */
export class RangeContentTrafficTrackersApi extends BaseAPI {
    /**
     * 
     * @summary Create a Traffic Tracker
     * @param {TrafficTrackerCreate} [trafficTrackerCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentTrafficTrackersApi
     */
    public trafficTrackersCreate(trafficTrackerCreate?: TrafficTrackerCreate, options?: RawAxiosRequestConfig) {
        return RangeContentTrafficTrackersApiFp(this.configuration).trafficTrackersCreate(trafficTrackerCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Traffic Tracker
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentTrafficTrackersApi
     */
    public trafficTrackersDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentTrafficTrackersApiFp(this.configuration).trafficTrackersDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List traffic trackers
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {TrafficTrackersListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {TrafficTrackersListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentTrafficTrackersApi
     */
    public trafficTrackersList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: TrafficTrackersListSortByEnum, sort?: TrafficTrackersListSortEnum, options?: RawAxiosRequestConfig) {
        return RangeContentTrafficTrackersApiFp(this.configuration).trafficTrackersList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a Traffic Tracker
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentTrafficTrackersApi
     */
    public trafficTrackersRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentTrafficTrackersApiFp(this.configuration).trafficTrackersRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a Traffic Tracker
     * @param {string} uuid 
     * @param {TrafficTrackerUpdate} [trafficTrackerUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentTrafficTrackersApi
     */
    public trafficTrackersUpdate(uuid: string, trafficTrackerUpdate?: TrafficTrackerUpdate, options?: RawAxiosRequestConfig) {
        return RangeContentTrafficTrackersApiFp(this.configuration).trafficTrackersUpdate(uuid, trafficTrackerUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const TrafficTrackersListSortByEnum = {
    Author: 'author',
    Description: 'description',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Name: 'name'
} as const;
export type TrafficTrackersListSortByEnum = typeof TrafficTrackersListSortByEnum[keyof typeof TrafficTrackersListSortByEnum];
/**
 * @export
 */
export const TrafficTrackersListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type TrafficTrackersListSortEnum = typeof TrafficTrackersListSortEnum[keyof typeof TrafficTrackersListSortEnum];


/**
 * RangeContentVMSpecificationsApi - axios parameter creator
 * @export
 */
export const RangeContentVMSpecificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a VM specification
         * @param {VmSpecificationCreate} [vmSpecificationCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmSpecificationsCreate: async (vmSpecificationCreate?: VmSpecificationCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/vm-specifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vmSpecificationCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a VM specification
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmSpecificationsDelete: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('vmSpecificationsDelete', 'uuid', uuid)
            const localVarPath = `/v1/content/range/vm-specifications/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List of existing VM specifications
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {VmSpecificationsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {VmSpecificationsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmSpecificationsList: async (uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: VmSpecificationsListSortByEnum, sort?: VmSpecificationsListSortEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/content/range/vm-specifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (author !== undefined) {
                localVarQueryParameter['author'] = author;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a VM specification
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmSpecificationsRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('vmSpecificationsRetrieve', 'uuid', uuid)
            const localVarPath = `/v1/content/range/vm-specifications/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a VM specification
         * @param {string} uuid 
         * @param {VmSpecificationUpdate} [vmSpecificationUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmSpecificationsUpdate: async (uuid: string, vmSpecificationUpdate?: VmSpecificationUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('vmSpecificationsUpdate', 'uuid', uuid)
            const localVarPath = `/v1/content/range/vm-specifications/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vmSpecificationUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RangeContentVMSpecificationsApi - functional programming interface
 * @export
 */
export const RangeContentVMSpecificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RangeContentVMSpecificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a VM specification
         * @param {VmSpecificationCreate} [vmSpecificationCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vmSpecificationsCreate(vmSpecificationCreate?: VmSpecificationCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VMSpecification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vmSpecificationsCreate(vmSpecificationCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentVMSpecificationsApi.vmSpecificationsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a VM specification
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vmSpecificationsDelete(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vmSpecificationsDelete(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentVMSpecificationsApi.vmSpecificationsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List of existing VM specifications
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {VmSpecificationsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {VmSpecificationsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vmSpecificationsList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: VmSpecificationsListSortByEnum, sort?: VmSpecificationsListSortEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VmSpecificationsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vmSpecificationsList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentVMSpecificationsApi.vmSpecificationsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a VM specification
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vmSpecificationsRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VMSpecification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vmSpecificationsRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentVMSpecificationsApi.vmSpecificationsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a VM specification
         * @param {string} uuid 
         * @param {VmSpecificationUpdate} [vmSpecificationUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vmSpecificationsUpdate(uuid: string, vmSpecificationUpdate?: VmSpecificationUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VMSpecification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vmSpecificationsUpdate(uuid, vmSpecificationUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RangeContentVMSpecificationsApi.vmSpecificationsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RangeContentVMSpecificationsApi - factory interface
 * @export
 */
export const RangeContentVMSpecificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RangeContentVMSpecificationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a VM specification
         * @param {VmSpecificationCreate} [vmSpecificationCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmSpecificationsCreate(vmSpecificationCreate?: VmSpecificationCreate, options?: RawAxiosRequestConfig): AxiosPromise<VMSpecification> {
            return localVarFp.vmSpecificationsCreate(vmSpecificationCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a VM specification
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmSpecificationsDelete(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.vmSpecificationsDelete(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List of existing VM specifications
         * @param {string} [uuid] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [author] 
         * @param {{ [key: string]: any; }} [metadata] 
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {string} [search] Search the list partially or fully
         * @param {VmSpecificationsListSortByEnum} [sortBy] Key used to sort the collection by
         * @param {VmSpecificationsListSortEnum} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmSpecificationsList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: VmSpecificationsListSortByEnum, sort?: VmSpecificationsListSortEnum, options?: RawAxiosRequestConfig): AxiosPromise<VmSpecificationsList200Response> {
            return localVarFp.vmSpecificationsList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a VM specification
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmSpecificationsRetrieve(uuid: string, options?: RawAxiosRequestConfig): AxiosPromise<VMSpecification> {
            return localVarFp.vmSpecificationsRetrieve(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a VM specification
         * @param {string} uuid 
         * @param {VmSpecificationUpdate} [vmSpecificationUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmSpecificationsUpdate(uuid: string, vmSpecificationUpdate?: VmSpecificationUpdate, options?: RawAxiosRequestConfig): AxiosPromise<VMSpecification> {
            return localVarFp.vmSpecificationsUpdate(uuid, vmSpecificationUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RangeContentVMSpecificationsApi - object-oriented interface
 * @export
 * @class RangeContentVMSpecificationsApi
 * @extends {BaseAPI}
 */
export class RangeContentVMSpecificationsApi extends BaseAPI {
    /**
     * 
     * @summary Create a VM specification
     * @param {VmSpecificationCreate} [vmSpecificationCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentVMSpecificationsApi
     */
    public vmSpecificationsCreate(vmSpecificationCreate?: VmSpecificationCreate, options?: RawAxiosRequestConfig) {
        return RangeContentVMSpecificationsApiFp(this.configuration).vmSpecificationsCreate(vmSpecificationCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a VM specification
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentVMSpecificationsApi
     */
    public vmSpecificationsDelete(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentVMSpecificationsApiFp(this.configuration).vmSpecificationsDelete(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List of existing VM specifications
     * @param {string} [uuid] 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {string} [author] 
     * @param {{ [key: string]: any; }} [metadata] 
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {string} [search] Search the list partially or fully
     * @param {VmSpecificationsListSortByEnum} [sortBy] Key used to sort the collection by
     * @param {VmSpecificationsListSortEnum} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentVMSpecificationsApi
     */
    public vmSpecificationsList(uuid?: string, name?: string, description?: string, author?: string, metadata?: { [key: string]: any; }, offset?: number, limit?: number, search?: string, sortBy?: VmSpecificationsListSortByEnum, sort?: VmSpecificationsListSortEnum, options?: RawAxiosRequestConfig) {
        return RangeContentVMSpecificationsApiFp(this.configuration).vmSpecificationsList(uuid, name, description, author, metadata, offset, limit, search, sortBy, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a VM specification
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentVMSpecificationsApi
     */
    public vmSpecificationsRetrieve(uuid: string, options?: RawAxiosRequestConfig) {
        return RangeContentVMSpecificationsApiFp(this.configuration).vmSpecificationsRetrieve(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a VM specification
     * @param {string} uuid 
     * @param {VmSpecificationUpdate} [vmSpecificationUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RangeContentVMSpecificationsApi
     */
    public vmSpecificationsUpdate(uuid: string, vmSpecificationUpdate?: VmSpecificationUpdate, options?: RawAxiosRequestConfig) {
        return RangeContentVMSpecificationsApiFp(this.configuration).vmSpecificationsUpdate(uuid, vmSpecificationUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const VmSpecificationsListSortByEnum = {
    Uuid: 'uuid',
    Name: 'name',
    DateCreated: 'dateCreated',
    DateEdited: 'dateEdited',
    Description: 'description',
    Author: 'author'
} as const;
export type VmSpecificationsListSortByEnum = typeof VmSpecificationsListSortByEnum[keyof typeof VmSpecificationsListSortByEnum];
/**
 * @export
 */
export const VmSpecificationsListSortEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type VmSpecificationsListSortEnum = typeof VmSpecificationsListSortEnum[keyof typeof VmSpecificationsListSortEnum];


/**
 * RecentApi - axios parameter creator
 * @export
 */
export const RecentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns a list of recent content accessed.
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recentList: async (offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/recent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RecentApi - functional programming interface
 * @export
 */
export const RecentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RecentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns a list of recent content accessed.
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recentList(offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecentList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recentList(offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RecentApi.recentList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RecentApi - factory interface
 * @export
 */
export const RecentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RecentApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns a list of recent content accessed.
         * @param {number} [offset] Number of objects to skip
         * @param {number} [limit] Number of objects per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recentList(offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<RecentList200Response> {
            return localVarFp.recentList(offset, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RecentApi - object-oriented interface
 * @export
 * @class RecentApi
 * @extends {BaseAPI}
 */
export class RecentApi extends BaseAPI {
    /**
     * 
     * @summary Returns a list of recent content accessed.
     * @param {number} [offset] Number of objects to skip
     * @param {number} [limit] Number of objects per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecentApi
     */
    public recentList(offset?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return RecentApiFp(this.configuration).recentList(offset, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VersionApi - axios parameter creator
 * @export
 */
export const VersionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns information about the current RangeOS API build
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionRetrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication openId required

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VersionApi - functional programming interface
 * @export
 */
export const VersionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VersionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns information about the current RangeOS API build
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async versionRetrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BuildVersionInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.versionRetrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VersionApi.versionRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VersionApi - factory interface
 * @export
 */
export const VersionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VersionApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns information about the current RangeOS API build
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionRetrieve(options?: RawAxiosRequestConfig): AxiosPromise<BuildVersionInfo> {
            return localVarFp.versionRetrieve(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VersionApi - object-oriented interface
 * @export
 * @class VersionApi
 * @extends {BaseAPI}
 */
export class VersionApi extends BaseAPI {
    /**
     * 
     * @summary Returns information about the current RangeOS API build
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionApi
     */
    public versionRetrieve(options?: RawAxiosRequestConfig) {
        return VersionApiFp(this.configuration).versionRetrieve(options).then((request) => request(this.axios, this.basePath));
    }
}



